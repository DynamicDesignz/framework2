#!/usr/bin/perl
###############

##
#         Name: msfweb
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#  Description: Web interface to the Metasploit Exploit Framework
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

# This is a really ghetto proof-of-concept for a web-based exploit interface

# XXX TODO
#	1. IP-based access control
#	2. Basic HTTP authentication
#	3. SSL mode support
#	4. Admin
#	5. Logs
#   6. ShikataGaNai != random via msfweb payload encoder? !?!?!!
#	7. web-based shell console

require 5.6.0;

use strict;
use FindBin qw{$RealBin};
use lib "$RealBin/lib";
use Msf::WebUI;

use POSIX;
use IO::Socket;
use Getopt::Std;

use Carp;

no utf8;

Msf::UI::ActiveStateSucks();

my $ui = Msf::WebUI->new($RealBin);
my $VERSION = $ui->Version;

$ui->SetGlobalEnv('_Console', 'Msf::PayloadComponent::WebConsole');

my @sections = qw{ EXPLOITS PAYLOADS SESSIONS ADMIN LOGS };
my $exploits = { };
my $payloads = { };
my $encoders = { };
my $nops     = { };

my $exploitsIndex;
my $payloadsIndex;
my $encodersIndex;

my $moduleKeys	= { };
my $moduleArch	= { };
my $moduleOS	= { };
my $moduleList	= { };
my $modules	    = { };
my $burl;


my %args = ();
getopts("vha:hr", \%args);

if ($args{h}) { Usage() }
# if ($args{v}) { $verbose++ }

my ($host, $port) = ("127.0.0.1", 55555);
if ($args{a})
{
    ($host, $port) = split(/:/, $args{a});
    if (! $port) { $port = 55555 }
}


print "[*] Starting Metasploit v$VERSION Web Interface on $host:$port...\n";


# Create the inital list of modules
LoadAllModules();

# Cache these lists
if (! $args{'r'}) {
	ExploitList();
	PayloadList();
}

my $ghettoWeb = GhettoWeb->new
(
	'host'	=> $host,
	'port'	=> $port,
	'fnWeb'	=> \&ProcessWebRequest,
	'fnIPC'	=> \&ProcessIPCRequest,
	'fnHRP'	=> \&HTTPRequest,
);

$ghettoWeb->LogFile('/tmp/ghetto.log');
$ghettoWeb->Run();

if ($ghettoWeb->IsError) {
	print STDERR "[*] Error: ".$ghettoWeb->GetError."\n";
}



exit(0);


########################################################
#                 !!! WARNING !!!                      #
#                                                      #
#    Viewing the code below may result in the loss     #
#    of vision, nausea, indigestion, insomnia, or      #
#    even INSTANT DEATH. You have been warned.         #
#                                                      #
########################################################

######################################################################
######################################################################
######################################################################

sub ProcessResRequest {
	my ($req, $cli, $ipc) = @_;

	my %files =
	(
		'LOGO'	=> ['image/jpg', 'msfweb_logo.jpg'],
		'STYLE'	=> ['text/css',  'style.css'],
	);
	
	if ( exists( $files{ $req->{'params'}->{'ID'} } ) ) {
		my ($type, $path) = @{ $files{ $req->{'params'}->{'ID'} } };
		my $data;
		
		if ( open (X, "<$RealBin/data/msfweb/$path") ) {
			while (<X>) { $data .= $_ }
			close (X);
		}
		
		$cli->Send(HTTPResponse(200, $data, $type));
	}
}


sub ProcessIPCRequest {
	my $self	= shift;
	my $ipc		= shift;

	my $req = $ipc->getline || return;
	chomp($req);
	
	my ($cmd, @args) = split(/\s+/, $req);
	return if ! $cmd;
	
	print "[ $ipc ] $cmd ($args[0] | $args[1])\n";
	
	if ($cmd eq 'SESSION') {
		my $sid = $self->SessionNew($ipc);
		$ipc->printflush("SID $sid\n");
	}
	
	# NEW <sid> <pid of exploit pipe handler>
	if ($cmd eq 'NEW') {
		$self->SessionPipePID(@args);
		$ipc->printflush("SHELL\n");
	}
	
	if ($cmd eq 'SHUTDOWN') {
		$ipc->printflush("SHUTDOWN\n");
	}
	
	if ($cmd eq 'GET') {
		my $resp = $self->SessionDataGet($args[0]);
		$ipc->printflush("GET ".unpack("H*", $resp)."\n");
	}
	
	if ($cmd eq 'PUT') {
		my $resp = $self->SessionDataPut($args[0], pack("H*", $args[1]));
		$ipc->printflush("PUT $resp\n");
	}
	
	if ($cmd eq 'CMD') {
		my $out = $self->SessionIPC($args[0]);
		if ($out) {
			$out->printflush("CMD ".$args[1]."\n");
			$ipc->printflush("CMD OK\n");
		}
		else {
			$ipc->printflush("CMD ERROR ($out)\n");
		}

	}
	
	if ($cmd eq 'LIST') {
		$ipc->printflush("LIST 1,2,3,4,5,6,7,8,9\n");
	}
}

sub ProcessWebRequest {
	my $self = shift;
	my ($req, $cli, $ipc) = @_;
    my $state = $req->{'params'};
	my $mbase = $req->{'base'};
	my $res;
	
	# Process resource requests
	if ($req->{'base'} eq 'RESOURCE') {
		ProcessResRequest($req, $cli, $ipc);
		exit(0);
	}

	# Generate the base URL
	$burl = "/$mbase?";
	
	# Reload all modules only when the -r option has been specified
	if (exists($args{'r'})) {
		LoadAllModules();
	}
	
	# Start with a standard header
	$res .= HTML_Header($req);
	
    my $logaction;
    if (defined (my $mid = $state->{'MODULE'} )) {

		my $mname;
		        
		if ($mbase eq 'EXPLOITS' && exists($exploits->{$mid}) ) {
			$mname = $exploits->{$mid}->Name;
		}
		
		if ($mbase eq 'PAYLOADS' && exists($payloads->{$mid}) ) {
			$mname = $payloads->{$mid}->Name;
		}
		
		if (! defined($mname)) {
			$mname = 'Invalid Module';
		}						

        $res .= "<table width=100% bgcolor='black'>\n";
		$res .= "<tr><td class='textBold'>Module: $mname</td></tr>\n";
		$res .= "</table><br/>\n";
    }

    $state->{'client'} = $cli;
	$state->{'parent'} = $ipc;
	
	if ($req->{'base'} eq 'EXPLOITS') {
		
    	if ($state->{'MODE'} eq 'MAIN')    { $res .= ExploitList($state) }
		if ($state->{'MODE'} eq 'SELECT')  { $res .= ExploitTarget($state) }
    	if ($state->{'MODE'} eq 'PAYLOAD') { $res .= ExploitPayload($state) }
    	if ($state->{'MODE'} eq 'OPTIONS') { $res .= ExploitOptions($state) }
    	if ($state->{'MODE'} eq 'TARGETS') { $res .= ExploitTargets($state) }
    	if ($state->{'MODE'} eq 'CHECK')   { $res .= ExploitCheck($state) }

    	# ExploitExec doesn't return on success
    	if ($state->{'MODE'} eq 'EXPLOIT') { $res .= ExploitExec($state) }

		$res .= HTML_Footer();  
	}

	if ($req->{'base'} eq 'PAYLOADS') {
	
    	if ($state->{'MODE'} eq 'MAIN')      { $res .= PayloadList($state) }
		if ($state->{'MODE'} eq 'SELECT')    { $res .= PayloadOptions($state) }
		if ($state->{'MODE'} eq 'GENERATE')  { $res .= PayloadGenerate($state) }
		$res .= HTML_Footer();
	}
	
	if ($req->{'base'} eq 'SESSIONS') {
	
    	if ($state->{'MODE'} eq 'MAIN')      { $res .= SessionList($state) }
		if ($state->{'MODE'} eq 'LOAD')      { $res = SessionLoad($state) }
		if ($state->{'MODE'} eq 'COMMAND')   { $res = SessionCommand($state) }
		if ($state->{'MODE'} eq 'UPDATE')    { $res = SessionUpdate($state) }
	}	
			
    
	
    $cli->Send(HTTPResponse(200, $res));
    $cli->Close();
	
    exit(0);
}

sub Usage {
    print STDERR "Usage: $0 -a hostname:port [-v -r]\n";
    exit(0);
}


sub HTML_Header {
	my $req = shift;
	
    my $header = qq
[<html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
		<link type='text/css' rel='stylesheet' href='/RESOURCE?ID=STYLE'>
    </head>
    <body bgcolor='white' text='black'>
<a name='Top'></a>

<br/>
<div align='center'><img src='/RESOURCE?ID=LOGO'></div>
<br/>

<table align='center' cellpadding=0 border=0 cellspacing=0 width='98%' bgcolor='#000000'>
<tr><td>
<table align='center' cellpadding=8 border=0 cellspacing=1 width='100%'>
<tr>
];

	my $lastTab = 'tabLight';
	my $currTab;
	
	my $width = int( 100 / scalar(@sections) ) .'%';
	foreach my $section (@sections) {
		$lastTab = ($lastTab eq 'tabLight') ? 'tabDark' : 'tabLight';
		$currTab = ($section eq $req->{'base'}) ? 'tabActive' : $lastTab;
		
		$header .= qq[
                <td class='$currTab' width='$width' align='center'> <a href='/$section'>$section</a> </td>		
		];
	}
	$header .= qq[
        </tr>

        <tr>
                <td colspan=5 bgcolor='#ffffff'>
                <br/>
	];
	
	return $header;

}

sub HTML_Footer {
    return qq[
		<br/>
		</td>
	</tr>
</table></td></tr></table>
<br/>
<div align='center' class='copy'>
	copyright &copy 2003-2005 metasploit.com<br/>
</div>
</body>
</html>
	];
}

sub URLEncode {
    my ($data) = @_;
    my $res;
    foreach (split(//, $data))  
    { $res .= sprintf("%%%.2x", ord($_)) }
    return $res;
}

sub StateToURL {
    my ($mode, $state) = @_;
    my (%tmp, $res);
    $res = $burl;
	
    foreach (keys(%{$state})) {
        next if $_ eq "client";
        
        my $value = $_ eq "MODE" ? $mode : $state->{$_};
        $res .= $_ . "=" . URLEncode($value) . "&";
    }
    return $res;
}

sub StateToOptions {
    my ($state) = @_;
    my $res = {};
    
    foreach (keys(%{$state})) {
        if (m/^OPT\_(.*)/ && defined($state->{$_})) { $res->{$1} = $state->{$_} }
    }
    return $res;
}

sub SessionList { 
	my $state	= shift;
	my $ipc		= $state->{'parent'}; 
	my $res;
	
	my @slist;
	$ipc->printflush("LIST\n");
	
	if ( defined(my $raw = $ipc->getline) ) {
		chomp($raw);
		my ($cmd, $list) = split(/\s+/, $raw);
		@slist = split(/,/, $list);
	}

	$res .= "<p class='textBold'>Session List:<br\></p>\n";
    $res .= "<table align='center' cellpadding=0 border=0 cellspacing=0 width='95%'>\n";
	$res .= "<tr><td colspan=2><br\></td></tr>\n";

	foreach my $sid (@slist) {
        $res .= "<tr><td class='textNormal'><a href='/SESSIONS?MODE=LOAD&SID=$sid' target='_blank'>Session $sid</a></td></tr>";
	}
	
    $res .= "</table>\n";
	return $res;
}

sub SessionLoad { 
	my $state	= shift;
	my $sid		= $state->{'SID'} + 0;
	my $res		= qq
[<html>
<frameset rows="*, 45" border=0 frameborder=0 framespacing=0>
  <frame src="/SESSIONS?MODE=UPDATE&SID=$sid" name="update">
  <frame src="/SESSIONS?MODE=COMMAND&SID=$sid" name="command">
  <noframes><body>This feature requires frames...</body></noframes>
</frameset>
];
	
	return $res;
}

# Quick command bar to send commands to the shell
sub SessionCommand { 
	my $state	= shift;
	my $sid		= $state->{'SID'} + 0;
	my $res		= qq
[<html>
<body bgcolor='white' text='black'>

<form action='/SESSIONS#END' target='update'>
<input type='hidden' name='MODE' value='UPDATE'>
<input type='hidden' name='SID' value='$sid'>
<input type='text' name='CMD' size=80>
<input type='submit' name='submit' onsumbit='javascript:document.form.CMD="";' value='Send Command'>
<input type='submit' name='clear' value='Clear'>
</form>
</body>
</html>
];
	return $res;
}

sub SessionUpdate { 
	my $state	= shift;
	my $ipc		= $state->{'parent'};
	my $sid		= $state->{'SID'} + 0;
	my $cmd		= $state->{'CMD'};

	my $res		= qq
[<html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
		<link type='text/css' rel='stylesheet' href='/RESOURCE?ID=STYLE'>
		<meta http-equiv='refresh' content='10;URL=/SESSIONS?MODE=UPDATE&SID=$sid#END'>
    </head>
    <body bgcolor='white' text='black'>
	<pre>
];

	# Check for the cache file, open if needed
	my $cache_file = sprintf("$RealBin/data/msfweb/cache%.4x.dat", $sid);
	my $cache_data;
	
	if ($state->{'clear'}) {
		unlink($cache_file);
	}
	
	if (open(CACHE, "<$cache_file")) {
		while (<CACHE>) { $cache_data .= $_ }
		close(CACHE);
	}

	my $raw;

	# Ask the server for any pending data for this session
	$ipc->printflush("GET $sid\n");
	$raw = $ipc->getline;
	
	if ($raw =~ m/GET (\w+)$/) {
		my $data = pack("H*", $1);
		$data = XSS_Filter($data);
		$cache_data .= $data;
	}
	
	if (open(CACHE, ">$cache_file")) {
		print CACHE $cache_data;
		close(CACHE);
	}
	
	if ($cmd) {
		$cmd .= "\n";
		$ipc->printflush("CMD $sid ".unpack("H*", $cmd)."\n");
		$cmd = XSS_Filter($cmd);
		$cache_data .= "<div class='textBold'>&gt;&gt; $cmd</div>";
		$raw = $ipc->getline;
	}
	
	# Give us time to execute the command and load the response
	sleep(1);

	# Ask the server for any pending data for this session
	$ipc->printflush("GET $sid\n");
	$raw = $ipc->getline;
	
	if ($raw =~ m/GET (\w+)$/) {
		my $data = pack("H*", $1);
		$data = XSS_Filter($data);
		$cache_data .= $data;
	}
	
	if (open(CACHE, ">$cache_file")) {
		print CACHE $cache_data;
		close(CACHE);
	}

	$res .= $cache_data;
	$res .= "</pre><br\><br\><a name='END'></a></body></html>";
	return $res;
}


sub PayloadList {
	my $mtype = 'payloads';
	if (! $args{'r'} || ! defined( $moduleList->{$mtype} )) {
		$moduleList->{$mtype} = ModuleList($mtype);
	} 
	return $moduleList->{$mtype};
}

sub ExploitList {
	my $mtype = 'exploits';
	if (! $args{'r'} || ! defined( $moduleList->{$mtype} )) {
		$moduleList->{$mtype} = ModuleList($mtype);
	} 
	return $moduleList->{$mtype};
}

sub ModuleList
{
	my $mtype = shift;
    my $mList;
	my @links;
	
	my $moduleMerge = {};
	my $mKeys		= $moduleKeys->{$mtype};
	my $mOS			= $moduleOS->{$mtype};
	my $mArch		= $moduleArch->{$mtype};
			
	# Navigation header
	$mList = "<div align='center' class='navHead'>Navigation Keys<br/><br/>\n";
	
	# List of mKeys
	if (scalar(keys %{ $mKeys } )) {
		my @links = ();
		foreach my $kname  (sort( keys %{ $mKeys }) ) {
			push @links, "<a href='#$kname' class='nav'>$kname</a> ";
			$moduleMerge->{$kname} = $mKeys->{$kname};
		}
		$mList .= join(" | ", @links) . "<br/><br/>\n";
	}
	
		
	# List of mOS
	if (scalar(keys %{ $mOS } )) {
		my @links = ();	
		foreach my $kname (sort( keys %{ $mOS }) ) {
			push @links, "<a href='#$kname' class='nav'>$kname</a> ";
			$moduleMerge->{$kname} = $mOS->{$kname};
		}
		$mList .= join(" | ", @links) . "<br/><br/>\n";
	}

	# List of mArch
	if (scalar(keys %{ $mArch } )) {
		my @links = ();
		foreach my $kname (sort( keys %{ $mArch}) ) {
			push @links, "<a href='#$kname' class='nav'>$kname</a> ";
			$moduleMerge->{$kname} = $mArch->{$kname};		
		}
		$mList .= join(" | ", @links) . "<br/><br/>\n";
	}
	
	$mList .= "</div><br\>\n";

	# Generate a frame for each unique key, os, and arch
	foreach my $kname (	sort( keys %{ $moduleMerge }) ) {
	
		$mList .= qq[
<a name='$kname'><br/></a>        
<table align='center' cellpadding=1 border=0 cellspacing=0 width='80%' bgcolor='black'>        
	<tr><td>
    <table align='center' cellpadding=8 border=0 cellspacing=0 width='100%' bgcolor='white'>
    <tr>
		<td class='nav' align='left'> $kname </td>
    	<td class='listBody' align='right'><a href='#Top'>Top</a></td>
	</tr>
	<tr><td class='listBody' align='center' colspan=2>
		<blockquote>
		<table align='center' padding=6 border=0 cellspacing=0 width='100%'>
];

	# Dump out all of the matching modules for this key, os, or arch
	foreach my $ename (sort @{ $moduleMerge->{$kname} }) {
		$mList .= "<tr><td>  -  <a href='/". uc($mtype) ."?MODE=SELECT&";
		$mList .= "MODULE=".URLEncode($ename)."'>".$modules->{$mtype}->{$ename}->Name."</a>";
		$mList .= "</td></tr>\n";
	}
	
	$mList .= qq[
		</table>
		</blockquote>
</td></tr></table>
</td></tr></table>
];

	}
    return $mList;
}

sub ModuleInfo {
	my $module = shift;
	my $res;
	
	my $desc = $module->Description();
    $desc =~ s/\</\&lt;/g;
    $desc =~ s/\>/\&gt;/g;
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";
    $res .= "<tr><td align='left' width=80 class='textBold'>Name:</td>";
	$res .= "<td class='textNormal'>" . $module->Name() . "</td></tr>\n";
	
    my ($rev)   = $module->Version() =~ m/\$Revisio.:\s+([^\$]+)/; 
    $res .= "<tr><td align='left' width=80 class='textBold'>Version:</td>";
	$res .= "<td class='textNormal'>" . $rev . "</td></tr>\n";

    my @authors = @{$module->Authors()};
    my $author = shift(@authors);
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $res .= "<tr><td align='left' width=80 class='textBold'>Authors:</td>";
	$res .= "<td class='textNormal'>$author</td></tr>\n";
    
	foreach my $author (@authors) {
        $author =~ s/</&lt;/g;
        $author =~ s/>/&gt;/g;
        $res .= "<tr><td align='left' width=80></td><td class='textNormal'>$author</td></tr>\n";
    }
    
    $res .= "<tr><td colspan=2 class='textNormal'>";
    $res .= "<br/>$desc<br/><br/>";

    foreach my $ref (@{$module->RefLinks}) { $res .= " -  <a href='$ref' target='_blank'>$ref</a><br/>\n" }
	
    $res .= "<br/></td></tr></table>\n";
	return $res;
}

sub PayloadEncoders {
	my $payloadArch	= shift;
	my $payloadOS	= shift;
	my %res;
	
	foreach my $encoderName (keys %{ $encodersIndex }) {
		my $encoder		= $encodersIndex->{$encoderName};		
		my $encoderArch	= $encoder->Arch;
		my $encoderOS	= $encoder->OS;

		next if ! $ui->ListCheck($payloadArch,	$encoderArch);
		next if ! $ui->ListCheck($payloadOS,	$encoderOS);
		$res{ $encoderName } = $encoder;
	}
	return %res;
}

sub PayloadOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 

    if (! exists($payloads->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $p = $payloads->{$module};
    
	$res .= ModuleInfo($p);	 
	  
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";    
    $res .= "<form action='$burl' method='GET'>\n";
    foreach (keys(%{$state})) {
        next if $_ eq 'client';
        if ($_ ne "MODE") {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='GENERATE'>\n";
        }
    }
  
    my $popts =  $p->UserOpts();

    foreach my $popt (sort(keys(%{$popts}))) {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        
        $dflt = Pex::Utils::SourceIP() if $popt eq "LHOST";
        
        $res .= "<tr><td class='textBold'>$popt</td>".
                "<td class='textBold'>$reqd</td>".
				"<td class='textBold'>". $popts->{$popt}->[1] ."</td>".
                "<td class='textBold'><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td class='textNormal'>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
	
    $res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
	
	# Display encoding options only when an arch is set	
	if (scalar( @{ $p->Arch } )) {
		$res .= "<tr><td colspan=6 class='textBold'>";
		$res .= "Max Size: ";
		$res .= "<input type='text' size=10 name='MaxSize' value=''>";
		$res .= "</td></tr>\n";
		
		$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
		
		$res .= "<tr><td colspan=6 class='textBold'>";
		$res .= "Restricted Characters (format: 0x00 0x01)<br\> ";
		$res .= "<input type='text' size=45 name='BadChars' value='0x00 '>";
		$res .= "</td></tr>\n";

		$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";

		my %encoderList = PayloadEncoders($p->Arch, $p->OS);
		
		$res .= "<tr><td colspan=6 class='textBold'>";
		$res .= "Preferred Encoder:<br\> ";
		$res .= "<select name='ENCODER' size=1>\n";
		$res .= "<option value='default'> Default Encoder\n";
		foreach my $encoderName (keys %encoderList) {
			$res .= "<option> $encoderName\n";
		}
		$res .= "</select>\n";
		$res .= "</td></tr>\n";		
	}
	
	$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ACTION' value='Generate Payload'></td></tr>\n";
    $res .= "</form>\n";
    $res .= "</table>\n";  
    return $res;
}



sub PayloadGenerate
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 

    if (! exists($payloads->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $p = $payloads->{$module};
    my $o = StateToOptions($state);
	
	my $optstr;
    foreach my $k (keys(%{ $o })) {
        $ui->SetTempEnv($k, $o->{$k});
		$optstr .= " $k=".$o->{$k};
    }
	
	my $badChars = CharsToBytes($state->{'BadChars'});
	my $maxSize  = $state->{'MaxSize'} || 65000;
	my $rawShell = $p->Build();

	
	my ($payloadArch)	= $p->Arch;
	my ($payloadOS)		= $p->OS;

	my $finalEncoder;
	my $encodedPayload;
	
		
	if (! $badChars) {
		$finalEncoder = 'None';
		$encodedPayload = Msf::EncodedPayload->new($rawShell, $rawShell);
	}
	
	my %encoderList	= PayloadEncoders($payloadArch, $payloadOS);
	my $encoderOpt	= $state->{'ENCODER'};
	
	if ($encoderOpt ne 'default' && ! exists($encoderList{$encoderOpt})) {
		return "<div class='textBold'>Invalid encoder specified!</div>";
	}
	
	# Shrink the list down to the single selected option
	if ($encoderOpt ne 'default') {
		%encoderList = ( $encoderOpt => $encoderList{ $encoderOpt } );
	}
	
	foreach my $encoderName (keys %encoderList) {
		next if ! $badChars;
		
		my $encoder			= $encoderList{$encoderName};
		my $encodedShell	= $encoder->Encode($rawShell, $badChars);

		next if ! $encodedShell;

		if ($encoder->IsError) {
			$encoder->ClearError;
			next;
		}

		next if Pex::Text::BadCharCheck($badChars, $encodedShell);
		
		$encodedPayload = Msf::EncodedPayload->new($rawShell, $encodedShell);

		if (length($encodedPayload->Payload) > $maxSize) {
			undef($encodedPayload);
			next;
		}
		
		$finalEncoder = $encoder->SelfEndName;
		last;
	}

	if (! $encodedPayload) {
    	$res .= "<div class='textBold'>No encoders succeeded :( </div>\n";
		return $res;
	}	
	
	my $sC = Pex::Text::BufferC($encodedPayload->Payload);
	my $sP = Pex::Text::BufferPerl($encodedPayload->Payload);

	if ($p->Multistage) {
		$res .= "<div class='textBold'>Warning: only the loading stage of multi-stage payloads will be displayed!</div>\n<br\>";	
	}



	$optstr =~ s/\<|\>//g;
	$optstr .= " Size=".length($encodedPayload->Payload);
	$optstr .= " Encoder=$finalEncoder";
	
	$res .= "<pre>\n";
	$res .= "<div class='shellcode'>";
	$res .= "/* $module - $optstr http://metasploit.com */\n";
	$res .= "unsigned char scode[] =\n$sC\n\n\n";

	$res .= "# $module - $optstr http://metasploit.com\n";
	$res .= "my \$shellcode =\n$sP\n\n\n";

	$res .= "</div></pre>\n";
	
	return $res;	
}


sub ExploitTarget
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }
    
    my $x = $exploits->{$module};
    
	$res .= ModuleInfo($x);

	# Display available targets

    if (scalar($x->TargetsList) ) {
        $res .= "<table align='center' cellpadding=2 border=0 cellspacing=0 width='95%'>\n";
		$res .= "<tr><td class='textBold' align='left'  colspan=2>Select Target:</td></td>";

		my $tidx = 0;
        foreach my $k ( $x->TargetsList )
        {
            my $u = StateToURL('PAYLOAD', $state);
			my $default;
			
			if ($tidx == $x->DefaultTarget) {
				$default = "(default)";
			}
			
            $res .= "<tr><td align='right' class='textBold'>$tidx - </td><td><a href='".$u."OPT_TARGET=$tidx'> $k $default</a></td></tr>\n";
			$tidx++;
        }
        $res .= "</table>\n";
    } else {
        return ExploitOptions($state);
    }
}

sub ExploitPayload
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }
    
    my $x = $exploits->{$module};

	# Display available payloads

    my $matches = $ui->MatchPayloads($x, $payloads) if($x->Payload);

    if (defined($x->Payload) ) {
		$res .= "<p class='textBold'>Select Payload:<br\></p>\n";
        $res .= "<table align='center' cellpadding=0 border=0 cellspacing=0 width='95%'>\n";
		$res .= "<tr><td class='textBold' align='center'>Payload</td>";
		$res .= "    <td class='textBold' align='center'>Description</td></tr>\n";
		$res .= "<tr><td colspan=2><br\></td></tr>\n";
				
        foreach my $k (sort(keys(%{ $matches })))
        {
            my $u = StateToURL('OPTIONS', $state);
            my $pname = $payloads->{$k}->Name();
            $res .= "<tr><td class='textNormal'><a href='".$u."PAYLOAD=" . $k . "'>$k</a></td>";
            $res .= "<td class='textNormal'>" .$pname . "</td></tr>\n";
        }
        $res .= "</table>\n";
    } else {
        return ExploitOptions($state);
    }
}

sub ExploitOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $x = $exploits->{$module};
    my $p = $payloads->{$state->{'PAYLOAD'}};
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";
        
    if (defined($x->Payload) && ! $state->{"PAYLOAD"})
    {
        $res .=  "<tr><td class='textBold'>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
 
    $res .= "<form action='$burl' method='GET'>\n";
    foreach (keys(%{$state})) {
        next if $_ eq 'client';
        if ($_ ne "MODE") {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
        }
    }

    my $mopts = $x->UserOpts();
    my $popts = defined($x->Payload) ? $p->UserOpts() : {};

    foreach my $mopt (sort(keys(%{$mopts}))) {
        my $dflt = $mopts->{$mopt}->[3];
        my $reqd = $mopts->{$mopt}->[0] ? "Required" : "Optional";
		
		if (exists($x->AutoOpts->{$mopt})) {
			$dflt = $x->AutoOpts->{$mopt};
		}
		
        $res .= "<tr><td class='textBold'>$mopt</td>".
                "<td class='textBold'>$reqd</td>".
				"<td class='textBold'>". $mopts->{$mopt}->[1] ."</td>".
                "<td class='textBold'><input type='text' name='OPT_$mopt' value='$dflt'></td>".
                "<td class='textNormal'>".$mopts->{$mopt}->[2]."</td></tr>\n";
    }
    
    foreach my $popt (sort(keys(%{$popts}))) {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        
        $dflt = Pex::Utils::SourceIP() if $popt eq "LHOST";
 
 		if (exists($x->AutoOpts->{$popt})) {
			$dflt = $x->AutoOpts->{$popt};
		}
		       
        $res .= "<tr><td class='textBold'>$popt</td>".
                "<td class='textBold'>$reqd</td>".
				"<td class='textBold'>". $popts->{$popt}->[1] ."</td>".
                "<td class='textBold'><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td class='textNormal'>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
    
    $res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Vulnerability Check'></td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Launch Exploit'></td></tr>\n";
    $res .= "</form>\n";
    $res .= "</table>\n";
    return $res;
}

sub ExploitExec
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    my $exploit = $exploits->{$module};
    
    if (! $exploit) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $o = StateToOptions($state);
    foreach my $k (keys(%{ $o })) {
        $ui->SetTempEnv($k, $o->{$k});
    }
    
    $ui->SetTempEnv('PAYLOAD', $state->{'PAYLOAD'});
    
    my $validPayloads = $ui->MatchPayloads($exploit, $payloads) if($exploit->Payload);

    my $payloadName = $ui->GetEnv('PAYLOAD');
    my $payload = $validPayloads->{$payloadName};

    # Mmmmm, candy
    $ui->SetTempEnv('_Exploits', $exploits);
    $ui->SetTempEnv('_Payloads', $payloads);
    $ui->SetTempEnv('_Exploit', $exploit);
    $ui->SetTempEnv('_PayloadName', $payloadName);
    $ui->SetTempEnv('_Payload', $payload);
    $ui->SetTempEnv('_ValidPayloads', $validPayloads);
    $exploit->ApplyAutoOpts;
   
    
    if ($state->{"ExploitAction"} eq "Vulnerability Check") {
        $res .= "\n<form action='$burl' method='GET'>\n";
        foreach (keys(%{$state})) {
            if ($_ ne "MODE")  {
                $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
            } else {
                $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
            }
        }

        $res .= "<input type='submit' name='ExploitAction' value='Launch Exploit'>\n";
        $res .= "</form>\n";
        $res .= "<hr><br/><br/>\n";
        $res .= "<br/><div class='textBold'>Check Results:</div>";
		$res .= "<div class='textNormal'>" . (($ui->Check) ? "Vulnerable" : "Not Vulnerable") . "</div><br/>\n";
        $res .= "<br/>". join("<br/>\n", @{$ui->DumpLines}) . "<br/>\n";
        return $res;
    }
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";
    
    if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) ) {
        $res .=  "<tr><td class='textBold'>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
    
    
    # We hijack the socket from the web service
    my $Browser = $state->{'client'};

	# Use chunked transfer mode to return partial responses
	my $out = "HTTP/1.1 200 OK\r\n".
	          "Connection: close\r\n".
			  "Date: ". HTTPDate()."\r\n".
			  "Content-Type: text/html\r\n".
			  "Transfer-Encoding: chunked\r\n\r\n";
	
    $Browser->Send($out);
	
	$out = HTML_Header().
           "<div class='moduleOutput'>\n".
           "<b>Processing exploit request (".$exploit->Name.")...</b><br/>\n".
           "<b>Using payload: " . $payloadName . "</div><br/>\n".
qq[		   
		<br/>
		</td>
	</tr>
</table></td></tr></table>
<br/>
];


	# Close out the main table and prepare for incremental output
	$out .=
		"<br\><hr size=1 width='80%'>".
		"<div align='center' class='navHead'> Exploit Output </div>\n".
		"<hr size=1 width='80%'><br\>".	
		"<div align='left' class='moduleOutput' bgcolor='#dddddd'>\n".
		"<blockquote><blockquote>\n\n";
	$Browser->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
	
	
	# Ask the parent for a session ID
	$state->{'parent'}->printflush("SESSION\n");
	my $raw = $state->{'parent'}->getline;
	
	if (! $raw || $raw !~ /SID ([0-9]{0,16})/ ) {
		$out = "<div class='textBold'>msfweb: unable to obtain session...</div>";
		$Browser->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
		exit(0);
	}
	
	my ($sid) = $raw =~ m/SID ([0-9]{0,16})/g;

	# debugging
	$out = "[*] msfweb starting with session $sid<br/>\n";
	$Browser->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
	
	# Setup a false stdio for the child process
	my ($einp, $eout, $einp_sock, $eout_sock);
	
	socketpair($einp_sock, $eout_sock, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
	
	my $einp = IO::Handle->new_from_fd(fileno($einp_sock), "a+");
	my $eout = IO::Handle->new_from_fd(fileno($eout_sock), "a+");
	
	# Configure the environment...
	$ui->SetTempEnv('_PipeInput',  $einp);
	$ui->SetTempEnv('_PipeOutput', $einp);
	$ui->SetTempEnv('_GhettoIPC',  $state->{'parent'});
	$ui->SetTempEnv('_SessionID',  $sid);
    $ui->SetTempEnv('_BrowserSocket', $Browser);	
	
	# Save the parent pid
	my $top = $$;
	
	# Now things get interesting :-)
	my $epid = fork();
	
	# The main process will keep our IPC open as long as we stay alive
	if ($epid) {

		my $pout = $state->{'parent'};
				
		# Wait for the go-ahead message from the parent
		my $ok = $pout->getline;
		exit if ! $ok;
		chomp($ok);

		if ($ok eq 'SHUTDOWN') {
			print STDERR "Shutting down the shell server...\n";
			exit(0);
		}
		
		if ($ok ne 'SHELL') {
			print STDERR "Unknown starting command: $ok\n";
			exit(0);
		}

		my $keepRunning = 1;
		
		while ($keepRunning) {
			my $sel = IO::Select->new();
			
			foreach ($eout, $pout) {
				$_->autoflush(1);
				$_->blocking(0);
				$sel->add($_);
			}

			my @rdy = $sel->can_read(0.25);
			foreach my $fd (@rdy) {
				
				# Output from the shell
				if ($fd eq $eout) {
					my ($data, $buff);
					while ($eout->read($buff, 1024)) { $data .= $buff }
					$pout->printflush("PUT $sid ".unpack("H*", $data)."\n");
				}
				
				# Request from the server
				if ($fd eq $pout) {
					my $data = $pout->getline;
					chomp ($data);
					
					if ($data eq 'SHUTDOWN') {
						$eout->close;
						$pout->close;
						$keepRunning = 0;
						next;
					}
					
					if ($data =~ m/CMD\s+(.*)/) {
						my $bytes = pack("H*", $1);
						print STDERR "Writing command $1 to shell\n";
						$eout->printflush($bytes);	
						next;
					}
					
					print STDERR "Unknown server request: $data\n";
				}
			}
		}
		
		exit(0);
	}
	
	# Feel the magic o_0
    $ui->Exploit();
	
	if (! $ui->GetTempEnv('_ShellServer')) {
		$state->{'parent'}->printflush("SHUTDOWN $sid\n");
		print STDERR "Shutting down the shell server process...\n";
	}	

	print STDERR "Exiting exploit loop\n";
    exit(0);
}

# Primitive HTTP request parser
sub HTTPRequest {
	my $self	= shift;
    my $cli		= shift;
	my $opt		= shift;
	
	my $timeout	= exists($opt->{'Timeout'}) ? $opt->{'Timeout'} : 30;
	my $raw		= $cli->Recv(-1, $timeout);
	return {} if ! $raw;
		
	my ($meth, $uri, $path, $query);
	my %headers;
	my %params;

	my @lines	= split(/\n/, $raw);
	my $rmeth	= shift(@lines);
		
	# Parse the request method and URI
	if ($rmeth =~ m/^([^\s]+)\s+([^\s]+)\s+/) {
		$meth	= lc($1);
		$uri	= $2;
	} 
	else { return; }
	
	# Read the HTTP request headers
	foreach my $line (@lines) {
		$line =~ s/\r|\n//g;
		last if $line eq '';
		if ($line =~ m/^([^:]+):(\s+|)(.*)$/) {
			$headers{lc($1)} = $3;	
		}
	}

	# Convert URI encoding to hex encoding
    $uri =~ s/\+/%20/g;
		
	# Split out the path from the query string
	if ($uri =~ m/^([^\?]+)(\?(.*)|)$/) {
		$path	= $1;
		$query	= $3;
	}
	
	# Convert hex encoding to plain text
	$path =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
	
	# Remove some garbage from the request
	$path =~ s/\x00|\x0a|\x0d|\<|\>|\s+$//g;
	
	# Remove parent paths and other bad joojoo
	$path =~ s/\/\.\.\/|\/\.\/|\\//g;
	
	# Convert multiple forward slashes to a single
	$path =~ s/\/+/\//g;

	# Break the invidual variables into chunks
    my @chunks = split(/&/, $query);
    
	# Process the chunks and place into %params
	foreach my $chunk (@chunks) {
        my ($var, $val) = split(/=/, $chunk);
        $val =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $params{$var} = $val;

        # ignore empty values
        $val =~ s/^\s+|\s+$//g;
        
		# strip out some hostile chars
		$val =~ s/\x00|\x0a|\x0d//g;
		
		# avoid cheesy xss attacks
        $val = XSS_Filter($val);      
        
        if (! length($val)) { delete($params{$var}) }
    }
    
    # Create a nice big hash of the request
	my $res  =
	{
		'method'	=> $meth,
		'headers'	=> \%headers,
		'params'	=> \%params,
		'path'		=> $path,
	};

	# Process the URL
	($res->{'base'}) = $path =~ m/^\/([^\?]+)/;
	if (! $res->{'base'}) {
		$res->{'base'} = 'EXPLOITS';
	}

	# Default to main mode
	if (! $res->{'params'}->{'MODE'}) {
		$res->{'params'}->{'MODE'} = 'MAIN';
	}
	
	return $res;
}

sub HTTPResponse {
	my $code = @_ ? shift() : 403;
	my $body = @_ ? shift() : '';
	my $type = @_ ? shift() : 'text/html';
	my $data;
	
	$data = "HTTP/1.1 $code\r\n".
			"Connection: close\r\n".
			"Date: ". HTTPDate() ."\r\n".
	        "Content-Length: ".length($body)."\r\n".
			"Content-Type: $type\r\n".
			"\r\n". $body;

	return $data;
}

sub HTTPDate {
	return strftime("%a, %e %b %Y %H:%M:%S GMT", gmtime());
}

sub CharsToBytes {
	my $chars = shift;
	my $badChars;
	foreach my $hc (split(/\s+/, $chars)) {
		if ($hc =~ m/^0x(.|..)/) {
			$badChars .= chr(hex($hc));
		} else {
			# it isn't hex char... maybe just plain char?
			foreach (split(//, $hc)) {
				$badChars .= $_;
			}
		}
	}
	return $badChars;
}

# XXX - not complete
sub XSS_Filter {
	my $data = shift;
	
	$data =~ s/\</\&lt;/g;
	$data =~ s/\>/\&gt;/g;
	return $data;
}

sub LoadAllModules {
	$exploitsIndex	= $ui->LoadExploits;
	$payloadsIndex	= $ui->LoadPayloads;
	$encodersIndex	= $ui->LoadEncoders;
	$nops			= $ui->LoadNops;

	$moduleKeys		= {};
	$moduleOS		= {};
	$moduleArch		= {};
	$modules		= {};
	
	foreach my $key (keys(%{$exploitsIndex})) {
		my $exploit = $exploitsIndex->{$key};
		
		$exploits->{$exploit->SelfEndName} = $exploit;
		$modules->{'exploits'}->{$exploit->SelfEndName} = $exploit;
		
		foreach my $kname ( @{ $exploit->Keys } ) {
			push @{ $moduleKeys->{'exploits'}->{$kname} }, $exploit->SelfEndName;
		}

		foreach my $kname ( @{ $exploit->OS } ) {
			push @{ $moduleOS->{'exploits'}->{$kname} }, $exploit->SelfEndName;
		}
		
		foreach my $kname ( @{ $exploit->Arch } ) {
			push @{ $moduleArch->{'exploits'}->{$kname} }, $exploit->SelfEndName;
		}				
	}

	foreach my $key (keys(%{$payloadsIndex})) {
		my $payload = $payloadsIndex->{$key};
		
		$payloads->{$payload->SelfEndName} = $payload;
		$modules->{'payloads'}->{$payload->SelfEndName} = $payload;
		
		foreach my $kname ( @{ $payload->OS } ) {
			push @{ $moduleOS->{'payloads'}->{$kname} }, $payload->SelfEndName;
		}
		
		foreach my $kname ( @{ $payload->Arch } ) {
			push @{ $moduleArch->{'payloads'}->{$kname} }, $payload->SelfEndName;
		}				
	}

	foreach my $key (keys(%{$encodersIndex})) {
		my $encoder = $encodersIndex->{$key};
		
		$encoders->{$encoder->SelfEndName} = $encoder;
		$modules->{'encoders'}->{$encoder->SelfEndName} = $encoder;
		
		foreach my $kname ( @{ $encoder->OS } ) {
			push @{ $moduleOS->{'encoders'}->{$kname} }, $encoder->SelfEndName;
		}
		
		foreach my $kname ( @{ $encoder->Arch } ) {
			push @{ $moduleArch->{'encoders'}->{$kname} }, $encoder->SelfEndName;
		}				
	}
		

	$ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
	$ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
	$ui->SetTempEnv('_Encoders', $encodersIndex);
	$ui->SetTempEnv('_Nops', $nops);
	
	
}



####################
package GhettoWeb; #
####################

use POSIX;
use IO::Socket;
use IO::Select;
use Pex;

sub new {
	my $name	= shift;
	my $self	= bless {}, $name;
	$self->_config(@_);
	$self->{'_Session'} = { };
	$self->{'_LastSession'} = 0;	
	return $self;
}

sub _config {
	my $self = shift;
	my %args = @_;
	foreach (keys %args) {
		$self->{'_Config'}->{$_} = $args{$_};
	}
};

sub SessionNext {
	my $self = shift;
	my $curr = $self->{'_LastSession'};
	$self->{'_LastSession'} = $curr + 1;

	return $self->{'_LastSession'};
}

sub SessionNew {
	my $self	= shift;
	my $ipc		= shift;
	my $sid 	= $self->SessionNext;
	
	$self->{'_Session'}->{$sid} =
	{
		'IPC'	=> $ipc,
		'PID'	=> 0,
		'Data'	=> '',
	};
	return $sid;
}

sub SessionDataGet {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});

	my $data = $self->{'_Session'}->{$sid}->{'Data'};
	$self->{'_Session'}->{$sid}->{'Data'} = '';
	return $data;	
}

sub SessionDataPut {
	my $self = shift;
	my $sid  = shift;
	my $data = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});

	$self->{'_Session'}->{$sid}->{'Data'} .= $data;
	return length($self->{'_Session'}->{$sid}->{'Data'});
}

sub SessionPipePID {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});
	$self->{'_Session'}->{$sid}->{'PID'} = shift if @_;
	return $self->{'_Session'}->{$sid}->{'PID'};
}

sub SessionIPC {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});
	$self->{'_Session'}->{$sid}->{'IPC'} = shift if @_;
	return $self->{'_Session'}->{$sid}->{'IPC'};
}

sub IsError {
    my $self = shift;
    return 1 if exists($self->{'_Error'});
    return;
}

sub GetError {
    my $self = shift;
    return if ! exists($self->{'_Error'});
    return $self->{'_Error'};
}

sub SetError {
    my $self = shift;
    my $boom = shift;
    $self->{'_Error'} = $boom;
    return $self->{'_Error'};
}

sub ClearError {
    my $self = shift;
    delete($self->{'_Error'});
}

sub LogFile {
	my $self = shift;
	$self->{'_LogFile'} = shift() if @_;
	return $self->{'_LogFile'};
}

sub Log {
    my $self	= shift;
	my $lvl		= shift;
	my $msg		= @_ ? shift() : return;
	
	if ( open(X, ">>".$self->LogFile) ) {
    	print X scalar(localtime())." <$lvl> $msg\n";
    	close(X);
	}
}



sub Run {
	my $self = shift;
	my $args = $self->{'_Config'};

	my $host  = $args->{'host'};
	my $port  = $args->{'port'};
	my $fnWeb = $args->{'fnWeb'} || sub { };
	my $fnIPC = $args->{'fnIPC'} || sub { };
	my $fnHRP = $args->{'fnHRP'} || sub { };
	
	my $httpd = IO::Socket::INET->new 
	(
    	LocalAddr => $host,
    	LocalPort => $port,
    	ReuseAddr => 1,
    	Listen    => 5,
	);
	
	if (! $httpd) {
		$self->SetError("Failed to start listener: $!");
		return;
	}
	
	$httpd->blocking(0);
	
	$SIG{'CHLD'} = sub { while (waitpid(-1, WNOHANG) == 0) { } };

	my %socketInfo = 
	(
		$httpd	=> [$httpd, 0, 'listener'],
	);

	my $keepRunning = 1;
	
	# The main event loop
	while ($keepRunning) {

		my $sel = IO::Select->new();

		foreach my $s (keys %socketInfo) {
			# Process all but child-side sockets
			if ($socketInfo{$s}->[2] ne 'ipc_child') {
				my $sd = $socketInfo{$s}->[0];

				if (! $sd) {
					$self->Log(1, "socketInfo{ $s } is invalid");
					delete($socketInfo{$s});
					next;
				}

				$sd->blocking(0);
				$sd->autoflush(1);
				$sel->add($sd);
			}
		}

		# Select for new connections and data
		my @ready = $sel->can_read(10);

		# Process each flagged socket
		foreach my $s (@ready) {

			# A new connection
			if ($s eq $httpd) {
				my ($client) = $httpd->accept;
				
				if (! $client) {
					$self->Log(1,  "Accept failed on primary listener socket: $@");
					next;
				}

				$socketInfo{$client} = [$client, 0, 'client'];
				$self->Log(3, "New client connection from ".$client->peerhost);
				next;
			}

			# A new HTTP request
			if ($socketInfo{$s}->[2] eq 'client') {
				my $cli = Msf::Socket::Tcp->new_from_socket($s);
				my $res = $fnHRP->($self, $cli);

				if ($res) {
					my ($par, $chi);

					# Create the comm channel between parent and child
					socketpair($par, $chi, AF_UNIX, SOCK_STREAM, PF_UNSPEC);

					# Spawn off the child process
					my $pid = fork();
					if (! $pid) {
						
						# Close the http listener inside the child
						$httpd->close;
						$self->Log(3,  "fnWeb called with pid $$...");						
						$fnWeb->($self, $res, $cli, $chi);
						exit(0);
					}

					$socketInfo{$par} = [$par, $pid, 'ipc'];
					$socketInfo{$chi} = [$chi, $pid, 'ipc_child'];
				} 
				else {
					eval { $s->shutdown(2); };
					eval { $s->close; };
				}

				# XXX - local cleanup up the original socket?
				delete($socketInfo{$s});
				next;
			}

			# A new IPC request
			if ($socketInfo{$s}->[2] eq 'ipc') {
				$self->Log(3,  "fnIPC called with pid $$ ($s)...");
				$fnIPC->($self, $s);
				next;
			}

			# Unknown socket type...
			$self->Log(1, "Unknown socket type ".$socketInfo{$s}->[2]);
		}

		# Remove sockets attach to dead processes
		foreach my $s (keys %socketInfo) {
			my $spid = $socketInfo{$s}->[1];
			if ($spid && ! kill(0, $spid)) {
				$self->Log(3, "Removed $s ($spid) of type ".$socketInfo{$s}->[2]);
				eval { $socketInfo{$s}->[0]->shutdown(2); };
				eval { $socketInfo{$s}->[0]->close; };
				delete($socketInfo{$s});
			}
		}
	}
}
