#!/usr/bin/perl
###############

##
#         Name: msfweb
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#  Description: Web interface to the Metasploit Exploit Framework
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

# This is a really ghetto proof-of-concept for a web-based exploit interface

require 5.6.0;

use strict;
use FindBin qw{$RealBin};
use lib "$RealBin/lib";
use Msf::WebUI;

use POSIX;
use IO::Socket;
use Getopt::Std;

no utf8;

Msf::UI::ActiveStateSucks();

my $ui = Msf::WebUI->new($RealBin);
my $VERSION = $ui->Version;

$ui->SetGlobalEnv('_Console', 'Msf::PayloadComponent::WebConsole');

my $exploits = { };
my $payloads = { };
my $exploitsIndex;
my $payloadsIndex;
my $encoders;
my $nops;
my $skey = 0;
my $ubase;


my ($x, $opt, $verbose, $cli);

my %args = ();
getopts("vha:hr", \%args);

if ($args{h}) { Usage() }
if ($args{v}) { $verbose++ }

my ($host, $port) = ("127.0.0.1", 55555);
if ($args{a})
{
    ($host, $port) = split(/:/, $args{a});
    if (! $port) { $port = 55555 }
}

my $httpd = IO::Socket::INET->new 
(
    LocalAddr => $host,
    LocalPort => $port,
    ReuseAddr => 1,
    Listen    => 5,
) || die "socket: $!";

print "[*] Starting Metasploit v$VERSION Web Interface on $host:$port...\n";


# Only provides some level of protection when the following conditions are met:
# 1. Access controls prevent a malicious user from obtaining the session key
# 2. Hostile service responses are stripped from remote data

# Go Go Ghetto PRNG!
srand();
for (1 .. (rand() * 128) + 128) {
	$skey ^= ($skey * rand() * 0xffff) + $$;
}

$SIG{'CHLD'} = sub { while (waitpid(-1, WNOHANG) == 0) { } };

# Create the inital list of modules
$exploitsIndex = $ui->LoadExploits;
$payloadsIndex = $ui->LoadPayloads;
$encoders = $ui->LoadEncoders;
$nops     = $ui->LoadNops;

foreach my $key (keys(%{$exploitsIndex})) {
	$exploits->{$exploitsIndex->{$key}->SelfEndName} = $exploitsIndex->{$key};
}

foreach my $key (keys(%{$payloadsIndex})) {
	$payloads->{$payloadsIndex->{$key}->SelfEndName} = $payloadsIndex->{$key};
}

$ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
$ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
$ui->SetTempEnv('_Encoders', $encoders);
$ui->SetTempEnv('_Nops', $nops);


# XXX - figure out logging...
    
while (1)
{
    my ($cs, $add) = $httpd->accept();
    next if ! $cs;
    
    my $child = fork();
    next if $child;

	# Wrap the new socket inside a Msf::Socket object
	my $cli = Msf::Socket::Tcp->new_from_socket($cs);
	
    # Parse the HTTP request
    my $state = HTTPRequest($cli);
    
	# Generate the base URL
	$ubase = "/msf".GenerateSID(inet_aton($cli->PeerAddr))."/";
	
    # Socket was closed
    exit(0) if ! defined($state);
    
    # Request was invalid
    if ($state == -1) {
        $cli->Send(HTTPResponse(500, 'Request Failed'));
        $cli->Close();
        exit(0);
    }


    my $res;
	
	# Reload all modules only when the -r option has been specified
	if (exists($args{'r'})) {
		$exploitsIndex = $ui->LoadExploits;
		$payloadsIndex = $ui->LoadPayloads;
		$encoders = $ui->LoadEncoders;
		$nops     = $ui->LoadNops;
		
		foreach my $key (keys(%{$exploitsIndex})) {
			$exploits->{$exploitsIndex->{$key}->SelfEndName} = $exploitsIndex->{$key};
		}
		
		foreach my $key (keys(%{$payloadsIndex})) {
			$payloads->{$payloadsIndex->{$key}->SelfEndName} = $payloadsIndex->{$key};
		}
		
		$ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
		$ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
		$ui->SetTempEnv('_Encoders', $encoders);
		$ui->SetTempEnv('_Nops', $nops);
	}
	
    my $logaction;
    if ($state->{'MODULE'}) {
        my $mname = exists($exploits->{$state->{'MODULE'}}) 
                    ? $exploits->{$state->{'MODULE'}}->Name() : "Invalid Module";

        $res = "<table width=100% bgcolor='black'><tr><td>".
               "<font color='white'><b>Module: $mname</b></font></td></tr></table><br>\n";
        $logaction = "$mname";
        
        if($state->{'PAYLOAD'}) {
            $logaction .= " PAYLOAD=".$state->{'PAYLOAD'};
        }
        
        if ($state->{'OPT_RHOST'}) {
            $logaction .= " HOST=".$state->{'OPT_RHOST'};
        }
        
        if ($state->{'OPT_RPORT'}) {
            $logaction .= " PORT=".$state->{'OPT_RPORT'};
        }       
    }

    $state->{'client'} = $cli;
    vprint($cli->PeerAddr.":".$cli->PeerPort."  ".$state->{'MODE'}."  $logaction\n");
    
    $res .= ProcessRequest($cli, $state);

    $cli->Send(HTTPResponse(200, $res));
    $cli->Close();
    exit(0);
}

sub Usage {
    print STDERR "Usage: $0 -a hostname:port [-v -r]\n";
    exit(0);
}

sub vprint {
    my ($msg) = @_;
    if ($verbose) { print $msg }
}

sub ProcessRequest {
    my ($cli, $state) = @_;
    my ($html, $body);
   
    $body = "Default Response";

    if ($state->{'MODE'} eq 'MAIN')    { $body = ExploitList($state) }
    if ($state->{'MODE'} eq 'SUMMARY') { $body = ExploitSummary($state) }
    if ($state->{'MODE'} eq 'PAYLOAD') { $body = ExploitPayload($state) }
    if ($state->{'MODE'} eq 'OPTIONS') { $body = ExploitOptions($state) }
    if ($state->{'MODE'} eq 'TARGETS') { $body = ExploitTargets($state) }
    if ($state->{'MODE'} eq 'CHECK')   { $body = ExploitCheck($state) }
    
    # ExploitExec doesn't return on success
    if ($state->{'MODE'} eq 'EXPLOIT') { $body = ExploitExec($state) }    
    
    $html = HTML_Header() . $body . HTML_Footer();
    return($html);
}

sub HTML_Header {
    return qq
    [
    <html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
        <style>
            BODY 
            {
                background:     white;
                font-family:    Verdana, Tahoma, Arial, Helvetica, sans-serif;
                color:          black;
                font-size:      12pt;
                margin:         0;
            }

            A:link          { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}
            A:active        { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}
            A:visited       { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}
            A:hover         { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}

        </style>
    </head>
    <body bgcolor='white' text='black'>
    ];
}

sub HTML_Footer {
    return "
    <br>
    <center>
        <a href='$ubase'>Exploit Listing</a> |
        <a href='http://metasploit.com/'>Metasploit.com</a> |
        <a href='http://s1.amazon.com/exec/varzea/pay/T2FKAC37FCOAYS/103-6224645-8776633'>Donate!</a>
    </center>
    </body>
    </html>";
}

sub URLEncode {
    my ($data) = @_;
    my $res;
    foreach (split(//, $data))  
    { $res .= sprintf("%%%.2x", ord($_)) }
    return $res;
}

sub StateToURL {
    my ($mode, $state) = @_;
    my (%tmp, $res);
    $res = $ubase."?";
	
    foreach (keys(%{$state})) {
        next if $_ eq "client";
        
        my $value = $_ eq "MODE" ? $mode : $state->{$_};
        $res .= $_ . "=" . URLEncode($value) . "&";
    }
    return $res;
}

sub StateToOptions {
    my ($state) = @_;
    my $res = {};
    
    foreach (keys(%{$state})) {
        if (m/^OPT\_(.*)/ && defined($state->{$_})) { $res->{$1} = $state->{$_} }
    }
    return $res;
}

sub ExploitList
{
    my $res;

    $res .= "<table align='center' padding=6 border=0 cellspacing=0 width=750>\n";
    $res .= "<tr><td colspan=2 align='left'><b><h2>Metasploit v$VERSION Exploit Index</h2></b></td></tr>\n";

    foreach my $x (sort(keys(%{$exploits}))) {
        $res .= "<tr><td> <li> </td><td>".
                "<a href='".$ubase."MODE=SUMMARY&MODULE=".
                URLEncode($x)."'>". 
                $exploits->{$x}->Name. 
                "</a></td></tr>\n";
    }

    $res .= "</table>\n";
    return $res;
}

sub ExploitSummary
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<b>Invalid Module</b>";
    }
    
    my $x = $exploits->{$module};
    
    my $desc = $x->Description();
    $desc =~ s/\</\&lt;/g;
    $desc =~ s/\>/\&gt;/g;
    
    $res = "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
    $res .= "<tr><td align='left' width=80><b>Name:</b></td><td>" . $x->Name() . "</td></tr>\n";
    my ($rev)   = $x->Version() =~ m/\$Revisio.:\s+([^\$]+)/; 
    $res .= "<tr><td align='left' width=80><b>Version:</b></td><td>" . $rev . "</td></tr>\n";

    my @authors = @{$x->Authors()};
    my $author = shift(@authors);
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $res .= "<tr><td align='left' width=80><b>Authors:</b></td><td>$author</td></tr>\n";
    foreach my $author (@authors) {
        $author =~ s/</&lt;/g;
        $author =~ s/>/&gt;/g;
        $res .= "<tr><td align='left' width=80></td><td>$author</td></tr>\n";
    }
    
    $res .= "<tr><td colspan=2>";
    $res .= "<br>$desc<br><br>";

    foreach my $ref (@{$x->RefLinks}) { $res .= "<li> <a href='$ref'>$ref</a><br>\n" }

    my $u = StateToURL('PAYLOAD', $state);
    $res .= "<br><a href='$u'>Select Payload</a><br>\n";
    $res .= "</td></tr></table>\n";

    return $res;
}

sub ExploitPayload
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<b>Invalid Module</b>";
    }

    my $x = $exploits->{$module};
    my $matches = $ui->MatchPayloads($x, $payloads) if($x->Payload);

    if (defined($x->Payload) ) {
        $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
        
        foreach my $k (sort(keys(%{ $matches })))
        {
            my $u = StateToURL('OPTIONS', $state);
            my $pname = $payloads->{$k}->Name();
            $res .= "<tr><td><a href='".$u."PAYLOAD=" . $k . "'>$k</a></td>";
            $res .= "<td>" .$pname . "</td></tr>\n";
        }
        $res .= "</table>\n";
    } else {
        return ExploitOptions($state);
    }
}

sub ExploitOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<b>Invalid Module</b>";
    }

    my $x = $exploits->{$module};
    my $p = $payloads->{$state->{'PAYLOAD'}};
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
        
    if (defined($x->Payload) && ! $state->{"PAYLOAD"})
    {
        $res .=  "<tr><td>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
 
    $res .= "<form action='$ubase' method='GET'>\n";
    foreach (keys(%{$state})) {
        next if $_ eq 'client';
        if ($_ ne "MODE") {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
        }
    }

    my $mopts = $x->UserOpts();
    my $popts = defined($x->Payload) ? $p->UserOpts() : {};

    foreach my $mopt (sort(keys(%{$mopts}))) {
        my $dflt = $mopts->{$mopt}->[3];
        my $reqd = $mopts->{$mopt}->[0] ? "Required" : "Optional";
        $res .= "<tr><td><b>$mopt</b></td>".
                "<td>$reqd</td><td>". $mopts->{$mopt}->[1] ."</td>".
                "<td><input type='text' name='OPT_$mopt' value='$dflt'></td>".
                "<td>".$mopts->{$mopt}->[2]."</td></tr>\n";
    }
    
    foreach my $popt (sort(keys(%{$popts}))) {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        
        $dflt = Pex::Utils::SourceIP() if $popt eq "LHOST";
        
        $res .= "<tr><td><b>$popt</b></td>".
                "<td>$reqd</td><td>". $popts->{$popt}->[1] ."</td>".
                "<td><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
    
    if (scalar($x->TargetsList)) {
        my $tidx = 0;
        $res .= "<tr><td colspan=6><br><b>Available Targets:</b><blockquote>\n";
        foreach my $tgt ($x->TargetsList) {
            $res .= "<input type='radio' name='OPT_TARGET' value='$tidx'> $tgt<br>\n";
            $tidx++;
        }
        $res .= "</blockquote></td></tr>\n";
    }
    
    $res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Vulnerability Check'></td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Launch Exploit'></td></tr>\n";
    $res .= "</form>\n";
    $res .= "</table>\n";  
    return $res;
}

sub ExploitExec
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    my $exploit = $exploits->{$module};
    
    if (! $exploit) {
        return "<b>Invalid Module</b>";
    }

    my $o = StateToOptions($state);
    foreach my $k (keys(%{ $o })) {
        $ui->SetTempEnv($k, $o->{$k});
    }
    
    $ui->SetTempEnv('PAYLOAD', $state->{'PAYLOAD'});
    
    my $validPayloads = $ui->MatchPayloads($exploit, $payloads) if($exploit->Payload);

    my $payloadName = $ui->GetEnv('PAYLOAD');
    my $payload = $validPayloads->{$payloadName};

    # Mmmmm, candy
    $ui->SetTempEnv('_Exploits', $exploits);
    $ui->SetTempEnv('_Payloads', $payloads);
    $ui->SetTempEnv('_Exploit', $exploit);
    $ui->SetTempEnv('_PayloadName', $payloadName);
    $ui->SetTempEnv('_Payload', $payload);
    $ui->SetTempEnv('_ValidPayloads', $validPayloads);
    $exploit->ApplyAutoOpts;
   
    
    if ($state->{"ExploitAction"} eq "Vulnerability Check") {
        $res .= "\n<form action='$ubase' method='GET'>\n";
        foreach (keys(%{$state})) {
            if ($_ ne "MODE")  {
                $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
            } else {
                $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
            }
        }

        $res .= "<input type='submit' name='ExploitAction' value='Launch Exploit'>\n";
        $res .= "</form>\n";
        $res .= "<hr><br><br>\n";
        $res .= "<br><b>Check Results:</b> " . (($ui->Check) ? "Vulnerable" : "Not Vulnerable") . "<br>\n";
        $res .= "<br>". join("<br>\n", @{$ui->DumpLines}) . "<br>\n";
        return $res;
    }
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
    
    if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) ) {
        $res .=  "<tr><td>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
    
    
    # We hijack the socket from the web service
    my $Browser = $state->{'client'};

	# Use chunked transfer mode to return partial responses
	my $out = "HTTP/1.1 200 OK\r\n".
	          "Connection: Close\r\n".
			  "Content-Type: text/html\r\n".
			  "Transfer-Encoding: Chunked\r\n\r\n";
	
    $Browser->Send($out);
	
	$out = HTML_Header().
          "<b>Processing exploit request (".$exploit->Name.")...</b><br>\n".
          "<b>Using payload: " . $payloadName . "<br>\n".
          "<pre>\n";
	
	$Browser->Send(sprintf("%x\n%s", length($out), $out));
	
    $ui->SetTempEnv('_BrowserSocket', $Browser);
    $ui->Exploit();

	$out = "\n</pre><br>". HTML_Footer();
	$Browser->Send(sprintf("%x\n%s", length($out), $out));

	$out = "";
	$Browser->Send(sprintf("%x\n%s", length($out), $out));
	
	$Browser->Close;
    
    exit(0);
}

# Primitive HTTP request parser
sub HTTPRequest {
    my $cli = shift;
    my ($url, $state);
	
    my $res = $cli->Recv(-1, 20);
    ($res) = split(/\n/, $res);

	# Extract the URI
    if ($res =~ m/^GET\s+(.*)\s+HTTP\/1\.[01]/) { $url = $1 }
    else {
		print STDERR "Invalid request from ".$cli->PeerAddr()."\n";
		return(-1);
    }
	
	# Extract the session ID
	my ($sid) = $url =~ m/^\/msf([^\/]+)\//;
	my $vid = GenerateSID(inet_aton($cli->PeerAddr));
	
	# Redirect the user if the SID does not match
	if ($sid ne $vid) {
		
		if ($sid) {
			print STDERR "Invalid session ID ($sid != $vid)\n";
		}
		
		my $rdir =
			"HTTP/1.1 302 Rejected\r\n".
			"Location: /msf$vid/\r\n".
			"Connection: Close\r\n".
			"Content-Length: 0\r\n\r\n";

		print STDERR "Redirecting to /msf$vid\n";
		$cli->Send($rdir);
		$cli->Close;
		return;
	}
	
	# Strip some things from the URI
    $url =~ s/^\/+msf[^\/]+\///g;
    $url =~ s/^\?//g;
	
	# Convert URI encoding to hex encoding
    $url =~ s/\+/%20/g;
	
	# Remove some hostile bits from the request
    $url =~ s/\x00|\x0A|\x0D//g;

		
	# Break the invidual variables into chunks
    my @chunks = split(/&/, $url);
    foreach my $chunk (@chunks) {
        my ($var, $val) = split(/=/, $chunk);
        $val =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $state->{$var} = $val;

        # ignore empty values
        $val =~ s/^\s+|\s+$//g;
        
        # remove any < or >'s (silly XSS monkies,there are worse problems here)
        $val =~ s/\<|\>//g;        
        
        if (! length($val)) { delete($state->{$var}) }
    }
    
    if (! $state->{'MODE'}) {
        $state->{'MODE'} = "MAIN";
    }
    
    return $state;
}

sub GenerateSID {
	my $data = shift;
	return unpack("H*", pack('N', $skey) ^ $data);
}

sub HTTPResponse {
	my $code = @_ ? shift() : 403;
	my $body = @_ ? shift() : '';
	my $type = @_ ? shift() : 'text/html';
	my $data;
	
	$data = "$code HTTP/1.1\r\n".
			"Connection: Close\r\n".
	        "Content-Length: ".length($body)."\r\n".
			"Content-Type: $type\r\n".
			"\r\n". $body;

	return $data;
}

