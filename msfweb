#!/usr/bin/perl
###############

##
#         Name: msfweb
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#  Description: Web interface to the Metasploit Exploit Framework
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

# This is a really ghetto proof-of-concept for a web-based exploit interface

require 5.6.0;

use strict;
use FindBin qw{$Bin};
use lib "$Bin/lib";
use Msf::WebUI;

use POSIX;
use IO::Socket;
use Getopt::Std;

Msf::UI::ActiveStateSucks();

my $VERSION = "2.0";

my $ui = Msf::WebUI->new($Bin);

my $exploits = { };
my $payloads = { };
my $exploitsIndex;
my $payloadsIndex;
my $encoders;
my $nops;


my ($x, $opt, $verbose, $cli);

my %args = ();
getopts("vha:", \%args);

if ($args{h}) { Usage() }
if ($args{v}) { $verbose++ }

my ($host, $port) = ("127.0.0.1", 55555);
if ($args{a})
{
    ($host, $port) = split(/:/, $args{a});
    if (! $port) { $port = 55555 }
}

my $httpd = IO::Socket::INET->new 
(
    LocalAddr => $host,
    LocalPort => $port,
    ReuseAddr => 1,
    Listen    => 5,
) || die "socket: $!";

print "[*] Starting Metasploit v$VERSION Web Interface on $host:$port...\n";

$SIG{'CHLD'} = sub { while (waitpid(-1, WNOHANG) == 0) { } };

while (1)
{
    my $add;
    ($cli, $add) = $httpd->accept();
    next if ! $cli;
    
    my $child = fork();
    next if $child;

    # Parse the HTTP request
    my $state = HTTPRequest($cli);
    
    # Socket was closed
    exit if ! defined($state);
    
    # Request was invalid
    if ($state == -1)
    {
        $cli->send("HTTP/1.0 200 OK\r\n\r\nRequest Failed");
        $cli->close();
        exit(0);
    }

    my $res;
    
    # Load up all our modules
    $exploitsIndex = $ui->LoadExploits;
    $payloadsIndex = $ui->LoadPayloads;
    $encoders = $ui->LoadEncoders;
    $nops     = $ui->LoadNops;

    foreach my $key (keys(%{$exploitsIndex})) {
        $exploits->{$exploitsIndex->{$key}->Name} = $exploitsIndex->{$key};
    }
    
    foreach my $key (keys(%{$payloadsIndex})) {
        $payloads->{$payloadsIndex->{$key}->Name} = $payloadsIndex->{$key};
    }

    $ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
    $ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
    $ui->SetTempEnv('_Encoders', $encoders);
    $ui->SetTempEnv('_Nops', $nops);

    if ($state->{'MODULE'})
    {
        my $mname = exists($exploits->{$state->{'MODULE'}}) 
                    ? $exploits->{$state->{'MODULE'}}->Name() : "Invalid Module";

        $res = "<table width=100% bgcolor='black'><tr><td>".
               "<font color='white'><b>Module: $mname</b></font></td></tr></table><br>\n";
    }

    $state->{'client'} = $cli;
    $res .= ProcessRequest($cli, $state);

    $cli->send("HTTP/1.0 200 OK\r\n\r\n$res");
    $cli->close();
    exit(0);
  
}

sub Usage
{
    print STDERR "Usage: $0 -a hostname:port [-v]\n";
    exit(0);
}

sub vprint
{
    my ($msg) = @_;
    if ($verbose) { print $msg }
}

sub ProcessRequest
{
    my ($cli, $state) = @_;
    my ($html, $body);
   
    $body = "Default Response";

    if ($state->{'MODE'} eq 'MAIN')    { $body = ExploitList($state) }
    if ($state->{'MODE'} eq 'SUMMARY') { $body = ExploitSummary($state) }
    if ($state->{'MODE'} eq 'PAYLOAD') { $body = ExploitPayload($state) }
    if ($state->{'MODE'} eq 'OPTIONS') { $body = ExploitOptions($state) }
    if ($state->{'MODE'} eq 'TARGETS') { $body = ExploitTargets($state) }
    if ($state->{'MODE'} eq 'CHECK')   { $body = ExploitCheck($state) }
    
    # ExploitExec doesn't return on success
    if ($state->{'MODE'} eq 'EXPLOIT') { $body = ExploitExec($state) }    
    
    $html = HTML_Header() . $body . HTML_Footer();
    
    return($html);
}

sub HTML_Header
{
    return qq
    [
    <html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
        <style>
            BODY 
            {
                background:     white;
                font-family:    Verdana, Tahoma, Arial, Helvetica, sans-serif;
                color:          black;
                font-size:      14pt;
                margin:         0;
            }

            A:link          { font-size: 14pt; text-decoration: none; color: navy; font-weight: bold;}
            A:active        { font-size: 14pt; text-decoration: none; color: navy; font-weight: bold;}
            A:visited       { font-size: 14pt; text-decoration: none; color: navy; font-weight: bold;}
            A:hover         { font-size: 14pt; text-decoration: none; color: navy; font-weight: bold;}

        </style>
    </head>
    <body bgcolor='white' text='black'>
    ];
}

sub HTML_Footer
{
    return "
    <br>
    <center>
        <a href='/'>Exploit Listing</a> |
        <a href='http://metasploit.com/'>Metasploit.com</a>
    </center>
    </body>
    </html>";
}


sub URLEncode
{
    my ($data) = @_;
    my $res;
    foreach (split(//, $data))  
    { $res .= sprintf("%%%.2x", ord($_)) }
    return $res;
}

sub StateToURL
{
    my ($mode, $state) = @_;
    my (%tmp, $res);
    
    foreach (keys(%{$state})) 
    {
        next if $_ eq "client";
        
        my $value = $_ eq "MODE" ? $mode : $state->{$_};
        $res .= $_ . "=" . URLEncode($value) . "&";
    }
    return $res;
}

sub StateToOptions
{
    my ($state) = @_;
    my $res = {};
    
    foreach (keys(%{$state})) 
    {
        if (m/^OPT\_(.*)/ && defined($state->{$_})) { $res->{$1} = $state->{$_} }
    }
    return $res;
}

sub ExploitList
{
    my $res;

    $res .= "<table align='center' padding=6 border=0 cellspacing=0 width=750>\n";
    $res .= "<tr><td colspan=2 align='left'><b><h2>Metasploit v$VERSION Exploit Index</h2></b></td></tr>\n";

    foreach my $x (sort(keys(%{$exploits})))
    {
        $res .= "<tr><td> <li> </td><td>".
                "<a href='/MODE=SUMMARY&MODULE=".
                URLEncode($x)."'>". 
                $exploits->{$x}->Name. 
                "</a></td></tr>\n";
    }

    $res .= "</table>\n";
    return $res;
}

sub ExploitSummary
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module}))
    {
        return "<b>Invalid Module</b>";
    }
    
    my $x = $exploits->{$module};
    
    my $desc = $x->Description();
    $desc =~ s/\</\&lt;/g;
    $desc =~ s/\>/\&gt;/g;
    
    $res = "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
    
    foreach my $item (qw(Name Version))
    {
        $res .= "<tr><td align='left' width=80><b>$item:</b></td><td>" . $x->$item() . "</td></tr>\n";
    }

    my @authors = @{$x->Authors()};
    my $author = shift(@authors);
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $res .= "<tr><td align='left' width=80><b>Authors:</b></td><td>$author</td></tr>\n";
    foreach my $author (@authors) {
        $author =~ s/</&lt;/g;
        $author =~ s/>/&gt;/g;
        $res .= "<tr><td align='left' width=80></td><td>$author</td></tr>\n";
    }
    
    $res .= "<tr><td colspan=2>";
    $res .= "<br>$desc<br><br>";

    foreach my $ref (@{$x->Refs()}) { $res .= "<li> <a href='$ref'>$ref</a><br>\n" }

    my $u = StateToURL('PAYLOAD', $state);
    $res .= "<br><a href='$u'>Select Payload</a><br>\n";
    $res .= "</td></tr></table>\n";

    return $res;
}

sub ExploitPayload
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module}))
    {
        return "<b>Invalid Module</b>";
    }

    my $x = $exploits->{$module};
    my $matches = $ui->MatchPayloads($x, $payloads) if($x->Payload);

    if (defined($x->Payload) )
    {
        $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
        
        foreach my $k (sort(keys(%{ $matches })))
        {
            my $u = StateToURL('OPTIONS', $state);
            my $pname = $payloads->{$k}->Name();
            $res .= "<tr><td><a href='".$u."PAYLOAD=" . $pname . "'>$pname</a></td>";
            $res .= "<td>" .$payloads->{$k}->Description() . "</td></tr>\n";
        }
        $res .= "</table>\n";
    } else {
        return ExploitOptions($state);
    }
}

sub ExploitOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module}))
    {
        return "<b>Invalid Module</b>";
    }

    my $x = $exploits->{$module};
    my $p = $payloads->{$state->{'PAYLOAD'}};
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
        
    if (defined($x->Payload) && ! $state->{"PAYLOAD"})
    {
        $res .=  "<tr><td>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
 
    $res .= "<form action='/' method='GET'>\n";
    foreach (keys(%{$state}))
    {
        next if $_ eq 'client';
        if ($_ ne "MODE")
        {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
        }
    }

    my $mopts = $x->UserOpts();
    my $popts = defined($x->Payload) ? $p->UserOpts() : {};

    foreach my $mopt (sort(keys(%{$mopts})))
    {
        my $dflt = $mopts->{$mopt}->[3];
        my $reqd = $mopts->{$mopt}->[0] ? "Required" : "Optional";
        $res .= "<tr><td><b>$mopt</b></td>".
                "<td>$reqd</td><td>". $mopts->{$mopt}->[1] ."</td>".
                "<td><input type='text' name='OPT_$mopt' value='$dflt'></td>".
                "<td>".$mopts->{$mopt}->[2]."</td></tr>\n";
    }
    
    foreach my $popt (sort(keys(%{$popts})))
    {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        
        $dflt = Pex::InternetIP() if $popt eq "LHOST";
        
        $res .= "<tr><td><b>$popt</b></td>".
                "<td>$reqd</td><td>". $popts->{$popt}->[1] ."</td>".
                "<td><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
    
    if (scalar($x->TargetsList))
    {
        my $tidx = 0;
        $res .= "<tr><td colspan=6><br><b>Available Targets:</b><blockquote>\n";
        foreach my $tgt ($x->TargetsList)
        {
            $res .= "<input type='radio' name='OPT_TARGET' value='$tidx'> $tgt<br>\n";
            $tidx++;
        }
        $res .= "</blockquote></td></tr>\n";
    }
    
    $res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Vulnerability Check'></td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Launch Exploit'></td></tr>\n";
    $res .= "</form>\n";
    $res .= "</table>\n";  
    return $res;
}

sub ExploitExec
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    my $exploit = $exploits->{$module};
    
    if (! $exploit)
    {
        return "<b>Invalid Module</b>";
    }

    my $o = StateToOptions($state);
    foreach my $k (keys(%{ $o }))
    {
        $ui->SetTempEnv($k, $o->{$k});
    }
    
    $ui->SetTempEnv('PAYLOAD', $state->{'PAYLOAD'});
    
    my $validPayloads = $ui->MatchPayloads($exploit, $payloads) if($exploit->Payload);

    my $payloadName = $ui->GetTempEnv('PAYLOAD');
    my $payload = $validPayloads->{$payloadName};

    # Mmmmm, candy
    $ui->SetTempEnv('_Exploits', $exploits);
    $ui->SetTempEnv('_Payloads', $payloads);
    $ui->SetTempEnv('_Exploit', $exploit);
    $ui->SetTempEnv('_PayloadName', $payloadName);
    $ui->SetTempEnv('_Payload', $payload);
    $ui->SetTempEnv('_ValidPayloads', $validPayloads);
   
    
    if ($state->{"ExploitAction"} eq "Vulnerability Check")
    {
        $res .= "\n<form action='/' method='GET'>\n";
        foreach (keys(%{$state}))
        {
            if ($_ ne "MODE")
            {
                $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
            } else {
                $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
            }
        }

        $res .= "<input type='submit' name='ExploitAction' value='Launch Exploit'>\n";
        $res .= "</form>\n";
        $res .= "<hr><br><br>\n";
        $res .= "<br><b>Check Results:</b> " . (($ui->Check) ? "Vulnerable" : "Not Vulnerable") . "<br>\n";
        $res .= "<br>". join("<br>\n", @{$ui->DumpLines}) . "<br>\n";
        return $res;
    }
    
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
    
    if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) )
    {
        $res .=  "<tr><td>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
    
    
    # we hijack the socket from the web service
    my $cli = $state->{'client'};
    
    $cli->send("HTTP/1.1 200 OK\r\nConnection: Close\r\nContent-type: text/html\r\n\r\n");
    $cli->send(HTML_Header());
    
    $cli->send("<b>Processing exploit request (".$exploit->Name.")...</b><br>\n");
    $cli->send("<b>Using payload: " . $payloadName . "<br>\n");
    Pex::Unblock($cli);
    
    $cli->send("<pre>\n");
    open(STDOUT, ">&=" . fileno($cli));
    open(STDERR, ">&=" . fileno($cli));

    $|++;
    
    $ui->SetTempEnv("BROWSER", $cli);
    $ui->Exploit();
    
    $cli->send(join("<br>\n", @{$ui->DumpLines}));

    $cli->send("\n</pre><br>");
    
    $cli->send(HTML_Footer());
    $cli->shutdown(2);
    $cli->close();
    exit(0);
}

sub HTTPRequest {
    my $cli = shift;
    my $sel = IO::Select->new($cli);
    my ($url, $state);
    my $res = "";
    
    $cli->blocking(0);
    
    my $max = time() + 5;
    while ($max > time() && $res !~ /\r\n/)
    {
        my ($buf, $cnt);
        my ($fd) = $sel->can_read(1);
        next if ! $fd;
        $cnt = sysread($fd, $buf, 2048); 
        return(undef) if $cnt == 0;
        $res .= $buf;    
    }
    ($res) = split(/\n/, $res);

    if ($res =~ m/^GET (.*) HTTP\/1\.[0|1]/) { $url = $1 }
    else 
    {
        print $res;
        return(-1);
    }

    $url =~ s/^\///g;
    $url =~ s/^\?//g;
    $url =~ s/\+/%20/g;
    $url =~ s/\x00|\x0A|\x0D//g;

    my @chunks = split(/&/, $url);
    foreach my $chunk (@chunks)
    {
        my ($var, $val) = split(/=/, $chunk);
        $val =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $state->{$var} = $val;

        # ignore empty values
        $val =~ s/^\s+|\s+$//g;
        if (! length($val)) { delete($state->{$var}) }
    }
    
    if (! $state->{'MODE'})
    {
        $state->{'MODE'} = "MAIN";
    }
    
    return $state;
}
