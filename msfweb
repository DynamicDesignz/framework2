#!/usr/bin/perl
###############

##
#         Name: msfweb
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#  Description: Web interface to the Metasploit Exploit Framework
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

# This is a really ghetto proof-of-concept for a web-based exploit interface

# XXX TODO
#	1. IP-based access control
#	2. Basic HTTP authentication
#	3. SSL mode support
#	4. Payloads
#	5. Encoders
#	6. Nops
#	7. Logs


require 5.6.0;

use strict;
use FindBin qw{$RealBin};
use lib "$RealBin/lib";
use Msf::WebUI;

use POSIX;
use IO::Socket;
use Getopt::Std;

no utf8;

Msf::UI::ActiveStateSucks();

my $ui = Msf::WebUI->new($RealBin);
my $VERSION = $ui->Version;

$ui->SetGlobalEnv('_Console', 'Msf::PayloadComponent::WebConsole');

my @sections = qw{ EXPLOITS PAYLOADS ENCODERS NOPS LOGS };
my $exploits = { };
my $payloads = { };
my $exploitsIndex;
my $payloadsIndex;
my $encoders;
my $nops;

my $exploitKeys	= {};
my $exploitArch	= {};
my $exploitOS	= {};

my $exploitList;

my $burl;
my $skey;


my %args = ();
getopts("vha:hr", \%args);

if ($args{h}) { Usage() }
# if ($args{v}) { $verbose++ }

my ($host, $port) = ("127.0.0.1", 55555);
if ($args{a})
{
    ($host, $port) = split(/:/, $args{a});
    if (! $port) { $port = 55555 }
}


print "[*] Starting Metasploit v$VERSION Web Interface on $host:$port...\n";


# Only provides some level of protection when the following conditions are met:
# 1. Access controls prevent a malicious user from obtaining the session key
# 2. Hostile service responses are stripped from remote data

# Go Go Ghetto PRNG!
srand();
for (1 .. (rand() * 128) + 128) {
	$skey ^= ($skey * rand() * 0xffff) + $$;
}


# Create the inital list of modules
LoadAllModules();

my $ghettoWeb = GhettoWeb->new
(
	'host'	=> $host,
	'port'	=> $port,
	'fnWeb'	=> \&ProcessWebRequest,
	'fnIPC'	=> \&ProcessIPCRequest,
	'fnHRP'	=> \&HTTPRequest,
);

$ghettoWeb->Run();

if ($ghettoWeb->IsError) {
	print STDERR "[*] Error: ".$ghettoWeb->GetError."\n";
}



exit(0);


######################################################################
######################################################################
######################################################################


sub ProcessIPCRequest { 
	my $ipc = shift;
	print "IPC: $ipc\n";
}

sub ProcessWebRequest {
	my ($req, $cli, $ipc) = @_;
    my $state =  $req->{'params'};
	my $res;
	
	# Generate the base URL
	$burl = '/'.$req->{'base'}.'?';
	
	# Reload all modules only when the -r option has been specified
	if (exists($args{'r'})) {
		LoadAllModules();
	}
	
	# Start with a standard header
	$res .= HTML_Header($req);
	
    my $logaction;
    if ($state->{'MODULE'}) {
        my $mname = exists($exploits->{$state->{'MODULE'}}) 
                    ? $exploits->{$state->{'MODULE'}}->Name() : "Invalid Module";

        $res .= "<table width=100% bgcolor='black'><tr><td>".
                "<font color='white'><b>Module: $mname</b></font></td></tr></table><br>\n";
        $logaction = "$mname";  
    }

    $state->{'client'} = $cli;

	if ($req->{'base'} eq 'EXPLOITS') {
	
    	if ($state->{'MODE'} eq 'MAIN')    { $res .= ExploitList($state) }
    	if ($state->{'MODE'} eq 'SUMMARY') { $res .= ExploitSummary($state) }
    	if ($state->{'MODE'} eq 'PAYLOAD') { $res .= ExploitPayload($state) }
    	if ($state->{'MODE'} eq 'OPTIONS') { $res .= ExploitOptions($state) }
    	if ($state->{'MODE'} eq 'TARGETS') { $res .= ExploitTargets($state) }
    	if ($state->{'MODE'} eq 'CHECK')   { $res .= ExploitCheck($state) }

    	# ExploitExec doesn't return on success
    	if ($state->{'MODE'} eq 'EXPLOIT') { $res .= ExploitExec($state) }    
	}
	
    $res .= HTML_Footer();
	
    $cli->Send(HTTPResponse(200, $res));
    $cli->Close();
	
    exit(0);
}

sub Usage {
    print STDERR "Usage: $0 -a hostname:port [-v -r]\n";
    exit(0);
}


sub HTML_Header {
	my $req = shift;
	
    my $header = qq
[<html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
        <style>
            BODY 
            {
                background:     white;
                font-family:    Verdana, Tahoma, Arial, Helvetica, sans-serif;
                color:          black;
                font-size:      12pt;
                margin:         0;
            }

            A:link          { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}
            A:active        { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}
            A:visited       { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}
            A:hover         { font-size: 12pt; text-decoration: none; color: navy; font-weight: bold;}

			.tabDark {
				background:		#dddddd;
				font-size:		12pt;
				font-weight:	bold;
			}
			
			.tabLight {
				background:		#ffffff;
				font-size:		12pt;
				font-weight:	bold;
			}
			
			.tabActive {
				background:		#feff9c;
				color:			black;
				font-size:		12pt;
				font-weight:	bold;
			}
			
			.sectionTitle {
				color:			black;
				font-size:		14pt;
				font-weight:	bold;
			}

			
			.listBody {
				background:		white;
				color:			black;
				font-size:		12pt;
			}
			
			A.nav {
				font-size:		11pt;
				font-weight:	bold;
				font-variant:	small-caps;
			}
			
			.nav { 
				font-size:		13pt;
				font-variant:	small-caps;
				font-weight:	normal;
				font-weight:	bold;
			}
			
			.navHead { 
				font-size:		11pt;
				font-weight:	bold;
			}
		
        </style>
    </head>
    <body bgcolor='white' text='black'>
<a name='Top'></a>
<br/>

<table align='center' cellpadding=0 border=0 cellspacing=0 width='98%' bgcolor='#000000'>
<tr><td>
<table align='center' cellpadding=8 border=0 cellspacing=1 width='100%'>
<tr>
];

	my $lastTab = 'tabLight';
	my $currTab;
	
	foreach my $section (@sections) {
		$lastTab = ($lastTab eq 'tabLight') ? 'tabDark' : 'tabLight';
		$currTab = ($section eq $req->{'base'}) ? 'tabActive' : $lastTab;
		
		$header .= qq[
                <td class='$currTab' width='20%' align='center'> <a href='/$section'>$section</a> </td>		
		];
	}
	$header .= qq[
        </tr>

        <tr>
                <td colspan=5 bgcolor='#ffffff'>
                <br/>
	];
	
	return $header;

}

sub HTML_Footer {
    return qq[
		<br/>
		</td>
	</tr>
</table></td></tr></table>
<br/>
</body>
</html>
	];
}

sub URLEncode {
    my ($data) = @_;
    my $res;
    foreach (split(//, $data))  
    { $res .= sprintf("%%%.2x", ord($_)) }
    return $res;
}

sub StateToURL {
    my ($mode, $state) = @_;
    my (%tmp, $res);
    $res = $burl;
	
    foreach (keys(%{$state})) {
        next if $_ eq "client";
        
        my $value = $_ eq "MODE" ? $mode : $state->{$_};
        $res .= $_ . "=" . URLEncode($value) . "&";
    }
    return $res;
}

sub StateToOptions {
    my ($state) = @_;
    my $res = {};
    
    foreach (keys(%{$state})) {
        if (m/^OPT\_(.*)/ && defined($state->{$_})) { $res->{$1} = $state->{$_} }
    }
    return $res;
}

sub ExploitList
{
    my $eList;
	my @links;
	my $exploitMerge = {};
	
	# Cache the generated page for speed
	if (! $args{'r'} && defined($exploitList) ) {
		return $exploitList;
	}
	
	# Navigation header
	$eList = "<div align='center' class='navHead'>Navigation Keys<br/><br/>\n";
	
	# List of exploitKeys
	foreach my $kname  (sort( keys %{ $exploitKeys }) ) {
		push @links, "<a href='#$kname' class='nav'>$kname</a> ";
		$exploitMerge->{$kname} = $exploitKeys->{$kname};
	}
	$eList .= join(" | ", @links) . "<br/><br/>\n";
	@links = ();
		
	# List of exploitOS
	foreach my $kname (sort( keys %{ $exploitOS }) ) {
		push @links, "<a href='#$kname' class='nav'>$kname</a> ";
		$exploitMerge->{$kname} = $exploitOS->{$kname};
	}
	$eList .= join(" | ", @links) . "<br/><br/>\n";
	@links = ();

	# List of exploitArch
	foreach my $kname (sort( keys %{ $exploitArch}) ) {
		push @links, "<a href='#$kname' class='nav'>$kname</a> ";
		$exploitMerge->{$kname} = $exploitArch->{$kname};		
	}
	$eList .= join(" | ", @links) . "<br/><br/>\n";
	@links = ();
	$eList .= "</div><br\>\n";


	# Generate a frame for each unique key, os, and arch
	foreach my $kname (	sort( keys %{ $exploitMerge }) ) {
	
		$eList .= qq[
<a name='$kname'><br></a>        
<table align='center' cellpadding=1 border=0 cellspacing=0 width='80%' bgcolor='black'>        
	<tr><td>
    <table align='center' cellpadding=8 border=0 cellspacing=0 width='100%' bgcolor='white'>
    <tr>
		<td class='nav' align='left'> $kname </td>
    	<td class='listBody' align='right'><a href='#Top'>Top</a></td>
	</tr>
	<tr><td class='listBody' align='center' colspan=2>
		<blockquote>
		<table align='center' padding=6 border=0 cellspacing=0 width='100%'>
];

	# Dump out all of the matching exploits for this key, os, or arch
	foreach my $ename (sort @{ $exploitMerge->{$kname} }) {
		$eList .= "<tr><td> <li> </td><td><a href='".$burl."MODE=SUMMARY&";
		$eList .= "MODULE=".URLEncode($ename)."'>".$exploits->{$ename}->Name."</a>";
		$eList .= "</td></tr>\n";
	}
	
	$eList .= qq[
		</table>
		</blockquote>
</td></tr></table>
</td></tr></table>
];

	}
	
	$exploitList = $eList;
    return $eList;
}

sub ExploitSummary
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<b>Invalid Module</b>";
    }
    
    my $x = $exploits->{$module};
    
    my $desc = $x->Description();
    $desc =~ s/\</\&lt;/g;
    $desc =~ s/\>/\&gt;/g;
    
    $res = "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
    $res .= "<tr><td align='left' width=80><b>Name:</b></td><td>" . $x->Name() . "</td></tr>\n";
    my ($rev)   = $x->Version() =~ m/\$Revisio.:\s+([^\$]+)/; 
    $res .= "<tr><td align='left' width=80><b>Version:</b></td><td>" . $rev . "</td></tr>\n";

    my @authors = @{$x->Authors()};
    my $author = shift(@authors);
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $res .= "<tr><td align='left' width=80><b>Authors:</b></td><td>$author</td></tr>\n";
    foreach my $author (@authors) {
        $author =~ s/</&lt;/g;
        $author =~ s/>/&gt;/g;
        $res .= "<tr><td align='left' width=80></td><td>$author</td></tr>\n";
    }
    
    $res .= "<tr><td colspan=2>";
    $res .= "<br>$desc<br><br>";

    foreach my $ref (@{$x->RefLinks}) { $res .= "<li> <a href='$ref'>$ref</a><br>\n" }

    my $u = StateToURL('PAYLOAD', $state);
    $res .= "<br><a href='$u'>Select Payload</a><br>\n";
    $res .= "</td></tr></table>\n";

    return $res;
}

sub ExploitPayload
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<b>Invalid Module</b>";
    }

    my $x = $exploits->{$module};
    my $matches = $ui->MatchPayloads($x, $payloads) if($x->Payload);

    if (defined($x->Payload) ) {
        $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
        
        foreach my $k (sort(keys(%{ $matches })))
        {
            my $u = StateToURL('OPTIONS', $state);
            my $pname = $payloads->{$k}->Name();
            $res .= "<tr><td><a href='".$u."PAYLOAD=" . $k . "'>$k</a></td>";
            $res .= "<td>" .$pname . "</td></tr>\n";
        }
        $res .= "</table>\n";
    } else {
        return ExploitOptions($state);
    }
}

sub ExploitOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<b>Invalid Module</b>";
    }

    my $x = $exploits->{$module};
    my $p = $payloads->{$state->{'PAYLOAD'}};
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
        
    if (defined($x->Payload) && ! $state->{"PAYLOAD"})
    {
        $res .=  "<tr><td>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
 
    $res .= "<form action='$burl' method='GET'>\n";
    foreach (keys(%{$state})) {
        next if $_ eq 'client';
        if ($_ ne "MODE") {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
        }
    }

    my $mopts = $x->UserOpts();
    my $popts = defined($x->Payload) ? $p->UserOpts() : {};

    foreach my $mopt (sort(keys(%{$mopts}))) {
        my $dflt = $mopts->{$mopt}->[3];
        my $reqd = $mopts->{$mopt}->[0] ? "Required" : "Optional";
        $res .= "<tr><td><b>$mopt</b></td>".
                "<td>$reqd</td><td>". $mopts->{$mopt}->[1] ."</td>".
                "<td><input type='text' name='OPT_$mopt' value='$dflt'></td>".
                "<td>".$mopts->{$mopt}->[2]."</td></tr>\n";
    }
    
    foreach my $popt (sort(keys(%{$popts}))) {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        
        $dflt = Pex::Utils::SourceIP() if $popt eq "LHOST";
        
        $res .= "<tr><td><b>$popt</b></td>".
                "<td>$reqd</td><td>". $popts->{$popt}->[1] ."</td>".
                "<td><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
    
    if (scalar($x->TargetsList)) {
        my $tidx = 0;
        $res .= "<tr><td colspan=6><br><b>Available Targets:</b><blockquote>\n";
        foreach my $tgt ($x->TargetsList) {
            $res .= "<input type='radio' name='OPT_TARGET' value='$tidx'> $tgt<br>\n";
            $tidx++;
        }
        $res .= "</blockquote></td></tr>\n";
    }
    
    $res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Vulnerability Check'></td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ExploitAction' value='Launch Exploit'></td></tr>\n";
    $res .= "</form>\n";
    $res .= "</table>\n";  
    return $res;
}

sub ExploitExec
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    my $exploit = $exploits->{$module};
    
    if (! $exploit) {
        return "<b>Invalid Module</b>";
    }

    my $o = StateToOptions($state);
    foreach my $k (keys(%{ $o })) {
        $ui->SetTempEnv($k, $o->{$k});
    }
    
    $ui->SetTempEnv('PAYLOAD', $state->{'PAYLOAD'});
    
    my $validPayloads = $ui->MatchPayloads($exploit, $payloads) if($exploit->Payload);

    my $payloadName = $ui->GetEnv('PAYLOAD');
    my $payload = $validPayloads->{$payloadName};

    # Mmmmm, candy
    $ui->SetTempEnv('_Exploits', $exploits);
    $ui->SetTempEnv('_Payloads', $payloads);
    $ui->SetTempEnv('_Exploit', $exploit);
    $ui->SetTempEnv('_PayloadName', $payloadName);
    $ui->SetTempEnv('_Payload', $payload);
    $ui->SetTempEnv('_ValidPayloads', $validPayloads);
    $exploit->ApplyAutoOpts;
   
    
    if ($state->{"ExploitAction"} eq "Vulnerability Check") {
        $res .= "\n<form action='$burl' method='GET'>\n";
        foreach (keys(%{$state})) {
            if ($_ ne "MODE")  {
                $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
            } else {
                $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
            }
        }

        $res .= "<input type='submit' name='ExploitAction' value='Launch Exploit'>\n";
        $res .= "</form>\n";
        $res .= "<hr><br><br>\n";
        $res .= "<br><b>Check Results:</b> " . (($ui->Check) ? "Vulnerable" : "Not Vulnerable") . "<br>\n";
        $res .= "<br>". join("<br>\n", @{$ui->DumpLines}) . "<br>\n";
        return $res;
    }
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width=750>\n";
    
    if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) ) {
        $res .=  "<tr><td>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
    
    
    # We hijack the socket from the web service
    my $Browser = $state->{'client'};

	# Use chunked transfer mode to return partial responses
	my $out = "HTTP/1.1 200 OK\r\n".
	          "Connection: close\r\n".
			  "Date: ". HTTPDate()."\r\n".
			  "Content-Type: text/html\r\n".
			  "Transfer-Encoding: chunked\r\n\r\n";
	
    $Browser->Send($out);
	
	$out = HTML_Header().
          "<b>Processing exploit request (".$exploit->Name.")...</b><br>\n".
          "<b>Using payload: " . $payloadName . "<br>\n".
          "<pre>\n";
	
	$Browser->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
	
    $ui->SetTempEnv('_BrowserSocket', $Browser);
    $ui->Exploit();

	$out = "\n</pre><br>". HTML_Footer();
	$Browser->Send(sprintf("%x\r\n%s\r\n", length($out), $out));

	$out = "";
	$Browser->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
	
	$Browser->Close;
    
    exit(0);
}

# Primitive HTTP request parser
sub HTTPRequest {
    my $cli = shift;
	my $opt = shift;
	
	my $timeout	= exists($opt->{'Timeout'}) ? $opt->{'Timeout'} : 30;
	my $raw		= $cli->Recv(-1, $timeout);
	return {} if ! $raw;
		
	my ($meth, $uri, $path, $query);
	my %headers;
	my %params;

	my @lines	= split(/\n/, $raw);
	my $rmeth	= shift(@lines);
		
	# Parse the request method and URI
	if ($rmeth =~ m/^([^\s]+)\s+([^\s]+)\s+/) {
		$meth	= lc($1);
		$uri	= $2;
	} 
	else { return; }
	
	# Read the HTTP request headers
	foreach my $line (@lines) {
		$line =~ s/\r|\n//g;
		last if $line eq '';
		if ($line =~ m/^([^:]+):(\s+|)(.*)$/) {
			$headers{lc($1)} = $3;	
		}
	}
	
	# Split out the path from the query string
	if ($uri =~ m/^([^\?]+)(\?(.*)|)$/) {
		$path	= $1;
		$query	= $3;
	}
	
	# Convert URI encoding to hex encoding
    $path =~ s/\+/%20/g;
	
	# Convert hex encoding to plain text
	$path =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
	
	# Remove some garbage from the request
	$path =~ s/\x00|\x0a|\x0d|\<|\>|\s+$//g;
	
	# Remove parent paths and other bad joojoo
	$path =~ s/\/\.\.\/|\/\.\/|\\//g;
	
	# Convert multiple forward slashes to a single
	$path =~ s/\/+/\//g;

	# Break the invidual variables into chunks
    my @chunks = split(/&/, $query);
    
	# Process the chunks and place into %params
	foreach my $chunk (@chunks) {
        my ($var, $val) = split(/=/, $chunk);
        $val =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $params{$var} = $val;

        # ignore empty values
        $val =~ s/^\s+|\s+$//g;
        
		# strip out some hostile chars
		$val =~ s/\x00|\x0a|\x0d//g;
		
		# avoid cheesy xss attacks
        $val =~ s/\<|\>//g;        
        
        if (! length($val)) { delete($params{$var}) }
    }
    
    # Create a nice big hash of the request
	my $res  =
	{
		'method'	=> $meth,
		'headers'	=> \%headers,
		'params'	=> \%params,
		'path'		=> $path,
	};

	
	# Extract the session ID
	my ($sid) = $headers{'cookie'} =~ m/SID=(.*)$/;
	my $vid = GenerateSID(inet_aton($cli->PeerAddr));
	
	# Redirect the user if the SID does not match
	if ($sid ne $vid) {
		
		my $rdir =
			"HTTP/1.1 302 Rejected\r\n".
			"Set-Cookie: SID=$vid; path=/;\r\n".
			"Location: ". $res->{'path'} ."\r\n".
			"Date: ". HTTPDate() ."\r\n".
			"Connection: Close\r\n".
			"Content-Length: 0\r\n\r\n";

		$cli->Send($rdir);
		$cli->Close;
		return;
	}
	
	# Process the URL
	($res->{'base'}) = $path =~ m/^\/([^\?]+)/;
	if (! $res->{'base'}) {
		$res->{'base'} = 'EXPLOITS';
	}

	# Default to main mode
	if (! $res->{'params'}->{'MODE'}) {
		$res->{'params'}->{'MODE'} = 'MAIN';
	}
	
	return $res;
}

sub HTTPResponse {
	my $code = @_ ? shift() : 403;
	my $body = @_ ? shift() : '';
	my $type = @_ ? shift() : 'text/html';
	my $data;
	
	$data = "HTTP/1.1 $code\r\n".
			"Connection: close\r\n".
			"Date: ". HTTPDate() ."\r\n".
	        "Content-Length: ".length($body)."\r\n".
			"Content-Type: $type\r\n".
			"\r\n". $body;

	return $data;
}

sub HTTPDate {
	return strftime("%a, %e %b %Y %H:%M:%S GMT", gmtime());
}

sub GenerateSID {
	my $data = shift;
	return unpack("H*", pack('N', $skey) ^ $data);
}

sub LoadAllModules {
	$exploitsIndex	= $ui->LoadExploits;
	$payloadsIndex	= $ui->LoadPayloads;
	$encoders		= $ui->LoadEncoders;
	$nops			= $ui->LoadNops;
	$exploitKeys	= {};
	$exploitOS		= {};
	$exploitArch	= {};
	
	foreach my $key (keys(%{$exploitsIndex})) {
		my $exploit = $exploitsIndex->{$key};
		
		$exploits->{$exploit->SelfEndName} = $exploit;
		
		foreach my $kname ( @{ $exploit->Keys } ) {
			push @{ $exploitKeys->{ $kname } }, $exploit->SelfEndName;
		}

		foreach my $kname ( @{ $exploit->OS } ) {
			push @{ $exploitOS->{ $kname } }, $exploit->SelfEndName;
		}
		
		foreach my $kname ( @{ $exploit->Arch } ) {
			push @{ $exploitArch->{ $kname } }, $exploit->SelfEndName;
		}				
	}

	foreach my $key (keys(%{$payloadsIndex})) {
		$payloads->{$payloadsIndex->{$key}->SelfEndName} = $payloadsIndex->{$key};
	}

	$ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
	$ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
	$ui->SetTempEnv('_Encoders', $encoders);
	$ui->SetTempEnv('_Nops', $nops);
	
	
}



####################
package GhettoWeb; #
####################

use POSIX;
use IO::Socket;
use IO::Select;
use Pex;

sub new {
	my $name	= shift;
	my $self	= bless {}, $name;
	
	$self->_config(@_);
	return $self;
}

sub _config {
	my $self = shift;
	my %args = @_;
	foreach (keys %args) {
		$self->{'_Config'}->{$_} = $args{$_};
	}
};

sub IsError {
    my $self = shift;
    return 1 if exists($self->{'_Error'});
    return;
}

sub GetError {
    my $self = shift;
    return if ! exists($self->{'_Error'});
    return $self->{'_Error'};
}

sub SetError {
    my $self = shift;
    my $boom = shift;
    $self->{'_Error'} = $boom;
    return $self->{'_Error'};
}

sub ClearError {
    my $self = shift;
    delete($self->{'_Error'});
}

sub LogFile {
	my $self = shift;
	$self->{'_LogFile'} = shift() if @_;
	return $self->{'_LogFile'};
}

sub Log {
    my $self	= shift;
	my $lvl		= shift;
	my $msg		= @_ ? shift() : return;
	
	if ( open(X, ">>".$self->LogFile) ) {
    	print X scalar(localtime())." <$lvl> $msg\n";
    	close(X);
	}
}



sub Run {
	my $self = shift;
	my $args = $self->{'_Config'};

	my $host  = $args->{'host'};
	my $port  = $args->{'port'};
	my $fnWeb = $args->{'fnWeb'} || sub { };
	my $fnIPC = $args->{'fnIPC'} || sub { };
	my $fnHRP = $args->{'fnHRP'} || sub { };
	
	my $httpd = IO::Socket::INET->new 
	(
    	LocalAddr => $host,
    	LocalPort => $port,
    	ReuseAddr => 1,
    	Listen    => 5,
	);
	
	if (! $httpd) {
		$self->SetError("Failed to start listener: $!");
		return;
	}
	
	$httpd->blocking(0);
	
	$SIG{'CHLD'} = sub { while (waitpid(-1, WNOHANG) == 0) { } };

	my %socketInfo = 
	(
		$httpd	=> [$httpd, 0, 'listener'],
	);

	my $keepRunning = 1;
	
	# The main event loop
	while ($keepRunning) {

		my $sel = IO::Select->new();

		foreach my $s (keys %socketInfo) {
			# Process all but child-side sockets
			if ($socketInfo{$s}->[2] ne 'ipc_child') {
				my $sd = $socketInfo{$s}->[0];

				if (! $sd) {
					$self->Log(1, "socketInfo{ $s } is invalid");
					delete($socketInfo{$s});
					next;
				}

				$sd->blocking(0);
				$sd->autoflush(1);
				$sel->add($sd);
			}
		}

		# Select for new connections and data
		my @ready = $sel->can_read(10);

		# Process each flagged socket
		foreach my $s (@ready) {

			# A new connection
			if ($s eq $httpd) {
				my ($client) = $httpd->accept;
				
				if (! $client) {
					$self->Log(1,  "Accept failed on primary listener socket: $@");
					next;
				}

				$socketInfo{$client} = [$client, 0, 'client'];
				$self->Log(3, "New client connection from ".$client->peerhost);
				next;
			}

			# A new HTTP request
			if ($socketInfo{$s}->[2] eq 'client') {
				my $cli = Msf::Socket::Tcp->new_from_socket($s);
				my $res = $fnHRP->($cli);

				if ($res) {
					my ($par, $chi);

					# Create the comm channel between parent and child
					socketpair($par, $chi, AF_UNIX, SOCK_STREAM, PF_UNSPEC);

					# Spawn off the child process
					my $pid = fork();
					if (! $pid) {
						$self->Log(3,  "fnWeb called with pid $$...");
						$fnWeb->($res, $cli, $chi);
						exit(0);
					}

					$socketInfo{$par} = [$par, $pid, 'ipc'];
					$socketInfo{$chi} = [$chi, $pid, 'ipc_child'];
				} 
				else {
					eval { $s->shutdown(2); };
					eval { $s->close; };
				}

				# XXX - local cleanup up the original socket?
				delete($socketInfo{$s});
				next;
			}

			# A new IPC request
			if ($socketInfo{$s}->[2] eq 'ipc') {
				my $cli = Msf::Socket::Tcp->new_from_socket($s);
				$self->Log(3,  "fnIPC called with pid $$...");
				$fnIPC->($cli);
				next;
			}

			# Unknown socket type...
			$self->Log(1, "Unknown socket type ".$socketInfo{$s}->[2]);
		}

		# Remove sockets attach to dead processes
		foreach my $s (keys %socketInfo) {
			my $spid = $socketInfo{$s}->[1];
			if ($spid && ! kill(0, $spid)) {
				$self->Log(3, "Removed $s ($spid) of type ".$socketInfo{$s}->[2]);
				eval { $socketInfo{$s}->[0]->shutdown(2); };
				eval { $socketInfo{$s}->[0]->close; };
				delete($socketInfo{$s});
			}
		}
	}
}
