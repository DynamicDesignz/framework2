#!/usr/bin/perl
###############

##
#         Name: msfweb
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#  Description: Web interface to the Metasploit Exploit Framework
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

# This is a really ghetto proof-of-concept for a web-based exploit interface

# XXX TODO
#	1. IP-based access control
#	2. Basic HTTP authentication
#	3. SSL mode support
#	4. Admin
#	5. Logs
#   6. ShikataGaNai != random via msfweb payload encoder? !?!?!!


require 5.6.0;

use strict;
use FindBin qw{$RealBin};
use lib "$RealBin/lib";
use Msf::WebUI;

use POSIX;
use IO::Socket;
use Getopt::Std;

use Carp;

no utf8;

Msf::UI::ActiveStateSucks();

my $ui = Msf::WebUI->new($RealBin);
my $VERSION = $ui->Version;

$ui->SetGlobalEnv('_Console', 'Msf::PayloadComponent::WebConsole');

my @sections = qw{ EXPLOITS PAYLOADS SESSIONS ADMIN LOGS };


my $exploitsIndex;
my $payloadsIndex;
my $encodersIndex;
my $nopsIndex;
my $exploits	= { };
my $payloads	= { };
my $moduleKeys	= { };
my $moduleArch	= { };
my $moduleOS	= { };
my $moduleList	= { };
my $modules	    = { };
my $burl;


my %args = ();
getopts("vha:hr", \%args);

if ($args{h}) { Usage() }
# if ($args{v}) { $verbose++ }

my ($host, $port) = ("127.0.0.1", 55555);
if ($args{a})
{
    ($host, $port) = split(/:/, $args{a});
    if (! $port) { $port = 55555 }
}


print "[*] Starting Metasploit v$VERSION Web Interface on $host:$port...\n";

# Set the cache directory
$ui->SetTempEnv('_CacheDir', "$RealBin/data/msfweb");

# Create the inital list of modules
LoadAllModules();

# Cache these lists
if (! $args{'r'}) {
	ExploitList();
	PayloadList();
}

my $ghettoWeb = GhettoWeb->new
(
	'host'	=> $host,
	'port'	=> $port,
	'fnWeb'	=> \&ProcessWebRequest,
	'fnIPC'	=> \&ProcessIPCRequest,
	'fnHRP'	=> \&HTTPRequest,
);

$ghettoWeb->LogFile('/tmp/ghetto.log');
$ghettoWeb->Run();

if ($ghettoWeb->IsError) {
	print STDERR "[*] Error: ".$ghettoWeb->GetError."\n";
}



exit(0);


########################################################
#                 !!! WARNING !!!                      #
#                                                      #
#    Viewing the code below may result in the loss     #
#    of vision, nausea, indigestion, insomnia, or      #
#    even INSTANT DEATH. You have been warned.         #
#                                                      #
########################################################

######################################################################
######################################################################
######################################################################

sub ProcessResRequest {
	my ($req, $cli, $ipc) = @_;

	my %files =
	(
		'LOGO'	=> ['image/jpg', 'msfweb_logo.jpg'],
		'STYLE'	=> ['text/css',  'style.css'],
	);
	
	if ( exists( $files{ $req->{'params'}->{'ID'} } ) ) {
		my ($type, $path) = @{ $files{ $req->{'params'}->{'ID'} } };
		my $data;
		
		if ( open (X, "<$RealBin/data/msfweb/$path") ) {
			while (<X>) { $data .= $_ }
			close (X);
		}
		
		$cli->Send(HTTPResponse(200, $data, $type));
	}
}


sub ProcessIPCRequest {
	my $self	= shift;
	my $ipc		= shift;

	my $req = $ipc->getline || return;
	chomp($req);
	
	my ($cmd, @args) = split(/\s+/, $req);
	return if ! $cmd;
	
	print "[ $ipc ] $cmd ($args[0] | $args[1])\n";
	
	if ($cmd eq 'SESSION') {
		my $sid = $self->SessionNew($ipc);
		$ipc->printflush("SID $sid\n");
	}
	
	# NEW <sid> <pid of exploit pipe handler>
	if ($cmd eq 'NEW') {
		$self->SessionPipePID(@args);
		$ipc->printflush("SHELL\n");
	}
	
	if ($cmd eq 'SHUTDOWN') {
		$ipc->printflush("SHUTDOWN\n");
		$self->SessionRemove($args[0]);
	}
	
	if ($cmd eq 'CMD') {
		my $out = $self->SessionIPC($args[0]);
		if ($out) {
			$out->printflush("CMD ".$args[1]."\n");
			$ipc->printflush("CMD OK\n");
		}
		else {
			$ipc->printflush("CMD ERROR\n");
		}

	}
	
	if ($cmd eq 'INFO') {
		$self->SessionInfo($args[0], $args[1]);
	}
	
	# XXX replace this :/
	if ($cmd eq 'LIST') {
		my @list = $self->SessionList();
		my $data;
		foreach my $sid (@list) {
			$data .= "sid=".unpack("H*", "$sid").",". $self->SessionInfo($sid)." ";
		}
		$ipc->printflush("LIST $data\n");
	}
}

sub ProcessWebRequest {
	my $self = shift;
	my ($req, $cli, $ipc) = @_;
    my $state = $req->{'params'};
	my $mbase = $req->{'base'};
	my $res;
	
	# Process resource requests
	if ($req->{'base'} eq 'RESOURCE') {
		ProcessResRequest($req, $cli, $ipc);
		exit(0);
	}

	# Generate the base URL
	$burl = "/$mbase?";
	
	# Reload all modules only when the -r option has been specified
	if (exists($args{'r'})) {
		LoadAllModules();
	}
	
	# Start with a standard header
	$res .= HTML_Header($req);
	
    my $logaction;
    if (defined (my $mid = $state->{'MODULE'} )) {

		my $mname;
		        
		if ($mbase eq 'EXPLOITS' && exists($exploits->{$mid}) ) {
			$mname = $exploits->{$mid}->Name;
		}
		
		if ($mbase eq 'PAYLOADS' && exists($payloads->{$mid}) ) {
			$mname = $payloads->{$mid}->Name;
		}
		
		if (! defined($mname)) {
			$mname = 'Invalid Module';
		}						

        $res .= "<table width=100% bgcolor='black'>\n";
		$res .= "<tr><td class='textBoldWhite'>Module: $mname</td></tr>\n";
		$res .= "</table><br/>\n";
    }

    $state->{'client'} = $cli;
	$state->{'parent'} = $ipc;
	
	if ($req->{'base'} eq 'EXPLOITS') {
		
    	if ($state->{'MODE'} eq 'MAIN')    { $res .= ExploitList($state) }
		if ($state->{'MODE'} eq 'SELECT')  { $res .= ExploitTarget($state) }
    	if ($state->{'MODE'} eq 'PAYLOAD') { $res .= ExploitPayload($state) }
    	if ($state->{'MODE'} eq 'OPTIONS') { $res .= ExploitOptions($state) }
    	if ($state->{'MODE'} eq 'TARGETS') { $res .= ExploitTargets($state) }
    	if ($state->{'MODE'} eq 'CHECK')   { $res .= ExploitCheck($state) }

    	# ExploitExec doesn't return on success
    	if ($state->{'MODE'} eq 'EXPLOIT') { $res .= ExploitExec($state) }

		$res .= HTML_Footer();  
	}

	if ($req->{'base'} eq 'PAYLOADS') {
	
    	if ($state->{'MODE'} eq 'MAIN')      { $res .= PayloadList($state) }
		if ($state->{'MODE'} eq 'SELECT')    { $res .= PayloadOptions($state) }
		if ($state->{'MODE'} eq 'GENERATE')  { $res .= PayloadGenerate($state) }
		$res .= HTML_Footer();
	}
	
	if ($req->{'base'} eq 'SESSIONS') {
	
    	if ($state->{'MODE'} eq 'MAIN')      { $res .= SessionList($state) }
		if ($state->{'MODE'} eq 'LOAD')      { $res = SessionLoad($state) }
		if ($state->{'MODE'} eq 'COMMAND')   { $res = SessionCommand($state) }
		if ($state->{'MODE'} eq 'UPDATE')    { $res = SessionUpdate($state) }
	}	
			
    
	
    $cli->Send(HTTPResponse(200, $res));
    $cli->Close();
	
    exit(0);
}

sub Usage {
    print STDERR "Usage: $0 -a hostname:port [-v -r]\n";
    exit(0);
}


sub HTML_Header {
	my $req = shift;
	
    my $header = qq
[<html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
		<link type='text/css' rel='stylesheet' href='/RESOURCE?ID=STYLE'>
    </head>
    <body bgcolor='white' text='black'>
<a name='Top'></a>

<br/>
<div align='center'><img src='/RESOURCE?ID=LOGO'></div>
<br/>

<table align='center' cellpadding=0 border=0 cellspacing=0 width='98%' bgcolor='#000000'>
<tr><td>
<table align='center' cellpadding=8 border=0 cellspacing=1 width='100%'>
<tr>
];

	my $lastTab = 'tabLight';
	my $currTab;
	
	my $width = int( 100 / scalar(@sections) ) .'%';
	foreach my $section (@sections) {
		$lastTab = ($lastTab eq 'tabLight') ? 'tabDark' : 'tabLight';
		$currTab = ($section eq $req->{'base'}) ? 'tabActive' : $lastTab;		
		$header .= qq[ <td class='$currTab' width='$width' align='center'> <a href='/$section'>$section</a> </td> ];
	}
	$header .= qq[
        </tr>

        <tr>
                <td colspan=5 bgcolor='#ffffff'>
                <br/>
	];
	
	return $header;

}

sub HTML_Footer {
    return qq[
		<br/>
		</td>
	</tr>
</table></td></tr></table>
<br/>
<div align='center' class='copy'>
	copyright &copy 2003-2005 metasploit.com<br/>
</div>
</body>
</html>
	];
}

sub URLEncode {
    my ($data) = @_;
    my $res;
    foreach (split(//, $data))  
    { $res .= sprintf("%%%.2x", ord($_)) }
    return $res;
}

sub StateToURL {
    my ($mode, $state) = @_;
    my (%tmp, $res);
    $res = $burl;
	
    foreach (keys(%{$state})) {
        next if $_ eq "client";
        next if $_ eq "parent";
		
        my $value = $_ eq "MODE" ? $mode : $state->{$_};
        $res .= $_ . "=" . URLEncode($value) . "&";
    }
    return $res;
}

sub StateToOptions {
    my ($state) = @_;
    my $res = {};
    
    foreach (keys(%{$state})) {
        if (m/^OPT\_(.*)/ && defined($state->{$_})) { $res->{$1} = $state->{$_} }
    }
    return $res;
}

sub SessionList { 
	my $state	= shift;
	my $ipc		= $state->{'parent'}; 
	my $res;
	
	my %slist;
	$ipc->printflush("LIST\n");
	
	if ( defined(my $raw = $ipc->getline) ) {
		if ( (my ($data) = $raw =~ m/^LIST\s+(.*)\n/) ) {
			foreach my $entry (split(/\s+/, $data)) {
				my %hash = IPCDataToHash($entry);
				my $sid = $hash{'sid'};
				$slist{$sid} = \%hash;
				print "$sid ($entry\n)";
			}
		}
	}
	
	if (! scalar(keys(%slist))) {
		$res .= "<p class='textBold'>There are no active sessions.<br\><br\></p>\n";
		return $res;
	}

	$res .= "<p class='textBold'>Session List:<br\><br\></p>\n";
    $res .= "<table align='center' cellpadding=0 border=0 cellspacing=0 width='95%'>\n";
	$res .= "<tr>";
	
	foreach (qw{Time Session User Exploit Target Payload}) {
		$res .= "<td class='textBold' align='center'>$_</td>";
	}
	
	$res .= "</tr><tr><td colspan=6><br\></td></tr>\n";

	foreach my $sid (sort { $a <=> $b } keys %slist ) {
		my $ses			= $slist{$sid};
		my $s_module	= $ses->{'module'};
		my $s_payload	= $ses->{'payload'};
		my $s_client	= $ses->{'client'};
		my $s_target	= $ses->{'target'};
		my $s_time		= scalar(localtime($ses->{'start'}));
		
		my $mlink = '/EXPLOITS?MODE=SELECT&MODULE='.URLEncode($s_module);
		my $plink = ($s_payload ne 'unknown') ? '/PAYLOADS?MODE=SELECT&MODULE='.URLEncode($s_payload) : '#';
		
        $res .= "<tr>";
		$res .= "<td class='textNormal'>$s_time</td>";
		$res .= "<td class='textNormal'><a href='/SESSIONS?MODE=LOAD&SID=$sid' target='_blank'>Session $sid</a></td>";
		$res .= "<td class='textNormal'>$s_client</td>";
		$res .= "<td class='textNormal'><a href='$mlink'>$s_module</a></td>";
		$res .= "<td class='textNormal'>$s_target</td>";
		$res .= "<td class='textNormal'><a href='$plink'>$s_payload</a></td>";
		$res .= "</tr>";
	}
	
    $res .= "</table>\n";
	return $res;
}

sub SessionLoad { 
	my $state	= shift;
	my $sid		= $state->{'SID'} + 0;
	my $res		= qq
[<html>
<frameset rows="*, 45" border=0 frameborder=0 framespacing=0>
  <frame src="/SESSIONS?MODE=UPDATE&SID=$sid" name="update">
  <frame src="/SESSIONS?MODE=COMMAND&SID=$sid" name="command">
  <noframes><body>This feature requires frames...</body></noframes>
</frameset>
];
	
	return $res;
}

# Quick command bar to send commands to the shell
sub SessionCommand { 
	my $state	= shift;
	my $ipc		= $state->{'parent'};	
	my $sid		= $state->{'SID'} + 0;
	my $cmd		= $state->{'CMD'};	
	my $res		= qq
[<html>
<body bgcolor='white' text='black'>

<form action='/SESSIONS' name='cmdform'>
<input type='hidden' name='MODE' value='COMMAND'>
<input type='hidden' name='SID' value='$sid'>
<input type='text' name='CMD' size=80>
<input type='submit' name='submit' onsumbit='javascript:document.form.CMD="";' value='Send Command'>
<input type='submit' name='clear' value='Clear'>
</form>
<script language='javascript'>
<!--
	window.focus();
	document.cmdform.CMD.focus();
//-->
</script>
</body>
</html>
];
	my $cmd_data;
	
	# process the actual command
	if ($cmd) {
		$cmd .= "\n";
		$ipc->printflush("CMD $sid ".unpack("H*", $cmd)."\n");
		my $raw = $ipc->getline;
		
		if ($raw =~ /ERROR/) {
			$ipc->printflush("SHUTDOWN $sid\n");
		}
	}

	return $res;
}

sub SessionUpdate { 
	my $state	= shift;
	my $ipc		= $state->{'parent'};
	my $chi		= $state->{'client'};
	my $sid		= $state->{'SID'} + 0;
	my $cmd		= $state->{'CMD'};

	# <meta http-equiv='refresh' content='10;URL=/SESSIONS?MODE=UPDATE&SID=$sid#END'>
	my $res		= qq
[<html>
    <head>
        <title>Metasploit Framework Web Console v$VERSION</title>
		<link type='text/css' rel='stylesheet' href='/RESOURCE?ID=STYLE'>
    </head>
    <body bgcolor='white' text='black'>
	<pre>
];

	# Use chunked transfer mode to return partial responses
	my $out = "HTTP/1.1 200 OK\r\n".
	          "Connection: close\r\n".
			  "Date: ". HTTPDate()."\r\n".
			  "Content-Type: text/html\r\n".
			  "Transfer-Encoding: chunked\r\n\r\n";
	
    $chi->Send($out);
	$chi->Send(sprintf("%x\r\n%s\r\n", length($res), $res));
	
	my $init = 0;
	my $foff = 0;
	my $idle = 0;
	my $tick = time();
	
	my $cache_file = $ui->GetEnv('_CacheDir'). sprintf("/cache%.8x.dat", $sid);
	my $cache_data;

	if (! open(CACHE, "<$cache_file")) {
		if (open(CACHE, ">>$cache_file")) {
			$init = time;
			print CACHE "<!-- INIT:$init -->\n";
			close (CACHE);
		} else { print STDERR "Could not write cache file: $!"; exit(0); }
	}
				
	while (1) {
		$res = undef;
		
		if (! $chi->Socket->connected) {
			exit(0);
		}
		
		# Read the init time stamp from the top
		seek(FILE, 0, 0);
		my $init_data = <CACHE>;
		
		# If it changed, reset the file markers
		if ($init_data =~ m/\s+INIT:([0-9]{1,15})\s+/) {
			if ($init != $1) {
				$init = $1;
				$foff = 0;
				print STDERR "Resetting INIT markers ($init)\n";
			}
		}

		# Seek to the last data marker
		seek(CACHE, $foff, 0);
		
		# Read until we hit EOF
		for ($foff = tell(CACHE); my $data = <CACHE>; $foff = tell(CACHE)) {
			$res .= $data;
		}
		
		# Clear stdio errors and seek to the last tell
		seek(CACHE, $foff, 1);
		seek(CACHE, $foff, 0);

		# If there is a new data, display it
		if ($res) {
			$res .= "<script language='javascript'>self.scrollTo(0, 999999999)</script>";
			$chi->Send(sprintf("%x\r\n%s\r\n", length($res), $res));
			$tick = time();
			$idle = 0;
		}
		
		# Send a comment as a keep alive
		if ($tick + 10 < time()) {
			$res = "<!-- MSF -->";
			$chi->Send(sprintf("%x\r\n%s\r\n", length($res), $res));
			$tick = time();
			$idle++;
		}
		
		# If we have been idle for five minutes, shut down the reader
		if ($idle > 30) {
			$res =  "<div class='textBold'>!!! Idle timeout reached, reload to start again.</div>\n";
			$res .= "</pre></body></html>\n";
			$chi->Send(sprintf("%x\r\n%s\r\n", length($res), $res));
			exit(0);
		}
		
		# Sleep a quarter of a second to reduce CPU usage 
		select(undef, undef, undef, 0.25);
	}
	
	$res = "</pre></body></html>\n";
	$chi->Send(sprintf("%x\r\n%s\r\n", length($res), $res));
	exit(0);
}


sub PayloadList {
	my $mtype = 'payloads';
	if (! $args{'r'} || ! defined( $moduleList->{$mtype} )) {
		$moduleList->{$mtype} = ModuleList($mtype);
	} 
	return $moduleList->{$mtype};
}

sub ExploitList {
	my $mtype = 'exploits';
	if (! $args{'r'} || ! defined( $moduleList->{$mtype} )) {
		$moduleList->{$mtype} = ModuleList($mtype);
	} 
	return $moduleList->{$mtype};
}

sub ModuleList
{
	my $mtype = shift;
    my $mList;
	my @links;
	
	my $moduleMerge = {};
	my $mKeys		= $moduleKeys->{$mtype};
	my $mOS			= $moduleOS->{$mtype};
	my $mArch		= $moduleArch->{$mtype};
			
	# Navigation header
	$mList = "<div align='center' class='navHead'>Navigation Keys<br/><br/>\n";
	
	# List of mKeys
	if (scalar(keys %{ $mKeys } )) {
		my @links = ();
		foreach my $kname  (sort( keys %{ $mKeys }) ) {
			push @links, "<a href='#$kname' class='nav'>$kname</a> ";
			$moduleMerge->{$kname} = $mKeys->{$kname};
		}
		$mList .= join(" | ", @links) . "<br/><br/>\n";
	}
	
		
	# List of mOS
	if (scalar(keys %{ $mOS } )) {
		my @links = ();	
		foreach my $kname (sort( keys %{ $mOS }) ) {
			push @links, "<a href='#$kname' class='nav'>$kname</a> ";
			$moduleMerge->{$kname} = $mOS->{$kname};
		}
		$mList .= join(" | ", @links) . "<br/><br/>\n";
	}

	# List of mArch
	if (scalar(keys %{ $mArch } )) {
		my @links = ();
		foreach my $kname (sort( keys %{ $mArch}) ) {
			push @links, "<a href='#$kname' class='nav'>$kname</a> ";
			$moduleMerge->{$kname} = $mArch->{$kname};		
		}
		$mList .= join(" | ", @links) . "<br/><br/>\n";
	}
	
	$mList .= "</div><br\>\n";

	# Generate a frame for each unique key, os, and arch
	foreach my $kname (	sort( keys %{ $moduleMerge }) ) {
	
		$mList .= qq[
<a name='$kname'><br/></a>        
<table align='center' cellpadding=1 border=0 cellspacing=0 width='80%' bgcolor='black'>        
	<tr><td>
    <table align='center' cellpadding=8 border=0 cellspacing=0 width='100%' bgcolor='white'>
    <tr>
		<td class='nav' align='left'> $kname </td>
    	<td class='listBody' align='right'><a href='#Top'>Top</a></td>
	</tr>
	<tr><td class='listBody' align='center' colspan=2>
		<blockquote>
		<table align='center' padding=6 border=0 cellspacing=0 width='100%'>
];

	# Dump out all of the matching modules for this key, os, or arch
	foreach my $ename (sort @{ $moduleMerge->{$kname} }) {
		$mList .= "<tr><td>  -  <a href='/". uc($mtype) ."?MODE=SELECT&";
		$mList .= "MODULE=".URLEncode($ename)."'>".$modules->{$mtype}->{$ename}->Name."</a>";
		$mList .= "</td></tr>\n";
	}
	
	$mList .= qq[
		</table>
		</blockquote>
</td></tr></table>
</td></tr></table>
];

	}
    return $mList;
}

sub ModuleInfo {
	my $module = shift;
	my $res;
	
	my $desc = $module->Description();
    $desc =~ s/\</\&lt;/g;
    $desc =~ s/\>/\&gt;/g;
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";
    $res .= "<tr><td align='left' width=80 class='textBold'>Name:</td>";
	$res .= "<td class='textNormal'>" . $module->Name() . "</td></tr>\n";
	
    my ($rev)   = $module->Version() =~ m/\$Revisio.:\s+([^\$]+)/; 
    $res .= "<tr><td align='left' width=80 class='textBold'>Version:</td>";
	$res .= "<td class='textNormal'>" . $rev . "</td></tr>\n";

    my @authors = @{$module->Authors()};
    my $author = shift(@authors);
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $res .= "<tr><td align='left' width=80 class='textBold'>Authors:</td>";
	$res .= "<td class='textNormal'>$author</td></tr>\n";
    
	foreach my $author (@authors) {
        $author =~ s/</&lt;/g;
        $author =~ s/>/&gt;/g;
        $res .= "<tr><td align='left' width=80></td><td class='textNormal'>$author</td></tr>\n";
    }
    
    $res .= "<tr><td colspan=2 class='textNormal'>";
    $res .= "<br/>$desc<br/><br/>";

    foreach my $ref (@{$module->RefLinks}) { $res .= " -  <a href='$ref' target='_blank'>$ref</a><br/>\n" }
	
    $res .= "<br/></td></tr></table>\n";
	return $res;
}

sub PayloadEncoders {
	my $payloadArch	= shift;
	my $payloadOS	= shift;
	my %res;
	
	foreach my $encoderName (keys %{ $encodersIndex }) {
		my $encoder		= $encodersIndex->{$encoderName};		
		my $encoderArch	= $encoder->Arch;
		my $encoderOS	= $encoder->OS;

		next if ! $ui->ListCheck($payloadArch,	$encoderArch);
		next if ! $ui->ListCheck($payloadOS,	$encoderOS);
		$res{ $encoderName } = $encoder;
	}
	return %res;
}

sub PayloadNops {
	my $payloadArch	= shift;
	my $payloadOS	= shift;
	my %res;
	
	foreach my $nopName (keys %{ $nopsIndex }) {
		my $nop		= $nopsIndex->{$nopName};		
		my $nopArch	= $nop->Arch;
		my $nopOS	= $nop->OS;

		next if ! $ui->ListCheck($payloadArch,	$nopArch);
		next if ! $ui->ListCheck($payloadOS,	$nopOS);
		$res{ $nopName } = $nop;
	}
	return %res;
}

sub PayloadOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 

    if (! exists($payloads->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $p = $payloads->{$module};
    
	$res .= ModuleInfo($p);	 
	  
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";    
    $res .= "<form action='$burl' method='GET'>\n";
    foreach (keys(%{$state})) {
        next if $_ eq 'client';
        if ($_ ne "MODE") {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='GENERATE'>\n";
        }
    }
  
    my $popts =  $p->UserOpts();

    foreach my $popt (sort(keys(%{$popts}))) {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        my $colc = $popts->{$popt}->[0] ? "textBold" : "textBoldGrey";
		
        $dflt = Pex::Utils::SourceIP() if $popt eq "LHOST";
        
        $res .= "<tr><td class='$colc'>$popt</td>".
                "<td class='$colc'>$reqd</td>".
				"<td class='$colc'>". $popts->{$popt}->[1] ."</td>".
                "<td class='textNormal'><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td class='textNormal'>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
	
    $res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
	
	# Display encoding options only when an arch is set	
	if (scalar( @{ $p->Arch } )) {
		$res .= "<tr><td colspan=6 class='textBold'>";
		$res .= "Max Size: ";
		$res .= "<input type='text' size=10 name='MaxSize' value=''>";
		$res .= "</td></tr>\n";
		
		$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
		
		$res .= "<tr><td colspan=6 class='textBold'>";
		$res .= "Restricted Characters (format: 0x00 0x01)<br\> ";
		$res .= "<input type='text' size=45 name='BadChars' value='0x00 '>";
		$res .= "</td></tr>\n";

		$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";

		my %encoderList = PayloadEncoders($p->Arch, $p->OS);
		
		$res .= "<tr><td colspan=6 class='textBold'>";
		$res .= "Selected Encoder:<br\> ";
		$res .= "<select name='ENCODER' size=1>\n";
		$res .= "<option value='default'> Default Encoder\n";
		foreach my $encoderName (keys %encoderList) {
			$res .= "<option> $encoderName\n";
		}
		$res .= "</select>\n";
		$res .= "</td></tr>\n";		
	}
	
	$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
    $res .= "<tr><td colspan=6><input type='submit' name='ACTION' value='Generate Payload'></td></tr>\n";
    $res .= "</form>\n";
    $res .= "</table>\n";  
    return $res;
}



sub PayloadGenerate
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 

    if (! exists($payloads->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $p = $payloads->{$module};
    my $o = StateToOptions($state);
	
	my $optstr;
    foreach my $k (keys(%{ $o })) {
        $ui->SetTempEnv($k, $o->{$k});
		$optstr .= " $k=".$o->{$k};
    }
	
	my $badChars = CharsToBytes($state->{'BadChars'});
	my $maxSize  = $state->{'MaxSize'} || 65000;
	my $rawShell = $p->Build();

	
	my ($payloadArch)	= $p->Arch;
	my ($payloadOS)		= $p->OS;

	my $finalEncoder;
	my $encodedPayload;
	
		
	if (! $badChars) {
		$finalEncoder = 'None';
		$encodedPayload = Msf::EncodedPayload->new($rawShell, $rawShell);
	}
	
	my %encoderList	= PayloadEncoders($payloadArch, $payloadOS);
	my $encoderOpt	= $state->{'ENCODER'};
	
	if (scalar(@{ $p->Arch }) && $encoderOpt ne 'default' && ! exists($encoderList{$encoderOpt})) {
		return "<div class='textBold'>Invalid encoder specified!</div>";
	}
	
	# Shrink the list down to the single selected option
	if ($encoderOpt ne 'default') {
		%encoderList = ( $encoderOpt => $encoderList{ $encoderOpt } );
	}
	
	foreach my $encoderName (keys %encoderList) {
		next if ! $badChars;
		
		my $encoder			= $encoderList{$encoderName};
		my $encodedShell	= $encoder->Encode($rawShell, $badChars);

		next if ! $encodedShell;

		if ($encoder->IsError) {
			$encoder->ClearError;
			next;
		}

		next if Pex::Text::BadCharCheck($badChars, $encodedShell);
		
		$encodedPayload = Msf::EncodedPayload->new($rawShell, $encodedShell);

		if (length($encodedPayload->Payload) > $maxSize) {
			undef($encodedPayload);
			next;
		}
		
		$finalEncoder = $encoder->SelfEndName;
		last;
	}

	if (! $encodedPayload) {
    	$res .= "<div class='textBold'>No encoders succeeded :( </div>\n";
		return $res;
	}	
	
	my $sC = Pex::Text::BufferC($encodedPayload->Payload);
	my $sP = Pex::Text::BufferPerl($encodedPayload->Payload);

	if ($p->Multistage) {
		$res .= "<div class='textBold'>Warning: only the loading stage of multi-stage payloads will be displayed!</div>\n<br\>";	
	}



	$optstr =~ s/\<|\>//g;
	$optstr .= " Size=".length($encodedPayload->Payload);
	$optstr .= " Encoder=$finalEncoder";
	
	$res .= "<pre>\n";
	$res .= "<div class='shellcode'>";
	$res .= "/* $module - $optstr http://metasploit.com */\n";
	$res .= "unsigned char scode[] =\n$sC\n\n\n";

	$res .= "# $module - $optstr http://metasploit.com\n";
	$res .= "my \$shellcode =\n$sP\n\n\n";

	$res .= "</div></pre>\n";
	
	return $res;	
}


sub ExploitTarget
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }
    
    my $x = $exploits->{$module};
    
	$res .= ModuleInfo($x);

	# Display available targets

    if (scalar($x->TargetsList) ) {
        $res .= "<table align='align' cellpadding=2 border=0 cellspacing=0'>\n";
		$res .= "<tr><td class='textBold' align='left'>Select Target:</td><td>&nbsp;</td></tr>";

		my $tidx = 0;
		my $colc = ListColor();
        foreach my $k ( $x->TargetsList )
        {
            my $u = StateToURL('PAYLOAD', $state);
			my $default;
			
			if ($tidx == $x->DefaultTarget) {
				$default = "(default)";
			}
			$colc = ListColor($colc);
			
            $res .= "<tr><td>&nbsp;</td><td align='left' class='textBold' bgcolor='$colc'>$tidx - <a href='".$u."OPT_TARGET=$tidx'> $k $default </a></td></tr>\n";
			$tidx++;
        }
        $res .= "</table>\n";
    } else {
        $res .= ExploitPayload($state);
    }
	return $res;
}

sub ExploitPayload
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }
    
    my $x = $exploits->{$module};

	# Display available payloads

    my $matches = $ui->MatchPayloads($x, $payloads) if($x->Payload);

    if (defined($x->Payload) ) {
		$res .= "<p class='textBold'>Select Payload:<br\></p>\n";
        $res .= "<table align='center' cellpadding=0 border=0 cellspacing=0 width='95%'>\n";
		$res .= "<tr><td class='textBold' align='center'>Payload</td>";
		$res .= "    <td class='textBold' align='center'>Description</td></tr>\n";
		$res .= "<tr><td colspan=2><br\></td></tr>\n";

		my $colc = ListColor();				
        foreach my $k (sort(keys(%{ $matches })))
        {
            my $u = StateToURL('OPTIONS', $state);
            my $pname = $payloads->{$k}->Name();
			$colc = ListColor($colc);
            $res .= "<tr><td class='textNormal' bgcolor='$colc'><a href='".$u."PAYLOAD=" . $k . "'>$k</a></td>";
            $res .= "<td class='textNormal' bgcolor='$colc'>" .$pname . "</td></tr>\n";
        }
        $res .= "</table>\n";
    } else {
        $res .= ExploitOptions($state);
    }
	return $res;
}

sub ExploitOptions
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    
    if (! exists($exploits->{$module})) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $x = $exploits->{$module};
    my $p = $payloads->{$state->{'PAYLOAD'}};
    
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";
        
    if (defined($x->Payload) && ! $state->{"PAYLOAD"})
    {
        $res .=  "<tr><td class='textBold'>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
 
    $res .= "<form action='$burl' method='GET'>\n";
    foreach (keys(%{$state})) {
        next if $_ eq 'client';
		next if $_ eq 'parent';
		
        if ($_ ne "MODE") {
            $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
        } else {
            $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
        }
    }

    my $mopts = $x->UserOpts();
    my $popts = defined($x->Payload) ? $p->UserOpts() : {};

    foreach my $mopt (sort(keys(%{$mopts}))) {
        my $dflt = $mopts->{$mopt}->[3];
        my $reqd = $mopts->{$mopt}->[0] ? "Required" : "Optional";
		my $colc = $mopts->{$mopt}->[0] ? "textBold" : "textBoldGrey";
		
		if (exists($x->AutoOpts->{$mopt})) {
			$dflt = $x->AutoOpts->{$mopt};
		}
		
        $res .= "<tr><td class='$colc'>$mopt</td>".
                "<td class='$colc'>$reqd</td>".
				"<td class='$colc'>". $mopts->{$mopt}->[1] ."</td>".
                "<td class='textNormal'><input type='text' name='OPT_$mopt' value='$dflt'></td>".
                "<td class='textNormal'>".$mopts->{$mopt}->[2]."</td></tr>\n";
    }
    
    foreach my $popt (sort(keys(%{$popts}))) {

        my $dflt = $popts->{$popt}->[3];
        my $reqd = $popts->{$popt}->[0] ? "Required" : "Optional";
        my $colc = $popts->{$popt}->[0] ? "textBold" : "textBoldGrey";
		
        $dflt = Pex::Utils::SourceIP() if $popt eq "LHOST";
 
 		if (exists($x->AutoOpts->{$popt})) {
			$dflt = $x->AutoOpts->{$popt};
		}
		       
        $res .= "<tr><td class='$colc'>$popt</td>".
                "<td class='$colc'>$reqd</td>".
				"<td class='$colc'>". $popts->{$popt}->[1] ."</td>".
                "<td class='textNormal'><input type='text' name='OPT_$popt' value='$dflt'></td>".
                "<td class='textNormal'>".$popts->{$popt}->[2]."</td></tr>\n"; 
    }
    
	if ($p && @{ $p->Arch } ) {

    	$res .= "<tr><td colspan=6>&nbsp;</td></tr>\n";
		my %encoderList = PayloadEncoders($p->Arch, $p->OS);

		$res .= "<tr>\n";
		$res .= "<td colspan=3 class='textBold'>";
		$res .= "Preferred Encoder:<br\> ";
		$res .= "<select name='ENCODER' size=1>\n";
		$res .= "<option value='default'> Default Encoder\n";
		foreach my $encoderName (keys %encoderList) {
			$res .= "<option> $encoderName\n";
		}	
		$res .= "</select>\n";
		$res .= "</td>\n";	


		my %nopList = PayloadNops($p->Arch, $p->OS);
		$res .= "<td colspan=3 class='textBold'>";
		$res .= "Nop Generator:<br\> ";
		$res .= "<select name='NOP' size=1>\n";
		$res .= "<option value='default'> Default Generator\n";
		foreach my $nopName (keys %nopList) {
			$res .= "<option> $nopName\n";
		}	
		$res .= "</select>\n";
		$res .= "</td>";
		$res .= "</tr>\n";		

    	$res .= "<td colspan=3>&nbsp;</td></tr>\n";	
	}
		
    $res .= "<tr>";
	$res .= "<td colspan=3 align='right'> <input type='submit' name='ExploitAction' value='Check'> </td>";
    $res .= "<td colspan=3 align='left'> <input type='submit' name='ExploitAction' value='Exploit'> </td>";
	$res .= "</tr>\n";
	
    $res .= "</form>\n";
    $res .= "</table>\n";
    return $res;
}

sub ExploitExec
{
    my ($state) = @_;
    my $module = $state->{'MODULE'};
    my $res; 
    my $exploit = $exploits->{$module};
    
    if (! $exploit) {
        return "<div class='textBold'>Invalid Module</div>";
    }

    my $o = StateToOptions($state);
    foreach my $k (keys(%{ $o })) {
        $ui->SetTempEnv($k, $o->{$k});
    }
    
    $ui->SetTempEnv('PAYLOAD', $state->{'PAYLOAD'});
    
    my $validPayloads = $ui->MatchPayloads($exploit, $payloads) if($exploit->Payload);

    my $payloadName = $ui->GetEnv('PAYLOAD');
    my $payload = $validPayloads->{$payloadName};

	if ($state->{'NOP'} && $state->{'NOP'} ne 'default') {
		$ui->SetTempEnv('Nop', $state->{'NOP'});
	}
	
	if ($state->{'ENCODER'} && $state->{'ENCODER'} ne 'default') {
		$ui->SetTempEnv('Encoder', $state->{'ENCODER'});
	}

    # Mmmmm, candy
    $ui->SetTempEnv('_Exploits', $exploits);
    $ui->SetTempEnv('_Payloads', $payloads);
    $ui->SetTempEnv('_Exploit', $exploit);
    $ui->SetTempEnv('_PayloadName', $payloadName);
    $ui->SetTempEnv('_Payload', $payload);
    $ui->SetTempEnv('_ValidPayloads', $validPayloads);
    $ui->SetTempEnv('_UI', $ui);
   
    
    if ($state->{"ExploitAction"} eq "Vulnerability Check") {
        $res .= "\n<form action='$burl' method='GET'>\n";
        foreach (keys(%{$state})) {
            if ($_ ne "MODE")  {
                $res .= "<input type='hidden' name='$_' value='" . $state->{$_} . "'>\n";
            } else {
                $res .= "<input type='hidden' name='MODE' value='EXPLOIT'>\n";
            }
        }

        $res .= "<input type='submit' name='ExploitAction' value='Launch Exploit'>\n";
        $res .= "</form>\n";
        $res .= "<hr><br/><br/>\n";
        $res .= "<br/><div class='textBold'>Check Results:</div>";
		$res .= "<div class='textNormal'>" . (($ui->Check) ? "Vulnerable" : "Not Vulnerable") . "</div><br/>\n";
        $res .= "<br/>". join("<br/>\n", @{$ui->DumpLines}) . "<br/>\n";
        return $res;
    }
    $res .= "<table align='center' padding=4 border=0 cellspacing=0 width='95%'>\n";
    
    if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) ) {
        $res .=  "<tr><td class='textBold'>Payload must be selected first!</td></tr></table>\n";
        return $res;
    }
    
  
    # We hijack the socket from the web service
    my $bout = $state->{'client'};
	my $pout = $state->{'parent'};
		
	# Use chunked transfer mode to return partial responses
	my $out = "HTTP/1.1 200 OK\r\n".
	          "Connection: close\r\n".
			  "Date: ". HTTPDate()."\r\n".
			  "Content-Type: text/html\r\n".
			  "Transfer-Encoding: chunked\r\n\r\n";
	
    $bout->Send($out);
	
	$out = HTML_Header().
           "<div class='moduleOutput'>\n".
           "<b>Processing exploit request (".$exploit->Name.")...</b><br/>\n".
           "<b>Using payload: " . $payloadName . "</div><br/>\n".
qq[		   
		<br/>
		</td>
	</tr>
</table></td></tr></table>
<br/>
];


	# Close out the main table and prepare for incremental output
	$out .=
		"<br\><hr size=1 width='80%'>".
		"<div align='center' class='navHead'> Exploit Output </div>\n".
		"<hr size=1 width='80%'><br\>".	
		"<div align='left' class='moduleOutput' bgcolor='#dddddd'>\n".
		"<blockquote><blockquote>\n\n";
	$bout->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
	
	
	# Ask the parent for a session ID
	$pout->printflush("SESSION\n");
	my $raw = $pout->getline;
	
	
	if (! $raw || $raw !~ /SID ([0-9]{0,16})/ ) {
		$out = "[*] <div class='textBold'>msfweb: unable to obtain session...</div>";
		$bout->Send(sprintf("%x\r\n%s\r\n", length($out), $out));
		exit(0);
	}
	
	my ($sid) = $raw =~ m/SID ([0-9]{0,16})/g;

	
	# Configure stdio for the child process
	my ($einp, $eout, $einp_sock, $eout_sock);
	
	socketpair($einp_sock, $eout_sock, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
	
	my $einp = IO::Handle->new_from_fd(fileno($einp_sock), "a+");
	my $eout = IO::Handle->new_from_fd(fileno($eout_sock), "a+");
	
	# Configure the environment...
	$ui->SetTempEnv('_PipeInput',  $einp);
	$ui->SetTempEnv('_PipeOutput', $einp);
	$ui->SetTempEnv('_GhettoIPC',  $pout);
	$ui->SetTempEnv('_SessionID',  $sid);
    $ui->SetTempEnv('_BrowserSocket', $bout);	
	
	# Save the parent pid
	my $top = $$;
	
	# Save off some information about this session
	my %sess =
	(
		'module'	=> $module,
		'client'	=> $bout->PeerAddr,
		'target'	=> $ui->GetEnv('RHOST') || 'unknown',
		'start'		=> time(),
		'payload'	=> $ui->GetEnv('PAYLOAD') || 'unknown',
	);
	
	
	# Now things get interesting :-)
	my $epid = fork();
	
	# The main process will keep our IPC open as long as we stay alive
	if ($epid) {
		
		my $cache_file = $ui->GetEnv('_CacheDir').sprintf("/cache%.8x.dat", $sid);
		
		# Wait for the go-ahead message from the parent
		my $ok = $pout->getline;
		exit if ! $ok;
		chomp($ok);

		if ($ok eq 'SHUTDOWN') {
			print STDERR "Shutting down the shell server...\n";
			$eout->close;
			$pout->close;
			exit(0);
		}
		
		if ($ok ne 'SHELL') {
			print STDERR "Unknown starting command: $ok\n";
			$eout->close;
			$pout->close;
			exit(0);
		}
		
		my $info = IPCHashToData(%sess);
		$pout->printflush("INFO $sid $info\n");
		

		unlink($cache_file);
		if (! open (CACHE, ">$cache_file")) {
			print STDERR "Could not open cache file: $!\n";
			$eout->close;
			$pout->close;
			exit(0);
		}

		my $cache = IO::Handle->new_from_fd(fileno(CACHE), "a+");
		$cache->blocking(0);
		$cache->autoflush(1);
		
		my $keepRunning = 1;
		
		while ($keepRunning) {
			my $sel = IO::Select->new();
			
			foreach ($eout, $pout) {
				$_->autoflush(1);
				$_->blocking(0);
				$sel->add($_);
			}

			my @rdy = $sel->can_read(0.25);
			foreach my $fd (@rdy) {
				
				# Output from the shell
				if ($fd eq $eout) {
					my ($data, $buff);
					while ($eout->read($buff, 1024)) { $data .= $buff }
					$cache->printflush(XSS_Filter($data));
					$cache->sync;
				}
				
				# Request from the server
				if ($fd eq $pout) {
					my $data = $pout->getline;
					chomp ($data);
					
					if ($data eq 'SHUTDOWN') {
						$keepRunning = 0;
						next;
					}
					
					# Command request from a client
					if ($data =~ m/CMD\s+(.*)/) {
						my $bytes = pack("H*", $1);
						$eout->printflush($bytes);
						
						# write command to cache file
						$bytes = XSS_Filter($bytes);
						my $out = "<div class='textBold'>&gt;&gt; $bytes</div>\n";
						$cache->printflush($out);
						$cache->sync;
						next;
					}
					
					print STDERR "Unknown server request: $data\n";
				}
			}
		}
		
		$cache->printflush("<div class='textBold'>&gt;&gt; Session is shutting down...</div>\n");

		# Shut down the service...
		$eout->close;
		$pout->close;
		exit(0);
	}
	
	# Feel the magic o_0
    $ui->Exploit();
	
	if (! $ui->GetTempEnv('_ShellServer')) {
		$pout->printflush("SHUTDOWN $sid\n");
		print STDERR "Shutting down the shell server process...\n";
	}	

	print STDERR "Exiting exploit loop\n";
    exit(0);
}


# Primitive HTTP request parser
sub HTTPRequest {
	my $self	= shift;
    my $cli		= shift;
	my $opt		= shift;
	
	my $timeout	= exists($opt->{'Timeout'}) ? $opt->{'Timeout'} : 30;
	my $raw		= $cli->Recv(-1, $timeout);
	return {} if ! $raw;
		
	my ($meth, $uri, $path, $query);
	my %headers;
	my %params;

	my @lines	= split(/\n/, $raw);
	my $rmeth	= shift(@lines);
		
	# Parse the request method and URI
	if ($rmeth =~ m/^([^\s]+)\s+([^\s]+)\s+/) {
		$meth	= lc($1);
		$uri	= $2;
	} 
	else { return; }
	
	# Read the HTTP request headers
	foreach my $line (@lines) {
		$line =~ s/\r|\n//g;
		last if $line eq '';
		if ($line =~ m/^([^:]+):(\s+|)(.*)$/) {
			$headers{lc($1)} = $3;	
		}
	}

	# Convert URI encoding to hex encoding
    $uri =~ s/\+/%20/g;
		
	# Split out the path from the query string
	if ($uri =~ m/^([^\?]+)(\?(.*)|)$/) {
		$path	= $1;
		$query	= $3;
	}
	
	# Convert hex encoding to plain text
	$path =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
	
	# Remove some garbage from the request
	$path =~ s/\x00|\x0a|\x0d|\<|\>|\s+$//g;
	
	# Remove parent paths and other bad joojoo
	$path =~ s/\/\.\.\/|\/\.\/|\\//g;
	
	# Convert multiple forward slashes to a single
	$path =~ s/\/+/\//g;

	# Break the invidual variables into chunks
    my @chunks = split(/&/, $query);
    
	# Process the chunks and place into %params
	foreach my $chunk (@chunks) {
        my ($var, $val) = split(/=/, $chunk);
        $val =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $params{$var} = $val;

        # ignore empty values
        $val =~ s/^\s+|\s+$//g;
        
		# strip out some hostile chars
		$val =~ s/\x00|\x0a|\x0d//g;
		
		# avoid cheesy xss attacks
        $val = XSS_Filter($val);      
        
        if (! length($val)) { delete($params{$var}) }
    }
    
    # Create a nice big hash of the request
	my $res  =
	{
		'method'	=> $meth,
		'headers'	=> \%headers,
		'params'	=> \%params,
		'path'		=> $path,
	};

	# Process the URL
	($res->{'base'}) = $path =~ m/^\/([^\?]+)/;
	if (! $res->{'base'}) {
		$res->{'base'} = 'EXPLOITS';
	}

	# Default to main mode
	if (! $res->{'params'}->{'MODE'}) {
		$res->{'params'}->{'MODE'} = 'MAIN';
	}
	
	return $res;
}

sub HTTPResponse {
	my $code = @_ ? shift() : 403;
	my $body = @_ ? shift() : '';
	my $type = @_ ? shift() : 'text/html';
	my $data;
	
	$data = "HTTP/1.1 $code\r\n".
			"Connection: close\r\n".
			"Date: ". HTTPDate() ."\r\n".
	        "Content-Length: ".length($body)."\r\n".
			"Content-Type: $type\r\n".
			"\r\n". $body;

	return $data;
}

sub HTTPDate {
	return strftime("%a, %e %b %Y %H:%M:%S GMT", gmtime());
}

sub CharsToBytes {
	my $chars = shift;
	my $badChars;
	foreach my $hc (split(/\s+/, $chars)) {
		if ($hc =~ m/^0x(.|..)/) {
			$badChars .= chr(hex($hc));
		} else {
			# it isn't hex char... maybe just plain char?
			foreach (split(//, $hc)) {
				$badChars .= $_;
			}
		}
	}
	return $badChars;
}

# XXX - not complete
sub XSS_Filter {
	my $data = shift;
	
	$data =~ s/\</\&lt;/g;
	$data =~ s/\>/\&gt;/g;
	return $data;
}

sub IPCDataToHash {
	my $data = shift;
	my %hash;
	
	foreach (split(/,/, $data)) {
		my ($var, $val) = split(/\=/, $_);
		next if ! $var;
		next if ! $val;
		$hash{$var} = pack("H*", $val);
	}
	return %hash;
}

sub IPCHashToData {
	my %hash = @_;
	my $data;
	foreach (keys %hash) {
		$data .= $_."=".unpack("H*", $hash{$_}).",";
	}
	return $data;
}

sub ListColor {
	my $color = shift;
	return ($color eq '#ffffff') ? '#dddddd' : '#ffffff';
}

sub LoadAllModules {
	$exploitsIndex	= $ui->LoadExploits;
	$payloadsIndex	= $ui->LoadPayloads;
	$encodersIndex	= $ui->LoadEncoders;
	$nopsIndex		= $ui->LoadNops;

	$moduleKeys		= {};
	$moduleOS		= {};
	$moduleArch		= {};
	$modules		= {};
	
	foreach my $key (keys(%{$exploitsIndex})) {
		my $exploit = $exploitsIndex->{$key};
		
		$exploits->{$exploit->SelfEndName} = $exploit;
		$modules->{'exploits'}->{$exploit->SelfEndName} = $exploit;
		
		foreach my $kname ( @{ $exploit->Keys } ) {
			push @{ $moduleKeys->{'exploits'}->{$kname} }, $exploit->SelfEndName;
		}

		foreach my $kname ( @{ $exploit->OS } ) {
			push @{ $moduleOS->{'exploits'}->{$kname} }, $exploit->SelfEndName;
		}
		
		foreach my $kname ( @{ $exploit->Arch } ) {
			push @{ $moduleArch->{'exploits'}->{$kname} }, $exploit->SelfEndName;
		}				
	}

	foreach my $key (keys(%{$payloadsIndex})) {
		my $payload = $payloadsIndex->{$key};
		
		$payloads->{$payload->SelfEndName} = $payload;
		$modules->{'payloads'}->{$payload->SelfEndName} = $payload;
		
		foreach my $kname ( @{ $payload->OS } ) {
			push @{ $moduleOS->{'payloads'}->{$kname} }, $payload->SelfEndName;
		}
		
		foreach my $kname ( @{ $payload->Arch } ) {
			push @{ $moduleArch->{'payloads'}->{$kname} }, $payload->SelfEndName;
		}				
	}

	$ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
	$ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
	$ui->SetTempEnv('_Encoders', $encodersIndex);
	$ui->SetTempEnv('_Nops', $nopsIndex);
	$ui->SetTempEnv('_UI', $ui);
}



####################
package GhettoWeb; #
####################

use POSIX;
use IO::Socket;
use IO::Select;
use Pex;

sub new {
	my $name	= shift;
	my $self	= bless {}, $name;
	$self->_config(@_);
	$self->{'_Session'} = { };
	$self->{'_LastSession'} = 0;	
	return $self;
}

sub _config {
	my $self = shift;
	my %args = @_;
	foreach (keys %args) {
		$self->{'_Config'}->{$_} = $args{$_};
	}
};

sub SessionNext {
	my $self = shift;
	my $curr = $self->{'_LastSession'};
	$self->{'_LastSession'} = $curr + 1;

	return $self->{'_LastSession'};
}

sub SessionNew {
	my $self	= shift;
	my $ipc		= shift;
	my $sid 	= $self->SessionNext;
	
	$self->{'_Session'}->{$sid} =
	{
		'IPC'	=> $ipc,
		'PID'	=> 0,
		'Data'	=> '',
	};
	$self->Log(3, "Creating session $sid with IPC socket $ipc");	
	return $sid;
}

sub SessionDataGet {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});

	my $data = $self->{'_Session'}->{$sid}->{'Data'};
	$self->{'_Session'}->{$sid}->{'Data'} = '';
	return $data;	
}

sub SessionDataPut {
	my $self = shift;
	my $sid  = shift;
	my $data = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});

	$self->{'_Session'}->{$sid}->{'Data'} .= $data;
	return length($self->{'_Session'}->{$sid}->{'Data'});
}

sub SessionPipePID {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});
	$self->{'_Session'}->{$sid}->{'PID'} = shift if @_;
	return $self->{'_Session'}->{$sid}->{'PID'};
}

sub SessionIPC {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});
	$self->{'_Session'}->{$sid}->{'IPC'} = shift if @_;
	return $self->{'_Session'}->{$sid}->{'IPC'};
}

sub SessionRemove { 
	my $self = shift;	
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});
	
	# shut down the pipe process
	if ((my $pid = $self->SessionPipePID($sid))) {
		$self->Log(3, "Removing session $sid with Pipe PID $pid");
		kill(9, $pid);
	}
	
	# shut down the ipc channel
	eval { $self->SessionIPC->close };
	
	# remove the entry from the session list
	delete($self->{'_Session'}->{$sid});

	return;
}

sub SessionList { 
	my $self = shift;
	return keys %{ $self->{'_Session'} };
}

sub SessionInfo {
	my $self = shift;
	my $sid  = shift;
	
	return if ! exists($self->{'_Session'}->{$sid});
	$self->{'_Session'}->{$sid}->{'Info'} = shift if @_;
	return $self->{'_Session'}->{$sid}->{'Info'};
}

sub SessionCheck { 
	my $self = shift;	
	my $sid  = shift;
	return 0 if ! exists($self->{'_Session'}->{$sid});
	return 1;
}

sub IsError {
    my $self = shift;
    return 1 if exists($self->{'_Error'});
    return;
}

sub GetError {
    my $self = shift;
    return if ! exists($self->{'_Error'});
    return $self->{'_Error'};
}

sub SetError {
    my $self = shift;
    my $boom = shift;
    $self->{'_Error'} = $boom;
    return $self->{'_Error'};
}

sub ClearError {
    my $self = shift;
    delete($self->{'_Error'});
}

sub LogFile {
	my $self = shift;
	$self->{'_LogFile'} = shift() if @_;
	return $self->{'_LogFile'};
}

sub Log {
    my $self	= shift;
	my $lvl		= shift;
	my $msg		= @_ ? shift() : return;
	
	if ( open(X, ">>".$self->LogFile) ) {
    	print X scalar(localtime())." <$lvl> $msg\n";
    	close(X);
	}
}



sub Run {
	my $self = shift;
	my $args = $self->{'_Config'};

	my $host  = $args->{'host'};
	my $port  = $args->{'port'};
	my $fnWeb = $args->{'fnWeb'} || sub { };
	my $fnIPC = $args->{'fnIPC'} || sub { };
	my $fnHRP = $args->{'fnHRP'} || sub { };
	
	my $httpd = IO::Socket::INET->new 
	(
    	LocalAddr => $host,
    	LocalPort => $port,
    	ReuseAddr => 1,
    	Listen    => 5,
	);
	
	if (! $httpd) {
		$self->SetError("Failed to start listener: $!");
		return;
	}
	
	$httpd->blocking(0);
	
	$SIG{'CHLD'} = sub { while (waitpid(-1, WNOHANG) == 0) { } };

	my %socketInfo = 
	(
		$httpd	=> [$httpd, 0, 'listener'],
	);

	my $keepRunning = 1;
	
	# The main event loop
	while ($keepRunning) {

		my $sel = IO::Select->new();

		foreach my $s (keys %socketInfo) {
			# Process all but child-side sockets
			if ($socketInfo{$s}->[2] ne 'ipc_child') {
				my $sd = $socketInfo{$s}->[0];

				if (! $sd) {
					$self->Log(1, "socketInfo{ $s } is invalid");
					delete($socketInfo{$s});
					next;
				}

				$sd->blocking(0);
				$sd->autoflush(1);
				$sel->add($sd);
			}
		}

		# Select for new connections and data
		my @ready = $sel->can_read(10);

		# Process each flagged socket
		foreach my $s (@ready) {

			# A new connection
			if ($s eq $httpd) {
				my ($client) = $httpd->accept;
				
				if (! $client) {
					$self->Log(1,  "Accept failed on primary listener socket: $@");
					next;
				}

				$socketInfo{$client} = [$client, 0, 'client'];
				$self->Log(3, "New client connection from ".$client->peerhost);
				next;
			}

			# A new HTTP request
			if ($socketInfo{$s}->[2] eq 'client') {
				my $cli = Msf::Socket::Tcp->new_from_socket($s);
				my $res = $fnHRP->($self, $cli);

				if ($res) {
					my ($par, $chi);

					# Create the comm channel between parent and child
					socketpair($par, $chi, AF_UNIX, SOCK_STREAM, PF_UNSPEC);

					# Spawn off the child process
					my $pid = fork();
					if (! $pid) {
						
						# Close the http listener inside the child
						$httpd->close;
						$self->Log(3,  "fnWeb called with pid $$...");						
						$fnWeb->($self, $res, $cli, $chi);
						exit(0);
					}

					$socketInfo{$par} = [$par, $pid, 'ipc'];
					$socketInfo{$chi} = [$chi, $pid, 'ipc_child'];
				} 
				else {
					eval { $s->shutdown(2); };
					eval { $s->close; };
				}

				# XXX - local cleanup up the original socket?
				delete($socketInfo{$s});
				next;
			}

			# A new IPC request
			if ($socketInfo{$s}->[2] eq 'ipc') {
				$self->Log(3,  "fnIPC called with pid $$ ($s)...");
				$fnIPC->($self, $s);
				next;
			}

			# Unknown socket type...
			$self->Log(1, "Unknown socket type ".$socketInfo{$s}->[2]);
		}

		# Remove sockets attach to dead processes
		foreach my $s (keys %socketInfo) {
			my $spid = $socketInfo{$s}->[1];
			if ($spid && ! kill(0, $spid)) {
				$self->Log(3, "Removed $s ($spid) of type ".$socketInfo{$s}->[2]);
				eval { $socketInfo{$s}->[0]->shutdown(2); };
				eval { $socketInfo{$s}->[0]->close; };
				delete($socketInfo{$s});
			}
		}
	}
}
