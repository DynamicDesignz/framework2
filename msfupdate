#!/usr/bin/perl
###############

require 5.6.0;
use strict;
use vars qw{$SSL_SUPPORT};

use FindBin qw{$RealBin};
use lib "$RealBin/lib";
use Digest::Perl::MD5 qw{md5_hex};
use Getopt::Std;
use IO::Socket;
use IO::Select;
use POSIX;

my $VERSION = '$Revision$';

my $UPDATE_HOST = "metasploit.com";
my $UPDATE_PATH = "/projects/Framework/updates";
my $SSL_VERIFIED = 0;
my $SSL_ISSUER   = '/C=US/ST=Texas/L=San Antonio/O=The Metasploit Project/OU=Development/CN=Metasploit CA/emailAddress=cacert@metasploit.com';
my $SSL_CERTS    = "$RealBin/docs";

select(STDOUT); $|++;
        
# Determine if SSL support is enabled
BEGIN
{
    if (eval "require Net::SSLeay")
    {
        Net::SSLeay->import();
        Net::SSLeay::load_error_strings();
        Net::SSLeay::SSLeay_add_ssl_algorithms();
        Net::SSLeay::randomize();
        $SSL_SUPPORT++;
    }
}

my %opts;
getopts('hvmruas', \%opts);

if ($opts{v}) {
    print "Msfupdate Version: $VERSION\n";
    exit(0);
}

if ($opts{h} || (! $opts{m} && ! $opts{r} && ! $opts{u})) {
    Usage();
}

chdir($RealBin);

my ($old_data, $now_data, $new_data);
my ($old, $now, $new);
my ($mod, $upx, $upd, $err);

$now_data = ScanFiles('.');

if (! -r '.current') {
    WriteFile('.current', $now_data);
    $old_data = $now_data;
} 
else {
    $old_data = ReadFile('.current');
}

if ($opts{r}) {
    print "[*] The local file hash has been rebuilt\n";
    WriteFile('.current', $now_data);
    exit(0);
}

if ($opts{u}) {
    if (! $SSL_SUPPORT) {
        print "[*] WARNING: The Net::SSLeay module is not installed.\n";
        print "    The update process will fall back to plain HTTP,\n";
        print "    this opens up the possibility of someone being\n";
        print "    able to inject malicious code into your system.\n";
        print "\n";
        print "Continue anyways (yes or no) ";
        my $resp;
        while ($resp !~ /yes|no/i) {
            print "> ";
            $resp = <STDIN>;
            chomp($resp);
        }
        print "\n";
        
        if ($resp !~ /yes/i) {
            print "[*] The update process has been cancelled\n";
            exit(0);
        }
    }
    
    $new_data = DownloadFile($UPDATE_HOST, "$UPDATE_PATH/.current");
}

$now = Hashit($now_data);
$old = Hashit($old_data);
$new = Hashit($new_data);

$mod = Diff($old, $now);
$upx = Diff($old, $new);
$upd = Diff($now, $new);

$err = { };

if ($opts{m}) {
    if (! keys(%{$mod})) {
        print "[*] No modifications since the last update\n";
        exit(0);
    }
    
    print "[*] Modifications since the last update:\n";
    foreach (keys(%{$mod})) {
        print "\t".$mod->{$_}."\t$_\n";
    }
    print "\n";
    exit(0);
}

# Strip this list down to just modifications
foreach (keys(%{$mod})) {
    if ($mod->{$_} ne 'Mod') {
        delete($mod->{$_});
    }
}

# They modified something, ask them what they want to do with it
if (! $opts{a} && keys(%{$mod})) {  
    print "[*] WARNING: You have made modifications to the\n";
    print "    following components of the Framework:\n\n";
    foreach (sort(keys(%{$mod}))) {
        print "\t".$_."\n";
    }
    print "\n";
    print "    Would you like to preserve these changes? If\n";
    print "    you say no, all local modifications will be\n";
    print "    overwritten by the updates.\n";
    print "\n";
    print "Preserve modifications (yes or no) ";
    my $resp;
    while ($resp !~ /yes|no/i) {
        print "> ";
        $resp = <STDIN>;
        chomp($resp);
    }
    if ($resp =~ /no/i) {
        $mod = {};
    }
}

# Do not remove user-created files
foreach (keys(%{$upd})) {
    if ($upd->{$_} eq 'Del') {
        delete($upd->{$_});
    }
}

# Ignore locally modified files when -a is supplied
if ($opts{a}) {
    $mod = {};
}

# After all of this stuff, this is what we have
# - $mod is a table of anything the user wants to keep
# - $upd is a table of everything online new or updated


# The plan of attack is:
# - Iterate through each item in $upd, if there is a match in
#   $mod, we print a message and ignore the download for it.
#   We will delete anything with the Del status set in this
#   table. 
# - Once we have identified an update, we try to download it.
#   If an error occurs, either because the download fails or
#   the md5 does no match, we place this into the $err table.
#
# - After all files have been processed, we rebuild the local
#   .current file and get ready for the next update.
#

print "[*] Update Task Summary\n\n";
foreach my $entry (keys(%{$upd})) {
    if ($mod->{$entry}) {
        print "\tIgnore $entry\n";
    }
    else {
        print "\tUpdate $entry\n";
    }
}
print "\n";

exit(0) if $opts{s};

if (! $opts{a}) {
    print "Continue? (yes or no) ";
    my $resp;
    while ($resp !~ /yes|no/i) {
        print "> ";
        $resp = <STDIN>;
        chomp($resp);
    }
    print "\n";
    if ($resp !~ /yes/i) {
        exit(0);
    }
}

foreach my $entry (keys(%{$upd})) {
    if ($mod->{$entry}) {
        next;
    } 
    my $data = DownloadFile($UPDATE_HOST, "$UPDATE_PATH/current/$entry");
    if ($upd->{$entry} ne md5_hex($data)) {
        print "[*] Error downloading file $entry\n";
        if ($data) {
            $err->{$entry} = "Checksum Error";
        }
        else {
            $err->{$entry} = "Download Error";
        }
        next;
    }
    
    # overwrite the local file O_o
    WriteFile($entry, $data);
    
    # set it executable since we dont track permissions
    chmod(0755, $entry);
    
    print "[*] Successfully downloaded $entry (".length($data)." bytes)\n";
}

print "[*] Regenerating local file database\n";
$now_data = ScanFiles('.');
WriteFile('.current', $now_data);

if (keys(%{$err})) {
    print "[*] The following errors were encountered:\n";
    foreach (%{$err}) {
        print "\t".$err->{$_}."\t$_\n";
    }
}

if ($new_data) {

    print "Changes against update set\n";
    print "==========================\n\n";
    foreach (keys(%{$upd})) {
        print "\t".$upd->{$_}."\t$_\n";
    }
    print "\n\n";

    print "Changes between old and new\n";
    print "==========================\n\n";
    foreach (keys(%{$upx})) {
        print "\t".$upx->{$_}."\t$_\n";
    }
    print "\n\n";
}


sub Usage { 
    print STDERR "  Usage: $0 [options]>\n";
    print STDERR "Options:\n";
    print STDERR "         -h             You're looking at me baby\n";
    print STDERR "         -v             List version information\n";
    print STDERR "         -u             Perform an online update via metasploit.com\n";
    print STDERR "         -s             Only display update tasks, do not actually download\n";
    print STDERR "         -m             Show any files locally modified since last update\n";
    print STDERR "         -a             Do not prompt, default to overwrite all files\n";
    # Developer options
    # print STDERR "         -r             Rebuild the local version database\n";
    exit(0);
}

sub ScanFiles {
    my $dir = shift;
    my $res;
    my $hwn;
    
    opendir ($hwn, $dir) || return;
    
    while (defined(my $entry = readdir($hwn))) {
        my $path = "$dir/$entry";

        # ignore all symlinks
        next if -l $path;
        
        # ignore all leading dot files   
        next if $entry =~ /^\./;
        
        # ignore cvs directories
        next if $entry eq 'CVS';
        
        # ignore the development tools
        next if $entry eq 'dev';
        
        # recurse into directories
        if (-d $path) {
            $res .= ScanFiles($path);
        } 
        elsif (-f $path) {
            $res .= HashFile($path)."\t$path\n";;
        }
    }
    closedir($hwn);
    return $res;   
}


sub DownloadFile {
    my $host = shift;
    my $path = shift;
    my $port = $SSL_SUPPORT ? 443 : 80;
    my $data;
    
    my $sock = IO::Socket::INET->new
    (
        PeerAddr    => $host,
        PeerPort    => $port,
        Proto       => 'tcp',
    );
    
    if (! $sock) {
        print STDERR "[*] Could not connect to $host: $!\n";
        exit(0);
    }
    my ($vnum) = $VERSION =~ m/\$Revision$]+)/;
    my $req = "GET $path HTTP/1.0\r\nUser-Agent: MSFUPDATE/$vnum\r\n\r\n";

    if ($SSL_SUPPORT) { 
        # Reset the verified flag
        $SSL_VERIFIED = 0;

        # Create SSL Context
        my $ctx = Net::SSLeay::CTX_new();
       
        # Tell SSL to use the certificate in the docs directory 
        Net::SSLeay::CTX_load_verify_locations($ctx, '', $SSL_CERTS);
        
        # Configure the SSL call-back to prevent MiTM
        Net::SSLeay::CTX_set_verify($ctx, &Net::SSLeay::VERIFY_PEER, \&SSLVerify);
                
        # Configure session for maximum interoperability
        Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL);
        
        # Create a new SSL object with context
        my $ssl = Net::SSLeay::new($ctx);

        # Bind the SSL descriptor to the socket
        Net::SSLeay::set_fd($ssl, $sock->fileno);
        
        # Negotiate connection
        my $sslConn = Net::SSLeay::connect($ssl);

        if ($sslConn <= 0) {
            print STDERR "[*] SSL error:". Net::SSLeay::print_errs()."\n";
            $sock->close;
            return;
        }
        
        Net::SSLeay::ssl_write_all($ssl, $req);
        $sock->shutdown(1);    
        
        my $cert = Net::SSLeay::get_peer_certificate($ssl);
        
        $data = Net::SSLeay::ssl_read_all($ssl);
        
        Net::SSLeay::free ($ssl);
        Net::SSLeay::CTX_free ($ctx);
        $sock->close;
        
        $data = ProcessHTTP($data);
        return $data;
    }
    
    $sock->send($req);
    $sock->shutdown(1);
    while (<$sock>) { $data .= $_ }
    close ($sock);
    $data = ProcessHTTP($data);    
    return $data;
}

# Prevent MiTM attacks on the update downloads when run over SSL
sub SSLVerify {
    my ($ok, $x509_store_ctx) = @_;
    my $cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($x509_store_ctx);
    
    if ($cert) {
        my $x509_issuer =  Net::SSLeay::X509_get_issuer_name($cert);
        my $issuer = Net::SSLeay::X509_NAME_oneline($x509_issuer);
        if ($ok && $issuer eq $SSL_ISSUER) {
            $SSL_VERIFIED++;
            return 1;
        }
    }
   
    return;
}

sub ProcessHTTP {
    my $http = shift;
    my @chunks = split(/\r\n\r\n/, $http);
    my $head = shift(@chunks);
    my $body = join("\r\n\r\n", @chunks);
    return if $head !~ /HTTP\/1.. 200\s+/;
    return $body;
}

sub WriteFile {
    my $file = shift;
    my $data = shift;
    open (my $out, ">$file") || return;
    print $out $data;
    close ($out);
}

sub ReadFile {
    my $path = shift;
    my $data;
    my $inp;
    
    open($inp, "<$path") || return;
    while (<$inp>) { $data .= $_ }
    close($inp);
    
    return $data;
}

sub HashFile {
    my $path = shift;
    my $data = ReadFile($path);
    return md5_hex($data);
}

sub Hashit {
    my $data = shift;
    my $hash = {};
    foreach my $line (split(/\n/, $data)) {
        my ($md5, $path) = split(/\s+/, $line);
        $hash->{$path} = $md5;
    }
    return $hash;
}

sub Diff {
    my $setA = shift;
    my $setB = shift;
    my $res;
    
    foreach (keys(%{$setA})) {
        if (exists($setB->{$_})) {
            if ($setA->{$_} ne $setB->{$_}) {
                $res->{$_} = 'Mod';
            }
        } 
        else {
            $res->{$_} = 'Del';
        }
    }
    
    foreach (keys(%{$setB})) {
        if (! exists($setA->{$_})) {
            $res->{$_} = 'New';
        }
    }
    
    return $res;
}
