#!/usr/bin/perl
###############

require 5.6.0;
use strict;
use vars qw{$SSL_SUPPORT};

use FindBin qw{$RealBin};
use lib "$RealBin/lib";
use Digest::Perl::MD5 qw{md5_hex};
use Getopt::Std;
use IO::Socket;
use IO::Select;
use POSIX;


my $UPDATE_HOST = "metasploit.com";
my $UPDATE_PATH = "/projects/Framework/updates";
my $SSL_VERIFIED = 0;
my $SSL_ISSUER   = '/C=US/ST=Texas/L=San Antonio/O=The Metasploit Project/OU=Development/CN=Metasploit CA/emailAddress=cacert@metasploit.com';
my $SSL_CERTS    = "$RealBin/docs";

# Determine if SSL support is enabled
BEGIN
{
    if (eval "require Net::SSLeay")
    {
        Net::SSLeay->import();
        Net::SSLeay::load_error_strings();
        Net::SSLeay::SSLeay_add_ssl_algorithms();
        Net::SSLeay::randomize();
        $SSL_SUPPORT++;
    }
}

chdir($RealBin);

my $old_data;
my $now_data = ScanFiles('.');
if (! -r '.current') {
    WriteFile('.current', $now_data);
    $old_data = $now_data;
} 
else {
    $old_data = ReadFile('.current');
}

my $new_data = DownloadFile($UPDATE_HOST, "$UPDATE_PATH/current.txt");

my $now = Hashit($now_data);
my $old = Hashit($old_data);
my $new = Hashit($new_data);

my $mod = Diff($old, $now);
my $upx = Diff($old, $new);
my $upd = Diff($now, $new);

print "Changes since last update\n";
print "==========================\n\n";
foreach (keys(%{$mod})) {
    print "\t".$mod->{$_}."\t$_\n";
}
print "\n\n";


if ($new_data) {

    print "Changes against update set\n";
    print "==========================\n\n";
    foreach (keys(%{$upd})) {
        print "\t".$upd->{$_}."\t$_\n";
    }
    print "\n\n";

    print "Changes between old and new\n";
    print "==========================\n\n";
    foreach (keys(%{$upx})) {
        print "\t".$upx->{$_}."\t$_\n";
    }
    print "\n\n";
}

sub ScanFiles {
    my $dir = shift;
    my $res;
    my $hwn;
    
    opendir ($hwn, $dir) || return;
    
    while (defined(my $entry = readdir($hwn))) {
        my $path = "$dir/$entry";

        # ignore all symlinks
        next if -l $path;
        
        # ignore all leading dot files   
        next if $entry =~ /^\./;
        
        # ignore cvs directories
        next if $entry eq 'CVS';
        
        # ignore the development tools
        next if $entry eq 'dev';
        
        # recurse into directories
        if (-d $path) {
            $res .= ScanFiles($path);
        } 
        elsif (-f $path) {
            $res .= HashFile($path)."\t$path\n";;
        }
    }
    closedir($hwn);
    return $res;   
}



sub DownloadFile {
    my $host = shift;
    my $path = shift;
    my $port = $SSL_SUPPORT ? 443 : 80;
    my $data;
    
    my $sock = IO::Socket::INET->new
    (
        PeerAddr    => $host,
        PeerPort    => $port,
        Proto       => 'tcp',
    );
    
    if (! $sock) {
        print STDERR "[*] Could not connect to $host: $!\n";
        exit(0);
    }

    my $req = "GET $path HTTP/1.0\r\nUser-Agent: msfupdate\r\n\r\n";

    if ($SSL_SUPPORT) { 

        # Create SSL Context
        my $ctx = Net::SSLeay::CTX_new();
       
        # Tell SSL to use the certificate in the docs directory 
        Net::SSLeay::CTX_load_verify_locations($ctx, '', $SSL_CERTS);
        
        # Configure the SSL call-back to prevent MiTM
        Net::SSLeay::CTX_set_verify($ctx, &Net::SSLeay::VERIFY_PEER, \&SSLVerify);
                
        # Configure session for maximum interoperability
        Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL);
        
        # Create a new SSL object with context
        my $ssl = Net::SSLeay::new($ctx);

        # Bind the SSL descriptor to the socket
        Net::SSLeay::set_fd($ssl, $sock->fileno);
        
        # Negotiate connection
        my $sslConn = Net::SSLeay::connect($ssl);

        if ($sslConn <= 0) {
            print STDERR "[*] SSL error:". Net::SSLeay::print_errs()."\n";
            $sock->close;
            return;
        }
        
        Net::SSLeay::ssl_write_all($ssl, $req);
        $sock->shutdown(1);    
        
        my $cert = Net::SSLeay::get_peer_certificate($ssl);
        
        $data = Net::SSLeay::ssl_read_all($ssl);
        
        Net::SSLeay::free ($ssl);
        Net::SSLeay::CTX_free ($ctx);
        $sock->close;
        
        $data = ProcessHTTP($data);
        return $data;
    }
    
    $sock->send($req);
    $sock->shutdown(1);
    while (<$sock>) { $data .= $_ }
    close ($sock);
    $data = ProcessHTTP($data);    
    return $data;
}

# Prevent MiTM attacks on the update downloads when run over SSL
sub SSLVerify {
    my ($ok, $x509_store_ctx) = @_;
    my $cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($x509_store_ctx);
    
    if ($cert) {
        my $x509_issuer =  Net::SSLeay::X509_get_issuer_name($cert);
        my $issuer = Net::SSLeay::X509_NAME_oneline($x509_issuer);
        if ($ok && $issuer eq $SSL_ISSUER) {
            $SSL_VERIFIED++;
            return 1;
        }
    }
   
    return;
}

sub ProcessHTTP {
    my $http = shift;
    my @chunks = split(/\r\n\r\n/, $http);
    my $head = shift(@chunks);
    my $body = join("\r\n\r\n", @chunks);
    return if $head !~ /HTTP\/1.. 200\s+/;
    return $body;
}

sub ReadFile {
    my $path = shift;
    my $data;
    my $inp;
    
    open($inp, "<$path") || return;
    while (<$inp>) { $data .= $_ }
    close($inp);
    
    return $data;
}

sub HashFile {
    my $path = shift;
    my $data = ReadFile($path);
    return md5_hex($data);
}

sub Hashit {
    my $data = shift;
    my $hash = {};
    foreach my $line (split(/\n/, $data)) {
        my ($md5, $path) = split(/\s+/, $line);
        $hash->{$path} = $md5;
    }
    return $hash;
}

sub Diff {
    my $setA = shift;
    my $setB = shift;
    my $res;
    
    foreach (keys(%{$setA})) {
        if (exists($setB->{$_})) {
            if ($setA->{$_} ne $setB->{$_}) {
                $res->{$_} = 'Mod';
            }
        } 
        else {
            $res->{$_} = 'Del';
        }
    }
    
    foreach (keys(%{$setB})) {
        if (! exists($setA->{$_})) {
            $res->{$_} = 'New';
        }
    }
    
    return $res;
}
