#!/usr/bin/perl
###############

##
#         Name: msfcli
#       Author: H D Moore <hdm [at] metasploit.com>
#       Author: spoonm <ninjatools [at] hush.com>
#      Version: $Revision$
#  Description: Command line interface to the Metasploit Exploit Framework
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

require 5.6.0;
$VERSION = "2.0";
use strict;
use FindBin qw{$Bin};
use lib "$Bin/lib";
use IO::Socket;
use POSIX;
use Msf::HandlerCLI;
use Msf::TextUI;

Msf::UI::ActiveStateSucks();

my $ui = Msf::TextUI->new($Bin);

my $exploits = { };
my $payloads = { };
my $exploitsIndex = $ui->LoadExploits;
my $payloadsIndex = $ui->LoadPayloads;
my $encoders = $ui->LoadEncoders;
my $nops     = $ui->LoadNops;


# Grab the 0x00 style module index
my $mod = shift;
my @ARG;

# A quick note:
# The Load methods return a hash of instantiated objects
# We should instantiate new objects when we are going to use them
# But since the cli only does 1 exploitation a run, its ok.

# Generate exploits index
# Payloads are now indexed by hex number instead of package name
my $i = 0;
foreach my $key (sort(keys(%{$exploitsIndex})))
{
    $exploits->{sprintf("0x%.2x", $i++)} = $exploitsIndex->{$key};
}

# Generate payloads index
# Payloads are now indexed by Name instead of package name
foreach my $key (keys(%{$payloadsIndex})) {
  $payloads->{$payloadsIndex->{$key}->Name} = $payloadsIndex->{$key};
}

if(!defined($mod) || !defined($exploits->{$mod})) {
  Msf::TextUI::PrintAsciiLogo();
  ListExploits();
  exit(0);
}

my $exploit = $exploits->{$mod};
my $exploitName = $exploit->SelfName;
$exploitName =~ s/.*:://g; # Remove package prefix
$ui->LoadTempEnv($exploitName);

$ui->SetTempEnv('_ExploitsIndex', $exploitsIndex);
$ui->SetTempEnv('_PayloadsIndex', $payloadsIndex);
$ui->SetTempEnv('_Encoders', $encoders);
$ui->SetTempEnv('_Nops', $nops);

# parse the command line options
while(my($key, $val) = split('\=', shift(@ARGV))) {
  if(!defined($val)) {
    push(@ARG, $key);
  }
  else {
    $ui->SetTempEnv($key, $val);
  }
}

my $validPayloads = $ui->MatchPayloads($exploit, $payloads) if($exploit->Payload);

my $payloadName = $ui->GetEnv('PAYLOAD');
my $payload = $validPayloads->{$payloadName};

# Mmmmm, candy
$ui->SetTempEnv('_Exploits', $exploits);
$ui->SetTempEnv('_Payloads', $payloads);
$ui->SetTempEnv('_Exploit', $exploit);
$ui->SetTempEnv('_PayloadName', $payloadName);
$ui->SetTempEnv('_Payload', $payload);
$ui->SetTempEnv('_ValidPayloads', $validPayloads);

if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) )
{
  $ui->PrintLine('[*] Invalid payload specified.');
  $ui->Payloads;
  exit(0);
}

# Main Dispatch
for(uc($ARG[0])) {
  $_ eq 'S' && do { $ui->Summary; last; };
  $_ eq 'O' && do { $ui->Options; last; };
  $_ eq 'A' && do { $ui->AdvancedOptions; last; };
  $_ eq 'P' && do { $ui->Payloads; last; };
  $_ eq 'T' && do { $ui->Targets; last; };
  $_ eq 'C' && do { $ui->Check; last; };
  $_ eq 'E' && do { $ui->SetTempEnv('HCALLBACK', \&xCallback); $ui->Exploit; last; };
  Usage();
}
exit(0);


################################################################################

sub Usage {
    print "\nUsage: $0 <ID> [var=val] [MODE]\n";
    print "Modes: \n";
    print "       (S)UMMARY      Show various information about the module\n";
    print "       (O)PTIONS      Show the available options for this module\n";
    print "       (A)DVANCED     Show the advanced options for this module\n";
    print "       (P)AYLOADS     Show available payloads for this module\n";
    print "       (T)ARGETS      Show available targets for this module\n";
    print "       (C)HECK        Determine if the target is vulnerable\n";
    print "       (E)XPLOIT      Attempt to exploit the target\n";
    print "\n";
}

sub ListExploits {
  print "\n============\n= Exploits\n\n";
  print $ui->DumpExploits(2, $exploits);
  print "\n";
}

sub xCallback { }
