#!/usr/bin/perl
###############

##
#         Name: msfcli
#       Author: H D Moore <hdm [at] metasploit.com>
#       Author: spoonm <spoonm [at] ghettohackers.net>
#      Purpose: Simple command line interface for launching exploits
#      Version: $Revision$
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

require 5.6.0;
$VERSION = "2.0";
use strict;
use FindBin qw{$Bin};
use lib "$Bin/lib";
use IO::Socket;
use POSIX;
use Msf::HandlerCLI;
use Msf::TextUI;

my $ui = Msf::TextUI->new($Bin);

# Grab the 0x00 style module index
my $mod = shift;
my @ARG;

# parse the command line options
while( my($key, $val) = split('\=', shift())) {
  if (! defined($val)) {
    push(@ARG, $key);
  }
  else {
    $ui->SetTempEnv($key, $val);
  }
}

my $exploits = { };
my $payloads = { };
my $exploitsIndex = $ui->LoadExploits;
my $payloadsIndex = $ui->LoadPayloads;
my $encoders = $ui->LoadEncoders;
my $nops     = $ui->LoadNops;

# A quick note:
# The Load methods return a hash of instantiated objects
# We should instantiate new objects when we are going to use them
# But since the cli only does 1 exploitation a run, its ok.

# Generate exploits index
# Payloads are now indexed by hex number instead of package name
my $i = 0;
foreach my $key (sort(keys(%{$exploitsIndex})))
{
    $exploits->{sprintf("0x%.2x", $i++)} = $exploitsIndex->{$key};
}

# Generate payloads index
# Payloads are now indexed by Name instead of package name
foreach my $key (keys(%{$payloadsIndex})) {
  $payloads->{$payloadsIndex->{$key}->Name} = $payloadsIndex->{$key};
}

if(!defined($mod) || !defined($exploits->{$mod})) {
  ListExploits();
  exit(0);
}

my $exploit = $exploits->{$mod};


my $payloadName = $ui->GetEnv('PAYLOAD');
my $payload = $payloads->{$payloadName};

if (defined($exploit->Payload) && defined($payloadName) && ! defined($payload) )
{
  $ui->PrintLine('[*] Invalid payload specified.');
  Payloads();
  exit(0);
}

# Mmmmm, candy
$ui->SetTempEnv('_Exploits', $exploits);
$ui->SetTempEnv('_Payloads', $payloads);
$ui->SetTempEnv('_Encoders', $encoders);
$ui->SetTempEnv('_Nops', $nops);

$ui->SetTempEnv('_Exploit', $exploit);
$ui->SetTempEnv('_PayloadName', $payloadName);
$ui->SetTempEnv('_Payload', $payload);

# Main Dispatch
for(uc($ARG[0])) {
  $_ eq 'S' && do { Summary(); last; };
  $_ eq 'O' && do { Options(); last; };
  $_ eq 'A' && do { Advanced(); last; };
  $_ eq 'P' && do { Payloads(); last; };
  $_ eq 'T' && do { Targets(); last; };
  $_ eq 'C' && do { Check(); last; };
  $_ eq 'E' && do { Exploit(); last; };
  Usage();
}
exit(0);


################################################################################

sub Summary {
  print $ui->DumpExploitSummary($exploit) . "\n";
}

sub Options {
  if (defined($exploit->Payload) && ! $payload)
  {
    die("[*] You must specify a payload before viewing the available options.\n");
  }
  print "============\n= Options\n\n";
  print $ui->DumpOptions(2, 'Exploit', $exploit);

  print $ui->DumpOptions(2, 'Payload', $payload) if(defined($exploit->Payload));
}

sub Advanced {
  if (defined($exploit->Payload) && ! $payload) {
    die("[*] You must specify a payload before viewing the available options.\n");
  }

  print "============\n= Advanced Options\n\n";
  print $ui->DumpAdvancedOptions(2, 'Payload', $payload) if(defined($exploit->Payload));
  print $ui->DumpAdvancedOptions(2, 'Exploit', $exploit);
}

sub Payloads {
  if (!defined($exploit->Payload)) {
    die("[*] This exploit does not use payloads.\n");
  }

  my $match = $ui->MatchPayloads($exploit, $payloads);

  print "============\n= Payloads\n\n";
  print $ui->DumpPayloads(2, $match) . "\n";
}

sub Targets {
  my @targets = $exploit->Targets;
  if (! defined(@targets) || ! scalar(@targets))
  {
    die("[*] This exploit does not define any targets.\n");
  }

  print "============\n= Targets\n\n";
  for(my $i = 0; $i < scalar(@targets); $i++)
  {
    printf ("  %d  $targets[$i]\n", $i);
  }
  print "\n";
}

sub Check {
  $exploit->Validate; # verify that all required exploit options have been set
  return if($exploit->PrintError);
  my $res = $exploit->Check;
  return if($exploit->PrintError);
  print "Check:   $res\n";
}

sub Exploit {

    $exploit->Validate;
    return if($exploit->PrintError);
    # validate payload module options
    if ($payload)
    {
        $payload->Validate;
        return if($payload->PrintError);

    }

    my @targets = $exploit->Targets;
    my $target = $ui->GetEnv('TARGET');
    if (defined($target) && ! defined($targets[$target]))
    {
      print "[*] Invalid target specified\n";
      exit(0);
    }
  
    # Important: Default the target to 0, maybe this should somehow
    # be in Msf::Exploit, maybe be part of the Validate process?
    $ui->SetTempEnv('TARGET', 0) if (!defined($target));
    if (defined($payload))
    {
        my $encodedPayload = $ui->Encode;
        return if($ui->PrintError || !$encodedPayload);
        $ui->SetTempEnv('EncodedPayload', $encodedPayload);
    }

    $ui->SetTempEnv('HCALLBACK', \&xCallback);

    my $handler = Msf::HandlerCLI->new();
    
    my ($phand, $chand, $phcode, $chcode);
    if ($payload && $handler->can($payload->Type))
    {
        $phand = $payload->Type;
        $chand = $phand . "_exp";
        
        # create the link between the child and parent processes
        if ($handler->can($phand) && $handler->can($chand))
        {
            my ($csock, $psock);
            $ui->SetTempEnv('HANDLER', $handler);
            $ui->SetTempEnv('HCFUNC',  $chand);
            
            print "[*] Creating link between child and parent process\n";
            
            socketpair($csock, $psock, AF_UNIX, SOCK_STREAM, PF_UNSPEC) 
            || die "msfcli: exploit: socketpair: $!";
            
            $ui->SetTempEnv('HCSOCK', $csock);
            $ui->SetTempEnv('HPSOCK', $psock);
        }      
    }
    
    my $child = fork();
    
    if ($child)
    {
        if ($exploit->Payload)
        {
            if ($phand)
            {
                print "[*] Starting handler $phand...\n";
                my $res = $handler->$phand($payload, $child);
                kill('TERM', $child);

                if (! $res)
                {
                    print "[*] Handler error: ". $handler->Error. "\n";
                    kill('TERM', $child);
                }

            } else {
                print "[*] No handler for payload type: ". $payload->Type. "\n";
            }
        }
        
        while (waitpid($child, WNOHANG) == 0) { sleep(1) }
        
    } else {
        select(undef, undef, undef, 0.5);
        $exploit->Exploit; 
        exit(0);
    }
    print "\n";
}

sub Usage {
    print "\nUsage: $0 <ID> [var=val] [MODE]\n";
    print "Modes: \n";
    print "       (S)UMMARY      Show various information about the module\n";
    print "       (O)PTIONS      Show the available options for this module\n";
    print "       (A)DVANCED     Show the advanced options for this module\n";
    print "       (P)AYLOADS     Show available payloads for this module\n";
    print "       (T)ARGETS      Show available targets for this module\n";
    print "       (C)HECK        Determine if the target is vulnerable\n";
    print "       (E)XPLOIT      Attempt to exploit the target\n";
    print "\n";
}

sub ListExploits {
  print "============\n= Exploits\n\n";
  print $ui->DumpExploits(2, $exploits);
  print "\n";
}

sub xCallback { }
