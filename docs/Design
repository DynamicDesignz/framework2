Right now there is sort of a clutter between the metasploit framework and Pex.

The way I look at it, Pex should be a stand alone exploit library, could have
been written by anyone, and it should be able to stand alone.  We just happen
to be taking advantage of this library.  So that means that nothing in Pex
should really have to do with metasploit, it should be what it originially was
ment to be.  Thus spawns the Msf classes.

So this means msf could pretty much stand alone w/o metasploit, and vice versa.
Atleast its a good goal to have in mind. This makes you rethink where the
Socket classes, etc, belong in the picture.

The way I see it, Pex should include things like:
1) Nop functions, exploits development helpers, etc
2) The Pex Encoder rocks, and should stay in Pex (msf will use it of course)
3) Protocol libraries fit well into Pex.

Then the Msf classes should include:
1) The inheritence structures for metasploit, Msf::Exploit, etc
2) The socket class, Msf::Socket (which could turn around and use Pex::Socket
   but this allows use to do things like manage the proxies from the Msf side.

So for when we are writing the UI's (which we now have 3 of), they should never
even use Pex.  Mostly likely some Msf classes will use Pex, but the UI code
itself should not have to.

Everything inherits from Msf::Base, so now we have GetEnv and SetEnv
methods in every Msf object.  This alows us to do cool things.
We can use the RHOST and LPORT, etc specifications in the config file to
autofill paramaters, so even for the cli version, I can setup my LHOST
and LPORT, and not have to specify them each time on the cli.

The global config also allows you to jump between gui's and save your settings.
If there is something that is gui specific, just prefix is like webSometing.

Also the print functions (and the functions to replace them) should be in Base.
So then a UI just replaces the functions, and everything will be using those
print functions, so even for prints you could be using the functions, which
adds the ability to more easily do some stuff (use sockets instead of STDOUT, 
etc)

Also you will have functions like FatalError, which prints the error and then
dies out, but this death will depend on the UI.

Pex seems to be pretty much static functions. Msf is the opposite, another good
reason to have them split apart (and a good way to realize where to split)


In order to nicely do inheritance, classes that are designed to be parents
classes should have a constructor similar to this.
sub new {
  my $class = shift;
  my $hash = @_ ? shift : { };
  my $self = bless($hash, $class);
  return($self);
}

This allows derived classes like an exploit, to do something like this
sub new {
  my $class = shift;
  return($class->SUPER::new({'Info' => \%info}, @_));
}                                                

Then the parent class could optionally have something like this...
sub new {
  my $class = shift;
  my $hash = @_ ? shift : { };
  my $self = bless($hash, $class);
  $self->SetDefaults;
  $self->{'Opts'} = shift;
  $self->{'EncodedPayload'} = shift;
  return($self);
}

Since every derived object (such at exploits) are all treated the same (as a
Msf::Exploit), but a Msf::Exploit is never instantiated, this constructor
handles the situation well.

This also plays nice with multiple inheritence, since now we can do something
like this.
sub new {
  my $class = shift;
  my $self = Base1::new($class, {'Info' => \%info}, @_));
  $self = Base2::new($class, $self);
  return($self);
}

However this means that only one base class can get passed parameters from the
new call on the derived class, which basically mean while the class may be the
product of two parents, its really either a "Mama's Boy" or a "Papa's Boy".

I'm not sure if multiple inheritance will even pop up in this project, my
initial thoughts on something like msfconsole would be multiple inheritance
from the Msf::UI and Msf::PsuedoShell classes, but Msf::Psuedoshell is better
off just used, not inherited.

Another problem that can arise is name collision in the inheritance structure.
You can sort of get around this by doing $self->{__PACKAGE__.'foo'}, and I
might still do so, but then my standard of the _foo function would still
get overriden if the child class was following the same standard. And we want
a child class to be able to access the parents attributes, so the best solution
would just to be clear about what internal variables everything is using, and
to be careful not to create any collisions. The __PACKAGE__ syntax is still
most likely best just to avoid silly exploit programmers who may unknowingly
use a attribute defined higher up in the inheritance structure.  Another and
probably better solution to this is to pick a naming style and stick with it
so if we are always FooBar, that means that can use any variables they want if
the first letter is lowercase, and they won't have to worry about collisions.
But also we want their variable names to follow along in a nice fasion to allow
for the global config for advanced situations.  I've been thinking about an
automatic way for them to define/set/access config variables for themself
(Most likely just parsing $self for the inital class), and do automatic merging
between their defaults and the environment.
