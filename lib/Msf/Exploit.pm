#!/usr/bin/perl
###############

##
#         Name: Exploit.pm
#       Author: spoonm <ninjatools [at] hush.com>
#      Version: $Revision$
#  Description: Parent class for exploit Modules, inherits from Module.
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

package Msf::Exploit;
$VERSION = 2.0;
use strict;
use base 'Msf::Module';

my $defaults =
{
  'Payload'     => undef,
  'Nop'         =>
    {
      'BadRegs'  => ['esp', 'ebp'],
    },
  'AutoOpts'    => { },
};

sub new {
  my $class = shift;
  my $hash = @_ ? shift : { };
  $hash->{'_InfoDefaults'} = $defaults;
  my $self = $class->SUPER::new($hash);
  $self->SetDefaults($defaults);
  return($self);
}

# Exploit Specific Accessors
sub Payload       { my $self = shift; return($self->Info->{'Payload'}); }
sub Nop           { my $self = shift; return($self->Info->{'Nop'}); }
sub Targets       { my $self = shift; return($self->Info->{'Targets'}); }
sub AutoOpts      { my $self = shift; return $self->Info->{'AutoOpts'}; }

sub DefaultTarget {
  my $self = shift;
  my $target = $self->Info->{'DefaultTarget'};
  $target = -1 if(!defined($target));
  return($target);
}

sub Prepare {
  my $self = shift;
  my $autoOpts = $self->AutoOpts;
  if($autoOpts) {
    foreach my $key (%{$autoOpts}) {
      if(!defined($self->GetVar($key))) {
        $self->PrintDebugLine(5, "AutoOpts setting $key -> " . $autoOpts->{$key});
        $self->SetTempEnv($key, $autoOpts->{$key});
      }
    }
  }
}

# Default fallthrough methods
sub Exploit {
  my $self = shift;
  $self->PrintLine('[*] No exploit method has been defined for this module.');
}

# Return true if no check has been defined
sub Check {
  my $self = shift;
  $self->PrintLine('[*] No check has been implemented for this module');
  return(1);
}

sub TargetsList {
  my $self = shift;
  my $targets = $self->Targets;
  my @targets;

  return if(ref($targets) ne 'ARRAY');

  my $i = 0;
  foreach my $target (@{$targets}) {
    $targets[$i++] = $target->[0];
  }
  return(@targets);
}

sub Handler {
  my $self = shift;
  my $sock = shift;
  my $payload = $self->GetLocal('_Payload');
  if($payload) {
    $sock = $sock->GetSocket if(ref($sock) =~ /Msf::Socket/);
    $payload->ChildHandler($sock);
  }
}

# We have this so the module can override it, and make decisions based on arch
# etc (access _Payload)
sub PayloadPrependEncoder {
  my $self = shift;
  return($self->Payload->{'PrependEncoder'});
}
sub PayloadPrepend {
  my $self = shift;
  return($self->Payload->{'Prepend'});
}
sub PayloadAppend {
  my $self = shift;
  return($self->Payload->{'Append'});
}
sub PayloadSpace {
  my $self = shift;
  return($self->Payload->{'Space'});
}
sub PayloadBadChars {
  my $self = shift;
  return($self->Payload->{'BadChars'});
}
sub PayloadMinNops {
  my $self = shift;
  return($self->Payload->{'MinNops'});
}
sub PayloadMaxNops {
  my $self = shift;
  return($self->Payload->{'MaxNops'});
}

sub NopBadRegs {
  my $self = shift;
  return($self->Nop->{'BadRegs'});
}

sub CheckCode {
  my $self = shift;
  my $code = shift;
  my $codes = {
    'error'    => -1,
    'notvuln'  => 0,
    'vuln'     => 1,
    'inconclusive'   => 2,
    'maybe'    => 3,
    'likely'   => 4,
    'probably' => 5,
  };

  foreach (keys(%{$codes})) {
    return($codes->{$_}) if($_ eq lc($code));
    return($_) if($codes->{$_} eq $code);
  }
  return;
}

1;
