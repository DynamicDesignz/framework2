#!/usr/bin/perl
###############

##
#         Name: Exploit.pm
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

package Msf::Exploit;
$VERSION = 2.0;
use strict;
use base 'Msf::Module';

my $defaults =
{
  'Name'        => 'No Name',
  'Version'     => '0.0',
  'Author'      => 'No Author',
  'Arch'        => [ ],
  'OS'          => [ ],
  'Keys'        => [ ],
  'Priv'        => 0,
  'UserOpts'    => { },
  'Payload'     => undef,
  'Refs'        => [ ],
  'Description' => 'No Description',
  'Targets'     => [ ],
  'AutoOpts'    => { },
};

sub new {
  my $class = shift;
  my $hash = @_ ? shift : { };
  my $self = $class->SUPER::new($hash);
  $self->SetDefaults($defaults);
  $self->{'EncodedPayload'} = shift;
  return($self);
}

# Internal accessors/mutators
sub _Info {
  my $self = shift;
  $self->{'Info'} = shift if(@_);
  return($self->{'Info'});
}
sub _EncodedPayload {
  my $self = shift;
  $self->{'EncodedPayload'} = shift if(@_);
  return($self->{'EncodedPayload'});
}

# External Mutators
sub SetEncodedPayload {
  my $self = shift;
  return($self->_EncodedPayload(@_));
}

# Wazza?
sub set_error
{
    my ($self,$error) = @_;
    my @cinf = caller(1);
    $self->{"ERROR"} = $cinf[3] . " => $error";
}

sub Error  { my $self = shift; return $self->{ERROR}  }

# Default fallthrough methods
sub Exploit {
  my $self = shift;
  $self->PrintLine('[*] No exploit method has been defined for this module.');
}

sub Check {
  my $self = shift;
  $self->PrintLine('[*] No check has been implemented for this module.');
}

sub Targets {
    my $self = shift;
    my $targets = $self->{'Info'}->{'Targets'};
    my @targets = ();

    return @targets if ref($targets) ne 'ARRAY';

    my $i = 0;
    foreach my $target (@{$targets}) { $targets[$i++] = $target->[0] }
    return(@targets);
}


# We have this so the module can override it, and make decisions based on arch
# etc
sub PayloadPrepend {
  my $self = shift;
  my $payload = shift;
  return($self->{'Info'}->{'Payload'}->{'Prepend'});
}
sub PayloadAppend {
  my $self = shift;
  my $payload = shift;
  return($self->{'Info'}->{'Payload'}->{'Append'});
}


1;
