#!/usr/bin/perl
###############

##
#         Name: msfpescan
#       Author: H D Moore <hdm [at] metasploit.com>
#      Version: $Revision$
#  Description: Search PE files for given opcodes
#      License:
#
#      This file is part of the Metasploit Exploit Framework
#      and is subject to the same licenses and copyrights as
#      the rest of this package.
#
##

require 5.6.0;

use strict;
use vars qw($VERSION);

use FindBin qw{$Bin};
use Getopt::Std;

use lib "$Bin/lib";

use Pex;
use Pex::PEInfo;

$VERSION = "1.0";

my %opts = ();

my %jmps =
    (
        "\xff\xd0" => ["eax", "call"],
        "\xff\xe0" => ["eax", "jmp" ],
        "\xff\xd1" => ["ecx", "call"],
        "\xff\xe1" => ["ecx", "jmp" ],
        "\xff\xd2" => ["edx", "call"],
        "\xff\xe2" => ["edx", "jmp" ],
        "\xff\xd3" => ["ebx", "call"],
        "\xff\xe3" => ["ebx", "jmp" ],
        "\xff\xe4" => ["esp", "jmp" ],
        "\xff\xd5" => ["ebp", "call"],
        "\xff\xe5" => ["ebp", "jmp" ],
        "\xff\xd6" => ["esi", "call"],
        "\xff\xe6" => ["esi", "jmp" ],
        "\xff\xd7" => ["edi", "call"],
        "\xff\xe7" => ["edi", "jmp" ],
        
        "\x50\xc3" => ["eax", "push"],
        "\x53\xc3" => ["ebx", "push"],
        "\x51\xc3" => ["ecx", "push"],
        "\x52\xc3" => ["edx", "push"],
        "\x54\xc3" => ["esp", "push"],
        "\x55\xc3" => ["ebp", "push"],
        "\x56\xc3" => ["esi", "push"],
        "\x57\xc3" => ["edi", "push"],
    );

my %pops =
    (
        "eax"   => "\x58",
        "ebx"   => "\x5b",
        "ecx"   => "\x59",
        "edx"   => "\x5a",
        "esi"   => "\x5e",
        "edi"   => "\x5f",
        "ebp"   => "\x5d",
    );


getopts("f:j:c:sx:a:l:I:n", \%opts);
if (! defined($opts{'f'}) || (! defined($opts{'j'}) && ! defined($opts{'c'}) && ! defined($opts{'x'}) && ! defined($opts{'a'}) && ! $opts{'s'})) { usage() }

my $filename = $opts{'f'};
my $pe = Pex::PEInfo->new($filename);

if (! $pe)
{
    print STDERR "$0: could not load PE image from file.\n";
    exit(0);
}

my $data = $pe->Raw;
if ($opts{'I'}) { $pe->ImageBase($opts{'I'}) }

# Scan for pop/pop/ret addresses
if (exists($opts{'s'})) 
{
    foreach my $rA (keys(%pops))
    {
        foreach my $rB (keys(%pops))
        {
            my $opc = $pops{$rA} . $pops{$rB} . "\xc3";
            my $lst = 0;
            my $idx = index($data,  $opc, $lst);
            while ($idx > 0)
            {
                printf("0x%.8x   $rA $rB ret\n", $pe->OffsetToVirtual($idx));
                $lst = $idx + 1;
                $idx = index($data, $opc, $lst);
            }
        }
    }
    exit(0);
}

# Scan for jmp/call/push,ret addresses
if (exists($opts{'j'})) 
{
    foreach my $opc (keys(%jmps))
    {
        next if ($opts{'j'} && lc($opts{'j'}) ne $jmps{$opc}->[0]);

        my $lst = 0;
        my $idx = index($data,  $opc, $lst);
        while ($idx > 0)
        {
            my ($reg, $typ) = @{$jmps{$opc}};
            printf("0x%.8x   $typ $reg\n", $pe->OffsetToVirtual($idx));
            $lst = $idx + 1;
            $idx = index($data, $opc, $lst);
        }
    }
    exit(0);
}


if (exists($opts{'c'}))
{
    my $bytesarg =  $opts{'c'};
    my $byteslen = (length($bytesarg) / 2) + $opts{'l'};

    if (length($bytesarg) % 2 != 0)
    {
        print "$0: bytes should be a string of hex digits (ie 'FFE4')\n";
        exit(0);
    }

    $bytesarg =~ s/([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
    if (length($bytesarg) > $byteslen)
    {
        print "$0: length calculation is wrong: $bytesarg\n";
        exit(0);
    }

    my $lst = 0;
    my $idx = index($data,  $bytesarg, $lst);
    while ($idx > 0)
    {
        my $found = substr($data, $idx, $byteslen);
        printf("0x%.8x   %s\n", $pe->OffsetToVirtual($idx), hexOutput($found));
        $lst = $idx + 1;
        $idx = index($data, $bytesarg, $lst);
    }
    exit(0);
}

# Regex
if(exists($opts{'x'})) {
  my $regex = $opts{'x'};
  $regex .= '.' x $opts{'l'};
  while($data =~ m/($regex)/g) {
    my $found = $1;
    my $loc = pos($data) - length($found);
    printf("0x%.8x   %s\n", $pe->OffsetToVirtual($loc), hexOutput($found));
  }
  exit(0);
}

elsif(exists($opts{'a'})) {
  my $address = hex($opts{'a'});
  my $length = exists($opts{'l'}) ? $opts{'l'} : 1;
  my $loc = $address - $pe->OffsetToVirtual(0);
  my $found = substr($data, $loc, $length);
  printf("0x%.8x   %s\n", $pe->OffsetToVirtual($loc), hexOutput($found));
}


sub hexOutput {
  my $data = shift;
  my $string = unpack('H*', $data);
  if($opts{'n'}) {
    my $tempString = $string;
    $tempString =~ s/(..)/\\x$1/g;
    $string .= "\n--- ndisasm output ---\n";
    $string .= `echo -ne "$tempString" | ndisasm -u /dev/stdin`;
    $string .= "--- ndisasm output ---";
  }
  return($string);
}


sub usage 
{
    print STDERR "  Usage: $0 -f filename.exe <mode> <options>\n";
    print STDERR "Modes:\n";
    print STDERR "         -j  <reg>    Search for jump equivalent instructions\n";
    print STDERR "         -c  <data>   Search for custom byte pattern (ie 'FFE4')\n";
    print STDERR "         -s           Search for pop+pop+ret combinations\n";
    print STDERR "         -x  <regex>  Search for regex match\n";
    print STDERR "         -a <address> Find code at VMA adress\n";
    print STDERR "Options:\n";
    print STDERR "         -l  <count>  Number of bytes to show after match\n";
    print STDERR "         -I  address  Use this ImageBase address instead of one from file\n";
    print STDERR "         -n           Print ndisasm output of data\n";
    print STDERR "\n";
    exit(0);

}
